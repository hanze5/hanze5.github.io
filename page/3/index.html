<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="也许不会有人进来吧">
<meta property="og:url" content="http://hanze5.github.io/page/3/index.html">
<meta property="og:site_name" content="也许不会有人进来吧">
<meta property="og:locale">
<meta property="article:author" content="Dawnlake">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hanze5.github.io/page/3/"/>





  <title>也许不会有人进来吧</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">也许不会有人进来吧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/07/15/23-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/15/23-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" itemprop="url">Linux内核——进程的虚拟地址空间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-15T09:58:12+08:00">
                2022-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<h2 id="进程虚拟地址空间的管理机制"><a href="#进程虚拟地址空间的管理机制" class="headerlink" title="进程虚拟地址空间的管理机制"></a>进程虚拟地址空间的管理机制</h2><h3 id="什么是虚拟地址空间"><a href="#什么是虚拟地址空间" class="headerlink" title="什么是虚拟地址空间"></a>什么是虚拟地址空间</h3><p>内存的页表映射机制实现虚拟地址到物理地址的转换。内核只需维护一个页目录表，而多个进程共享用户空间是不安全的，需要做管理,不然用户空间太大，若每个进程也只维护一个页目录表的话，查找管理不便。那么虚拟地址空间的管理机制是什么样的呢。</p>
<p><img src="/images/23/1678148132831.png" alt="1678148132831"></p>
<p>在linux中，proc是一个虚拟文件系统，也是一个控制中心，里面储存是当前内核运行状态的一系列特殊文件；该系统只存在内存当中，以文件系统的方式为访问系统内核数据的操作提供接口，可以通过更改其中的某些文件来改变内核运行状态。</p>
<p>写一个最简单的c语言程序并运行</p>
<p>!<img src="/images/23/1678148938760.png" alt="1678148938760"></p>
<p>使用top命令查看进程的ID,</p>
<p><img src="/images/23/1678148993319.png" alt="1678148993319"></p>
<p>使用cat /proc/232759/maps可以查看进程的虚拟地址空间的信息</p>
<p><img src="/images/23/1678149193044.png" alt="1678149193044"></p>
<p>含义：</p>
<p><img src="/images/23/1678149419801.png" alt="1678149419801"></p>
<h3 id="虚拟地址空间的管理"><a href="#虚拟地址空间的管理" class="headerlink" title="虚拟地址空间的管理"></a>虚拟地址空间的管理</h3><p>内核使用下面的数据结构来描述一个进程的的虚拟地址空间，文件路径<code>/include/linux/mm_types.h</code>，其中第一个成员 <code>vm_area_struct</code>被用来描述一个虚拟内存区域（VMA），一个地址空间由多个虚拟内存区域，可以看到是一个链表的形式。<code>pgd_t * pgd</code> 指向页目录表，地址映射必备，如果两个进程有同一个页目录表，那这两个进程甚至可以当成线程使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>		<span class="comment">/* list of VMAs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">	u64 vmacache_seqnum;                   <span class="comment">/* per-thread vmacache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_base;		<span class="comment">/* base of mmap area */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_legacy_base; <span class="comment">/* base of mmap area in bottom-up allocations */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> task_size;		<span class="comment">/* size of task vm space */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> highest_vm_end;   <span class="comment">/* highest vma end address */</span></span><br><span class="line">	<span class="type">pgd_t</span> * pgd;                    <span class="comment">//页目录表的地址</span></span><br><span class="line">	<span class="type">atomic_t</span> mm_users;	<span class="comment">/* How many users with user space? */</span></span><br><span class="line">	<span class="type">atomic_t</span> mm_count;  <span class="comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_ptes;			<span class="comment">/* PTE page table pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_pmds;			<span class="comment">/* PMD page table pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> map_count;				    <span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">spinlock_t</span> page_table_lock;		<span class="comment">/* Protects page tables and some counters */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>		<span class="comment">/* List of maybe swapped mm&#x27;s.	These are globally strung</span></span><br><span class="line"><span class="comment">						 * together off init_mm.mmlist, and are protected</span></span><br><span class="line"><span class="comment">						 * by mmlist_lock</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;	<span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;	<span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_vm;		<span class="comment">/* Total pages mapped */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> locked_vm;	<span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pinned_vm;	<span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data_vm;		<span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> exec_vm;		<span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stack_vm;		<span class="comment">/* VM_STACK */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> def_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">	 * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_rss_stat</span> <span class="title">rss_stat</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">cpumask_var_t</span> cpu_vm_mask_var;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">	<span class="type">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">	<span class="type">spinlock_t</span>			ioctx_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kioctx_table</span> __<span class="title">rcu</span>	*<span class="title">ioctx_table</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">	 * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">	 * order for it to be changed:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">	 * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">	 * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">	 * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> *<span class="title">exe_file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">	<span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page_table_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPUMASK_OFFSTACK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> <span class="title">cpumask_allocation</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * numa_next_scan is the next time that the PTEs will be marked</span></span><br><span class="line"><span class="comment">	 * pte_numa. NUMA hinting faults will gather statistics and migrate</span></span><br><span class="line"><span class="comment">	 * pages to new nodes if necessary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> numa_next_scan;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restart point for scanning and setting pte_numa */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> numa_scan_offset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* numa_scan_seq prevents two threads setting pte_numa */</span></span><br><span class="line">	<span class="type">int</span> numa_scan_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_NUMA_BALANCING) || defined(CONFIG_COMPACTION)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * An operation with batched TLB flushing is going on. Anything that</span></span><br><span class="line"><span class="comment">	 * can move process memory needs to flush the TLB when moving a</span></span><br><span class="line"><span class="comment">	 * PROT_NONE or PROT_NUMA mapped page.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> tlb_flush_pending;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span></span><br><span class="line">	<span class="comment">/* See flush_tlb_batched_pending() */</span></span><br><span class="line">	<span class="type">bool</span> tlb_flush_batched;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uprobes_state</span> <span class="title">uprobes_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_INTEL_MPX</span></span><br><span class="line">	<span class="comment">/* address of the bounds directory */</span></span><br><span class="line">	<span class="type">void</span> __user *bd_addr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HUGETLB_PAGE</span></span><br><span class="line">	<span class="type">atomic_long_t</span> hugetlb_usage;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">async_put_work</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那我们再来看看虚拟内存区域的（VMA）这个结构，内核将每个内存区域当作一个单独的内存对象管理，因此我们程序的代码段、数据段、未初始化全局变量、堆栈这种都有自己的 <code>vm_area_struct</code>然后再由虚拟地址空间把这些 <code>vm_area_struct</code>给串起来。</p>
<p>这里面 有一个mm_struct指针 而mm_struct又与tast_struct有一一的对应关系，因此就可以知道这块虚拟内存区域属于的哪一个进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. 就是权限 可读可写还是什么的  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="type">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面这个图太牛了</p>
<p><img src="/images/23/1678151170442.png" alt="1678151170442"></p>
<p>使用以下函数可以把文件映射到进程的地址空间里，具体就是再给这个进程分配一个VMA并把这个东西加到<code>mm_struct</code>里边</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr， <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span> ;</span><br></pre></td></tr></table></figure>
<p>在linux中，如果clone()时设置CLONE_VM标志，我们把这样的进程称作为线程。线程之间共享同样的虚拟内存空间。fork()函数利用copy_mm()函数复制父进程的mm_struct,也就是current-&gt;mm域给其子进程。(/kernel/fork.c) 参数中的<code>struct task_struct *tsk</code>是子进程的task struct</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernel/fork.c&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,<span class="keyword">struct</span> task_struct *tsk)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;min_flt = tsk-&gt;maj_flt = <span class="number">0</span>;</span><br><span class="line">	tsk-&gt;nvcsw = tsk-&gt;nivcsw = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line">	tsk-&gt;last_switch_count = tsk-&gt;nvcsw + tsk-&gt;nivcsw;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Are we cloning a kernel thread?</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We need to steal a active VM for that..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//取当前进程的mm</span></span><br><span class="line">	oldmm = current-&gt;mm;</span><br><span class="line">	<span class="keyword">if</span> (!oldmm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize the new vmacache entries */</span></span><br><span class="line">	vmacache_flush(tsk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">		<span class="type">atomic_inc</span>(&amp;oldmm-&gt;mm_users);</span><br><span class="line">		mm = oldmm;</span><br><span class="line">		<span class="keyword">goto</span> good_mm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	mm = dup_mm(tsk);</span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把mm赋给子进程的mm</span></span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line">	tsk-&gt;mm = mm;</span><br><span class="line">	tsk-&gt;active_mm = mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_nomem:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户空间的mmap函数在内核中的实现"><a href="#用户空间的mmap函数在内核中的实现" class="headerlink" title="用户空间的mmap函数在内核中的实现"></a>用户空间的mmap函数在内核中的实现</h2><p>用户空间使用mmap函数可以将一个文件或者设备映射到进程的地址空间去，上面说的，创建一个VMA加进去，到底是不是这样呢？映射的作用是，这样读写文件会快，如果不这么做的话，还会有用户空间和内核空间的数据拷贝过程，数据多的时候会极大影响性能。</p>
<p>用户空间的mmap()会通过系统调用调用到内核的do_mmap()函数。<br>do_mmap()函数会:<br>1.首先创建一个新的VMA并初始化，然后加入进程的虚拟地址空间里。<br>2.然后调用底层的mmap函数建立VMA和实际物理地址的联系（建立页表) 底层的mmap会根据文件类型不同有差异化。</p>
<h3 id="驱动的mmap实现"><a href="#驱动的mmap实现" class="headerlink" title="驱动的mmap实现"></a>驱动的mmap实现</h3><p>设备驱动的mmap实现主要是将这个物理设备的可操作区域映射到一个进程的虚拟地址空间。这样用户空间就可以直接采用指针的方式访问设备的可操作区域。在驱动中的mmap实现主要是完成一件事，就是建立设备的可操作区域到进程虚拟空间地址的映射过程。同时也需要保证这段映射的虚拟存储器区域不会被进程当做一般的空间使用，因此需要添加一系列的保护方式。</p>
<h4 id="驱动的mmap建立虚拟地址和物理地址的映射"><a href="#驱动的mmap建立虚拟地址和物理地址的映射" class="headerlink" title="驱动的mmap建立虚拟地址和物理地址的映射"></a>驱动的mmap建立虚拟地址和物理地址的映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立vma和物理地址的映射的工作由remap_pfn_range来完成，原型如下:</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma，, <span class="type">unsigned</span> <span class="type">long</span></span></span><br><span class="line"><span class="params">virt_addr，<span class="type">unsigned</span> <span class="type">long</span> pfn，<span class="type">unsigned</span> <span class="type">long</span> size，<span class="type">pgprot_t</span> prot)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vma            需要建立映射的VMA</span></span><br><span class="line"><span class="comment">virt_addr      需要建立映射的VMA的起始地址</span></span><br><span class="line"><span class="comment">pfn            页帧号，对应虚拟地址应当被映射的物理地址．这个页帧号简单地是物理地址右移 PAGE_SHIFT位 一般是12位</span></span><br><span class="line"><span class="comment">size           需要建立映射的VMA的大小，以字节.</span></span><br><span class="line"><span class="comment">prot           使用在vma-&gt;vm_page _prot中找到的值.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们可以重新回去看看file_operation这个结构体，这个就代表这驱动提供的能力，也就是要让驱动有mmap的能力，就需要实现 int(*mmap)函数，建立file 与 VMA的映射。就是用上面 的函数</p>
<p><img src="/images/23/1678153727517.png" alt="1678153727517"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br></pre></td></tr></table></figure>
<p>因此mmap是一种零拷贝技术。</p>
<h3 id="进程的用户栈和内核栈"><a href="#进程的用户栈和内核栈" class="headerlink" title="进程的用户栈和内核栈"></a>进程的用户栈和内核栈</h3><ul>
<li>用户栈:<br>基于进程的虚拟地址空间的管理机制实现;以VMA的形式实现;</li>
<li>内核栈:<br>每个进程都有属于自己的独自的内核栈;<br>大小根据不同的体系结构而不同，一般为1个page，也就是4K;</li>
</ul>
<h3 id="linux内核中进程的描述方式"><a href="#linux内核中进程的描述方式" class="headerlink" title="linux内核中进程的描述方式"></a>linux内核中进程的描述方式</h3><p>/include/linux/sched.h 有点长 不忘往这里放了吧  一个struct 四五百行，，，描述了linux进程的通用部分。然后它里面有一个成员结构体是，thread_info 描述了特定体系结构的汇编代码段需要访问的那部分数据。</p>
<p><img src="/images/23/1678169995715.png" alt="1678169995715"></p>
<h3 id="内核栈定义如下："><a href="#内核栈定义如下：" class="headerlink" title="内核栈定义如下："></a>内核栈定义如下：</h3><p><img src="/images/23/1678170171116.png" alt="1678170171116"></p>
<p><code>thread_info</code>包含了 自身体系架构的一些属性，不同体系有差异所以要单独实现，比如下面是arm的。</p>
<p>arch/arm/include/asm/thread_info.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	<span class="type">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span></span><br><span class="line">	<span class="type">mm_segment_t</span>		addr_limit;	<span class="comment">/* address limit */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* cpu */</span></span><br><span class="line">	__u32			cpu_domain;	<span class="comment">/* cpu domain */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_context_save</span>	<span class="title">cpu_context</span>;</span>	<span class="comment">/* cpu context */</span></span><br><span class="line">	__u32			syscall;	<span class="comment">/* syscall number */</span></span><br><span class="line">	__u8			used_cp[<span class="number">16</span>];	<span class="comment">/* thread used copro */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		tp_value[<span class="number">2</span>];	<span class="comment">/* TLS registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CRUNCH</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crunch_state</span>	<span class="title">crunchstate</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">fp_state</span>		<span class="title">fpstate</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(8)));</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">vfp_state</span>		<span class="title">vfpstate</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_THUMBEE</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thumbee_state;	<span class="comment">/* ThumbEE Handler Base register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/07/13/22-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/13/22-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%85%8D/" itemprop="url">Linux内核——内核空间的内存管理与分配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-13T08:05:12+08:00">
                2022-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<h2 id="页框和伙伴算法"><a href="#页框和伙伴算法" class="headerlink" title="页框和伙伴算法"></a>页框和伙伴算法</h2><ul>
<li>定义:内核使用struct page结构体描述每个物理页，也叫页框。一般一个页框对应一个4k的空间</li>
<li>场景:内核在很多情况下，需要申请连续的页框，而且数量不定，比如4个，5个，9个等。</li>
<li>实现: Linux把所有的空闲页框分组为11个块链表，每个链表上的页框块是固定的。在第i条链表中每个页框块都包含2的i次方个连续页。</li>
<li>注意:系统中每个页框块的第一个页框的物理地址是该块大小的整数倍。例如:大小为16个页框的块，其起始地址是16*2^12的倍数。</li>
</ul>
<p><img src="/images/22/1678103470108.png" alt="1678103470108"> </p>
<p>我要申请4k 就去找0里摘取一个；8k就找。</p>
<h2 id="页框操作"><a href="#页框操作" class="headerlink" title="页框操作"></a>页框操作</h2><p>分配2^order个连续的物理页，并返回一个指针，指向第一个页的page结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page * <span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br></pre></td></tr></table></figure>
<p>返回page页面所映射的的虚拟地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br></pre></td></tr></table></figure>
<h2 id="slab实现了内存的管理和分配"><a href="#slab实现了内存的管理和分配" class="headerlink" title="slab实现了内存的管理和分配"></a>slab实现了内存的管理和分配</h2><ul>
<li>slab层把不同的对象划分为所谓的高速缓存(cache)组，其中每个高速缓存都存放不同类型的对象;</li>
<li>每种对象类型对应一个高速缓存(cache) ;</li>
<li>例如一个高速缓存存放task_struct结构体，而另外一个高速缓存存放struct inode结构体;. </li>
<li>slab由一个或者多个物理上连续的页组成。每个高速缓存由多个slab组成。</li>
</ul>
<p><img src="/images/22/1678104047825.png" alt="1678104047825">|<img src="/images/22/1678104158296.png" alt="1678104158296"></p>
<p>slad又分为三个状态，用于形容 对象的分配情况。查看右图128B的情况，128Bcache中的每个对象大小都是128个字节，就是由2^15个page组成一个对象。每个slab又是由一个或多个page组成。</p>
<p>slab可以</p>
<ol>
<li>减少伙伴算法在分配小块连续内存时所产生的内部碎片;</li>
<li>将频繁使用的对象缓存起来，减少分配、初始化和释放对象的时间开销。</li>
<li>通过着色技术调整对象以更好的使用硬件高速缓存;</li>
</ol>
<p>这块没怎么看明白。。。。这里留下网址以后再继续看</p>
<p><a target="_blank" rel="noopener" href="https://www.toutiao.com/article/6874373733595742727/?log_from=09cb26731ee35_1678104694035">linux操作系统内存大串讲：段页式，slab，共享内存-今日头条 (toutiao.com)</a></p>
<h2 id="slab高速缓存的使用"><a href="#slab高速缓存的使用" class="headerlink" title="slab高速缓存的使用"></a>slab高速缓存的使用</h2><ol>
<li><p>通过命令 cat /proc/slabinfo 可查看系统中的长用的</p>
<p><img src="/images/22/1678145522310.png" alt="1678145522310"></p>
</li>
<li><p>内核中用 <code>struct kmem_cache</code>表示一个高速缓存。   通过下面的方法创建高速缓存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  kmem_cache*  <span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">size_t</span> size,<span class="type">size_t</span> align,</span></span><br><span class="line"><span class="params">                                      <span class="type">unsigned</span> <span class="type">long</span> flags,<span class="type">void</span> (*ctor)(<span class="type">void</span>))</span> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>申请和释放高速缓存  和申请 slab。 申请高速缓存的实现运用到了申请slab</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">    </span><br><span class="line">static_always_inline <span class="type">void</span> * <span class="title function_">slab_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags, <span class="type">unsigned</span> <span class="type">long</span> caller)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="内核中的最常用的内存申请"><a href="#内核中的最常用的内存申请" class="headerlink" title="内核中的最常用的内存申请"></a>内核中的最常用的内存申请</h2><ol>
<li>给硬件分配内存必须连续</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> _always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line"><span class="comment">//返回一个指向内存块的指针，其内存块大小至少size大小，所分配的内存在物理上是连续的。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vzalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span><span class="comment">//多了一步初始化操作 初始化成0</span></span><br><span class="line"><span class="comment">//返回一个指向内存块的指针，其内存块大小至少size大小，所分配的内存在物理上无需连续。</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/22/1678105707629.png" alt="1678105707629"></p>
<h3 id="kzalloc实现"><a href="#kzalloc实现" class="headerlink" title="kzalloc实现"></a>kzalloc实现</h3><p>我们的代码中就用到了<img src="/images/22/1678105885291.png" alt="1678105885291"></p>
<p>它的内部就是用kmalloc实现的，只是多了一步初始化为0的操作。</p>
<p><img src="/images/22/1678105935522.png" alt="1678105935522"></p>
<p>kmalloc的源码在/linux-4.9.229/include/linux/slab.h</p>
<p><img src="/images/22/1678105981827.png" alt="1678105981827"></p>
<p>大部分情况不会进入到if的判断里面，下图代码在 /mm/slab.c</p>
<p><img src="/images/22/1678106254461.png" alt="1678106254461"></p>
<p>到底依赖伙伴系统的算法。根据size和flag得到对应的高速缓存，通过调用kmalloc_slab里找到合适的缓存，然后找到对象返回到ret。kmalloc_slab的实现在/mm/slab_common.c</p>
<p><img src="/images/22/1678106514598.png" alt="1678106514598"></p>
<p>​        可以猜测到，通过大小查索引，是范围查找，合适的缓存。</p>
<p><img src="/images/22/1678106829368.png" alt="1678106829368"></p>
<p>  <img src="/images/22/1678106877955.png" alt="1678106877955"></p>
<p>妙啊！ 除以8算出8的几倍，通过倍数当作索引来找出合适的size</p>
<p>（这块儿看了好久都没理顺，打算先放一放往下看了。。。。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/12/06/2.%E5%85%B3%E4%BA%8EFPGA%E5%85%A8%E5%B1%80%E5%B8%83%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/06/2.%E5%85%B3%E4%BA%8EFPGA%E5%85%A8%E5%B1%80%E5%B8%83%E7%BA%BF/" itemprop="url">关于FPGA全局布线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-06T10:07:27+08:00">
                2021-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接触fpga布线是从复位杯的比赛开始。但是比赛的问题和数据已经将布线问题高度抽象化为了一个数学问题。所以个人认为无法实际支撑fpga布线的研究，因为在读相关文献的时候常常有看不懂的地方。所以从现在起阅读并翻译《MAPPING AND FPGA GLOBAL ROUTING USING MEAN FIELD ANNEALING》第三章的内容。<br>有些部分因怕翻译有误所以也copy了原文。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="/images/2/2.cover1.png" alt="封面1"></th>
<th><img src="/images/2/2.cover2.png" alt="封面2"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="FPGAs-amp-Global-Routing"><a href="#FPGAs-amp-Global-Routing" class="headerlink" title="FPGAs  &amp;  Global Routing"></a>FPGAs  &amp;  Global Routing</h1><ul>
<li>介绍FPGA以及其物理设计的简要步骤</li>
<li>路由架构，global routing problem 以及 经典解决方案</li>
<li>对global routing problem 进行建模</li>
</ul>
<h2 id="1-Introduction-to-Field-Programmable-Gate-Arrays"><a href="#1-Introduction-to-Field-Programmable-Gate-Arrays" class="headerlink" title="1.Introduction to Field Programmable Gate Arrays"></a>1.Introduction to Field Programmable Gate Arrays</h2><p>Field Programmable gate arrays (FPGAs)是新的电子可编程集成电路，具有高集成性和高速的周转时间。在VLSI设计自动化中，制造时间是一个比较重要的问题，为了减少制造互连的时间而引入可编程器件。<br>FPGA是ASIC设计市场中非常流行的可编程器件。FPGA可以减少制造周转时间和成本。在其最简单的形式中，FPGA由一个<strong>可编程逻辑块阵列</strong>和<strong>路由网络</strong>组成，以<strong>实现逻辑块的互连</strong>。可编程逻辑块可以由用户编程来实现一个小的逻辑功能。FPGA的一个重要特性是通过使用电子可编程的switches进行重新编程。商业的FPGA在 使用何种编程技术类型、 逻辑块的结构 和 路由结构 这几个方面有所不同。FPGA的逻辑块可以像晶体管一样简单，也可以像微处理器一样复杂。它通常能够实现许多不同的组合和顺序逻辑功能。FPGA的逻辑块可以分为晶体管对、基本的小门（如两个输入的NAND）、多路复用器和查找表。</p>
<h3 id="1-1-Logic-Blocks"><a href="#1-1-Logic-Blocks" class="headerlink" title="1.1  Logic Blocks"></a>1.1  Logic Blocks</h3><p>FPGA的不同逻辑块在尺寸和能力上有很大的不同。两个晶体管逻辑块只能实现一个反相器，但尺寸非常小，而Xilinx FPGA中使用的查找表逻辑块(look-up table，LUT)可以实现任何五个输入的逻辑功能，但它们的尺寸明显较大。<br>逻辑块可以按照粒度进行分类。粒度可以用各种方式定义，例如，逻辑块可以实现的布尔函数的数量，相当于两个输入NAND门的数量，晶体管的总数，输入和输出的数量。但一般来说，商业逻辑块可以分为两类：细粒度和粗粒度。使用细粒度逻辑块的主要优点是可使用的块被充分利用，主要缺点是需要较多的线段和可编程switch。</p>
<h3 id="1-2-Programming-Technologies"><a href="#1-2-Programming-Technologies" class="headerlink" title="1.2 Programming Technologies"></a>1.2 Programming Technologies</h3><p>FPGA是使用电子可编程开关进行编程的。根据这些可编程开关的特性，如导通电阻和电容，编程技术可分为三个主要类型。这三种类型是<strong><em>SRAM</em></strong>、<strong><em>antifuse</em></strong> 和 <strong><em>EPROM</em></strong>。</p>
<ul>
<li>SRAM编程技术使用静态的RAM cells去控制门和多路复用器。在SRAM中，switch是一个由一个SRAM位的状态来控制的导通的晶体管，故SRAM是易失性的。因此FPGA必须在芯片电源启动时及时加载和配置，它需要外部辅助的永久性存储提供编程位，比如PROM or EPROM. SRAM的优点是可快速重编程，最大的缺点就是占用面积大（实现个SRAM单元需要至少5个晶体管。）</li>
<li>antifuse是一种具有非编程状态的，两端之间具有极高的电阻。当在端之间施加一个极高的电压，两端就会被打通产生低电阻连接，这种连接是持久性的。编程antifuse需要额外的电路来提供可编程的高电压和高电流。使得antifuse本身的体积很小但是，加上额外的电路就不那么小了。</li>
<li>浮动门编程技术使用一种特殊技术，该技术在紫外线可擦EPROM和电可擦EEPROM中被发现。EPROM的主要优点是快速可编程性。另外，他也不需要额外的持久性存储在芯片通电时对其进行编程。然而，这种技术的加工步骤更为复杂且需要更多的高祖晶体管。</li>
</ul>
<h3 id="1-3-路由结构"><a href="#1-3-路由结构" class="headerlink" title="1.3 路由结构"></a>1.3 路由结构</h3><p>FPGA路由结构是对可编程switch和wiring segment的放置，以实现内部的编程性的逻辑互连。图3.1展示了一个典型的路由结构的模型。<br><img src="/images/2/2.FPGA路由结构.png" alt>  </p>
<p>一个wire segment是一条由可编程switch连接的线路，一条wire segment中可能会包含一个或多个switch。每个wire segment的末端都会附着一个switch。</p>
<ul>
<li>一个 track 是形成一条线段的一条或多条wire segment的序列；</li>
<li>一个 routing channel 是一组平行的track。  </li>
</ul>
<p>图3.1中还包含着两种基础的结构：switch block和connection block。</p>
<ul>
<li>一个switch block 提供水平和垂直线段之间的互连，当然也可以是水平与水平。</li>
<li>一个connection block在channel中提供逻辑块的输入和输出和wire segment的连接。<br><img src="/images/2/2.switch_block和connection_block.png" alt></li>
</ul>
<p>如图3.2所示，FPGA普遍拥有的两个重要的内部互连块。这些块内部的switch的数量对可路由性来说至关重要。switch数量越多路由选择就越多，但会影响路由质量和体积。<br>这些switch的数量及分布叫做FPGA的灵活性。switch block的灵活性记为$F_s$,connection block的灵活性记为$F_c$。$F_s$可以被定义为switch block提供给每个进入的wire segment的可以连接的总数。$F_c$可以被定义为channel中每个逻辑块可以连接的wire数。接下来展示两个商业FPGA的路由架构，它们分别来自Xilinx和Actel。</p>
<h4 id="The-Xilinx-Routing-Architecture"><a href="#The-Xilinx-Routing-Architecture" class="headerlink" title="The Xilinx Routing Architecture"></a>The Xilinx Routing Architecture</h4><p><img src="/images/2/2.结构Xilinx_3000_FPGA.png" alt><br>逻辑块通过connection_block与channel连接。由于使用的是SRAM编程技术所以连接点体积比较大，在 Xilinx 3000的$F_c$为2~3（有5条track通过block）。逻辑块的四个边上都有connection block，它们将不同的总共11个pin连接到wire segment。当pin被连接到水平或垂直的wire segment上之后，每个sire可以连接另一侧的15个可能的wire segment中的5~6个。Xilinx 3000的architecture提供了4种wire segment：</p>
<ul>
<li>General-purpose interconnect由通过switch block的wire segment组成。</li>
<li>Direct interconnect 由逻辑块直接与相邻最近的邻居逻辑块之间的互连。</li>
<li>Long lines，跨越芯片级的长度，提供high-fanout 均匀延迟连接。</li>
<li>Clock line，是跨越整个芯片的单个线网，由高驱动缓冲器驱动。（没理解）。</li>
</ul>
<h4 id="The-Actel-Routing-Architecture"><a href="#The-Actel-Routing-Architecture" class="headerlink" title="The  Actel  Routing  Architecture"></a>The  Actel  Routing  Architecture</h4><p><img src="/images/2/2.结构Actel_FPGA.png" alt><br>Actel的路由结构是非对称式的，水平方向要比垂直方向有更多的track。Actel FPGA的输入和输出引脚的连接性是不同的。对于输入引脚，每个引脚可以连接对应这一侧的channel种的所有track，。而输出引脚横跨逻辑块上面2个channel和下面2个channel，它可以连接它跨过的这四个channel中包含的所有channel。在Actel中没有独立可分离的switch block。相对应的起到该功能的东西分布在整个水平的channel中。所有的垂直的track都可以与入射的水平track相连接。每个水平的channel由22个track组成，每个track可划分成不同长度的segment。垂直的segment共有3种类型：输入段，输出端，和通过整个芯片高度或者重要部分的freeway。这允许比输出端允许的垂直距离更长。</p>
<h2 id="2-Physical-Design-Automation-of-FPGAs"><a href="#2-Physical-Design-Automation-of-FPGAs" class="headerlink" title="2  Physical Design Automation of FPGAs"></a>2  Physical Design Automation of FPGAs</h2><p>FPGA的物理设计流程包含三个主要步骤：partitioning,placement and routing.</p>
<h3 id="2-1-Partitioning"><a href="#2-1-Partitioning" class="headerlink" title="2.1 Partitioning"></a>2.1 Partitioning</h3><p>Partitioning is the separation of the logic into Logic  blocks. Partitioning has both a logical and physical component. The  connections within a logic blocks are constrained by the limited  routing architecture and limited number of blocks outputs. However, the quality of the resulting partitioning depends on how well the  placement can be done. The logical component has been investigated in the  context of technology mapping in logic optimization.<br>Partitioning 就是将逻辑划分成逻辑块。分区同时拥有着逻辑组件和物理组件。逻辑块内的连接受到路由结构的限制和块输出的数量。但是最终分区质量取决于分区的好坏。逻辑组件在逻辑优化的技术优化背景下应运而生。</p>
<h3 id="2-2-Placement"><a href="#2-2-Placement" class="headerlink" title="2.2 Placement"></a>2.2 Placement</h3><p>Placement starts with logic blocks and input-output blocks in partitioned netlist and decides which corresponding blocks on the chip  should  contain them. The FPGA  placement problem is very similar to  traditional standard cell and gate array placement problems. Many  of  existing algorithm place­ment algorithms are applicable, such as simulated annealing,force  directed relaxation and min-cut.<br>Placement从逻辑块和位于分区线网表中的输入-输出块开始进行，并决定了他们应该对应在哪个芯片哪个的块上。FPGA placement问题与传统的单元和门阵列的布局问题相似。现有的很多布局算法，如模拟退火算法、强定向松弛算法、最小裁剪。</p>
<h3 id="2-3-Routing"><a href="#2-3-Routing" class="headerlink" title="2.3 Routing"></a>2.3 Routing</h3><p>In general such a global  router divides the multipoint nets into two terminal nets and  routes  them with  minimumdistance path.<br>解决好所有电路的placement后，所有线网的每一个pin都必须连接。不同的FPGA结构有着不同的路由算法。FPGA的路由问题和standard cell和门阵列的设计一样复杂。FPGA路由可以分成：global routing and detailed routing。<br><img src="/images/2/2.Global_routing_and_Detailed_routing.png" alt><br>The global route defines route for each connection by assigning it a sequence of channel segments. After the paths are defined in terms of channel between two-pin connection detailed router chose specific wiring segments to implement the channel segment assigned during global routing.<br>主流的Global router会把多端线网花分为一组双端线网，然后使用最短路径算法。同时也要考虑平衡channel的密度。全局路由从粗粒度层面通过给出一条channel segment 序列来为每一条连接大致规划出一条路径。在这条路径以channel的形式确定下来后，由详细路由选择具体的wire segment 来实现global routing阶段设计出的路径。</p>
<h2 id="3-Global-Routing-Problem-in-Design-Automation-of-FPGAs"><a href="#3-Global-Routing-Problem-in-Design-Automation-of-FPGAs" class="headerlink" title="3. Global Routing Problem in Design Automation of FPGAs"></a>3. Global Routing Problem in Design Automation of FPGAs</h2><p> 全局路由为每个线网选择channel然后将具体的选择哪条wire segment 和 switch这种工作留给detailed router。全局路由为每个net决定哪些pin是真正需要被连接的。全局路由的最终目标是最小化channel密度之和。在许多研究中，FPGA中的路由问题都直接分配segment，而忽略了全局路由阶段。有一个独特的FPGA全局路由器：PGAroute.该路由器类似于standard cell的全局路由器，使用LocusRoute算法。</p>
<p>LocusRoute算法中，对每个多端线网执行以下三个步骤。<br>1) net的划分：用最小生成树算法将一个多端线网划分为一组双端线网。<br><img src="/images/2/2.简单的两转弯路径.png" alt><br>2) Route Generation and Evaluation:在这一步中考虑每一对pin之间的可能路径，并根据cost来选择最低的那条。<br>选择路径的方法是基于那些有2个转弯或者更少的路径.Locus评估两个物理pin之间所有两个弯道路径的cost，选择最低的那条。cost函数由channel的密度来定义。每个wire segment和switch block 被表示为cost array中的元素。<br>每一个cost array $H_{i,j}$中的元素,包含着通过wire segment(i,j)的路径数量.<br>The cost of path(P) is calculated as:  </p>
<script type="math/tex; mode=display">Cost(p)=\sum_{p} H_{i,j}</script><p>3) Reconstruction：这一步将所有的双端网重新连接在一起，然后performs assigns unique numbers to distinct segments of some nets in each channel. 在每个channel中，执行分配唯一的数字在某些网的不同段。<br>Locus route利用迭代策略，即在第一次所有线网被路由之后，每个线网再依次被撕裂和重新路由。迭代减少了顺序依赖，提高路由质量。</p>
<h2 id="4-Model-of-FPGA-for-Global-Routing"><a href="#4-Model-of-FPGA-for-Global-Routing" class="headerlink" title="4.Model of FPGA for Global Routing"></a>4.Model of FPGA for Global Routing</h2><p>商用的FPGA由以下部分组成：一个可编程逻辑块组成的规则的二维阵列（LB），一个可编程路由网络，switch boxes(SB)[3,1,2]. Logic blocks 被用来实现电路的功能；路由网络用来实现逻辑块和输入输出之间的连接。FPGA的路由网络包括wiring segment和connection blocks。基于FPGA的商业SRAM中，wiring segment可以分为三种类型（路由资源）：channel segments, long  lines and direct-interconnection.水平(垂直)的channel segment 由若干平行wire segment组成，它们连接水平(垂直)channel中的两个连续的SB。SB允许这些channel segments彼此可编程互连。direct-interconnection是相邻LB之间的连接。long  lines水平或竖直地穿过FPGA路由区域。connection block提供从LB的输入输出引脚到相应channel segments的wire segment的连接。每个引脚可以连接到一个通道中有限数量的wire segment上，这被称为connection block的灵活度。在本工作中，假设每个LB引脚可以连接到各自通道中的所有wire segment，把它作为我们的FPGA 模型的连接块。<br>direct-interconnections可以提供邻居LB之间的最小延迟的连接，long line在需要长距离传递信号是被使用（比如全局的时钟信号），这些路由资源在global routing中都没有被考虑到。因此我们关于的FPGA全局路由的模型只有可编程逻辑块（LB）,交换盒（SB）， channel segments。一个FPGA可以被建模为，二维的 由连接在水平和竖直channel segments中的LB组成的二维阵列，而SB则负责将水平和竖直的channel segments 连接在一起。<br><img src="/images/2/2.FPGA全局路由模型.png" alt><br>在本工作中我们使用最小生成树算法将多端线网划分为一组双端线网。故在此之后，文中提到的线网都指的是双端网。考虑一条双端曼哈顿距离为$d<em>h+d_v$的线网，其中$d_h$和$d_v$分别代表水平距离和垂直距离。该线网的路由区域被限制在大小为$(d_h+1)×(d_v+1)$的LB网格，如下图a所示<br><img src="/images/2/2.一条双端线网以及他子网和子网可能的路由区域.png" alt><br>然后该线网的最短距离可以被分解为三个独立的子网。该线网的每一个pin在最佳的路由区域只有一个邻居SB。所以，每一个pin都可以通过水平的或竖直的channel  segment与他的相邻的SB相连接，就如上图所示。同时，这两个pin连接的SB之间的连接的最佳路由区域就限制在$(d_h+1)×(d_v+1)$的大小的网格中。基于这个事实，我们进一步将每个线网细分为三个双端子网，及LS,SS,SL(如上图b所示)。这里，LS和SL子网代表着 LB-to-SB和SB-to-LB的连接，SS子网代表着特定网络的SB-to-SB连接。因此我们只LS和SL这两种子网考虑2条可能的路径，为SS子网考虑吧$d_h+d_v-2$条可能的包含1个或2个转弯的路径。<br>我们定义一个FPGA图(L,S,C),它是一个P×Q的二维网格，L,S,C分别代表着LB,SB,channel segments.这里P和Q代表着FPGA中水平和垂直的通道数量。每个顶点$s</em>{p,q}$代表着水平通道p和竖直通道q处的SB。网格中的每一个矩形单元$L<em>{p,q}$代表着四面相邻着$s</em>{p,q}$，$s<em>{p,q+1}$，$s</em>{p+1,q}$，$s<em>{p+1,q+1}$的LB。边被标记为$c^{h}</em>{pq}$($c^{v}<em>{pq}$),对应夹在$s</em>{p,q}$和$s<em>{p,q+1}$($s</em>{p+1,q}$)中间的channel segment。如下图所示：<br><img src="/images/2/2.FPGA_Graph.png" alt><br>全局路由问题为 寻找这些子网的路由的均匀分布 减少了搜索空间。路由的均匀分布有利于提高后续详细路由阶段寻找到可行路由的可能性。所以我们需要定义一个目标函数奖励balanced路由。因为我们前面讲到我们要避免区域性密度过高。将权重与边相关连以简化对给定路由结果的balance质量的计算。$w^{h}<em>{pq}$($w^{v}</em>{pq}$)代表$c^{h}<em>{pq}$($c^{v}</em>{pq}$)上的权重，意义是channel segment. 上的权重。通过这种模型，我们可以通过下面的公式来表示给定一条路由结果的balance质量：  </p>
<script type="math/tex; mode=display">B(R)=\sum_{p=1}^P\sum_{q=1}^{Q-1}(w^{h}_{pq}(R))^2+\sum_{q=1}^Q\sum_{p=1}^{P-1}(w^{v}_{pq}(R))^2</script><p>公式中，每个channel segment将其密度的平方贡献给目标函数，从而惩罚不平衡的路由分布。因此全局路由问题就是最小化上式。</p>
<h1 id="MFA-SOLUTION-FOR-GLOBAL-ROUTING-IN-FPGA"><a href="#MFA-SOLUTION-FOR-GLOBAL-ROUTING-IN-FPGA" class="headerlink" title="MFA SOLUTION FOR GLOBAL ROUTING IN FPGA"></a>MFA SOLUTION FOR GLOBAL ROUTING IN FPGA</h1><p>待续。。。。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/11/21/11-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94http%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/21/11-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94http%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/" itemprop="url">C++实战——Http业务逻辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-21T20:18:14+08:00">
                2021-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>书接上文，这里是http处理业务请求的具体逻辑内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    request_.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="comment">//没有数据可读直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_))  <span class="comment">//请求解析成功后 初始化相应</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//400代表解析不成功</span></span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//创造相应</span></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_);</span><br><span class="line">    <span class="comment">/* 响应头 */</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">    iovCnt_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件 */</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;</span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析http请求的逻辑"><a href="#解析http请求的逻辑" class="headerlink" title="解析http请求的逻辑"></a>解析http请求的逻辑</h2><p>下面简单分析，对http请求的解析的逻辑。</p>
<p><img src="/images/11/1677937698830.png" alt="1677937698830"></p>
<p>从http的请求报文的格式可看出，可以分为三个部分，<strong>请求首行</strong>、<strong>请求头部</strong>、<strong>请求数据</strong> 也叫<strong>请求体（body）</strong>，http解析也以此划分阶段。当解析数据还有剩余，会依据当前状态解析相应的部分。如：<code>ParseRequestLine_()</code>、<code>ParseHeader_()</code>、<code>ParseBody_</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> CRLF[] = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还有数据且状态不为解析完毕则不会跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_ != FINISH) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* lineEnd = <span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), CRLF, CRLF + <span class="number">2</span>);</span><br><span class="line">        <span class="function">std::string <span class="title">line</span><span class="params">(buff.Peek(), lineEnd)</span></span>;</span><br><span class="line">        <span class="keyword">switch</span>(state_)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_LINE:</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">ParseRequestLine_</span>(line)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ParsePath_</span>();</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> HEADERS:</span><br><span class="line">            <span class="built_in">ParseHeader_</span>(line);</span><br><span class="line">            <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                state_ = FINISH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BODY:</span><br><span class="line">            <span class="built_in">ParseBody_</span>(line);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lineEnd == buff.<span class="built_in">BeginWrite</span>()) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        buff.<span class="built_in">RetrieveUntil</span>(lineEnd + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(), version_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建响应的逻辑"><a href="#创建响应的逻辑" class="headerlink" title="创建响应的逻辑"></a>创建响应的逻辑</h3><p>同样，当请求的资源存在，可以响应时，也依次此创建响应。</p>
<p><img src="/images/11/1677939294522.png" alt="1677939294522"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 判断请求的资源文件 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> || <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;</span><br><span class="line">        code_ = <span class="number">404</span>; <span class="comment">//访问的是目录不是具体资源？？？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;</span><br><span class="line">        code_ = <span class="number">403</span>;   <span class="comment">//权限不够</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(code_ == <span class="number">-1</span>) &#123; </span><br><span class="line">        code_ = <span class="number">200</span>;   <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();         <span class="comment">//提醒错误的网页</span></span><br><span class="line">    <span class="built_in">AddStateLine_</span>(buff);  <span class="comment">//创建响应首行</span></span><br><span class="line">    <span class="built_in">AddHeader_</span>(buff);     <span class="comment">//创建响应头部</span></span><br><span class="line">    <span class="built_in">AddContent_</span>(buff);     <span class="comment">//创建内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/11/19/10-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/19/10-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url">C++实战——高并发服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-19T21:34:35+08:00">
                2021-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>服务器的工作实际上就是监听并且处理各种各样的事件。当服务器处于启动状态，就会不断用Epoll去监听，正在被监听的文件描述符事件。根据返回值和事件类型做出相应的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isClose_) &#123;</span><br><span class="line">	<span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   	timeMS = timer_-&gt;<span class="built_in">GetNextTick</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//一直使用 epoller_-&gt;Wait 去检测事件 返回值 有多少个</span></span><br><span class="line">   <span class="type">int</span> eventCnt = epoller_-&gt;<span class="built_in">Wait</span>(timeMS);</span><br><span class="line">   <span class="comment">//遍历这些事件</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCnt; i++) &#123;</span><br><span class="line">       <span class="comment">/* 处理事件 */</span></span><br><span class="line">       <span class="type">int</span> fd = epoller_-&gt;<span class="built_in">GetEventFd</span>(i);</span><br><span class="line">       <span class="type">uint32_t</span> events = epoller_-&gt;<span class="built_in">GetEvents</span>(i);</span><br><span class="line">       <span class="comment">//如果是监听描述符    说明有监听进来</span></span><br><span class="line">       <span class="keyword">if</span>(fd == listenFd_) &#123;</span><br><span class="line">           <span class="built_in">DealListen_</span>();   <span class="comment">//处理事件监听</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//出现了错误   关闭文件描述符</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">           <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">           <span class="built_in">CloseConn_</span>(&amp;users_[fd]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//非监听文件描述符有事件    处理读操作</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLIN) &#123;</span><br><span class="line">           <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">           <span class="built_in">DealRead_</span>(&amp;users_[fd]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//处理写操作</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLOUT) &#123;</span><br><span class="line">           <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">           <span class="built_in">DealWrite_</span>(&amp;users_[fd]);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//关闭连接</span></span><br><span class="line">       	<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Unexpected event&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面就挑选个人感觉比较重要的 两个时间的处理代码。</p>
<h3 id="处理监听事件"><a href="#处理监听事件" class="headerlink" title="处理监听事件"></a>处理监听事件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    users_[fd].<span class="built_in">init</span>(fd, addr);</span><br><span class="line">    <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timer_-&gt;<span class="built_in">add</span>(fd, timeoutMS_, std::<span class="built_in">bind</span>(&amp;WebServer::CloseConn_, <span class="keyword">this</span>, &amp;users_[fd]));</span><br><span class="line">    &#125;</span><br><span class="line">    epoller_-&gt;<span class="built_in">AddFd</span>(fd, EPOLLIN | connEvent_);</span><br><span class="line">    <span class="built_in">SetFdNonblock</span>(fd);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] in!&quot;</span>, users_[fd].<span class="built_in">GetFd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealListen_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="comment">//超过最大数量 做相应处理 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HttpConn::userCount &gt;= MAX_FD) &#123;</span><br><span class="line">            <span class="built_in">SendError_</span>(fd, <span class="string">&quot;Server busy!&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Clients is full!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AddClient_</span>(fd, addr);<span class="comment">//添加客户端</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(listenEvent_ &amp; EPOLLET); <span class="comment">//如果是ET模式  就必须一次性把事件读完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理读写"><a href="#处理读写" class="headerlink" title="处理读写"></a>处理读写</h3><p>处理读写事件主要工作相当于将读数据的任务发布给线程池。经过了很多封装，这里面要去源码去层层查看理解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnWrite_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> readErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">read</span>(&amp;readErrno); <span class="comment">//读取客户端数据</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> &amp;&amp; readErrno != EAGAIN) &#123;</span><br><span class="line">        <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    <span class="built_in">OnProcess</span>(client);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> writeErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">write</span>(&amp;writeErrno);</span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">ToWriteBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 传输完成 */</span></span><br><span class="line">        <span class="keyword">if</span>(client-&gt;<span class="built_in">IsKeepAlive</span>()) &#123;</span><br><span class="line">            <span class="comment">//业务逻辑处理</span></span><br><span class="line">            <span class="built_in">OnProcess</span>(client);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(writeErrno == EAGAIN) &#123;</span><br><span class="line">            <span class="comment">/* 继续传输 */</span></span><br><span class="line">            epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="业务处理逻辑"><a href="#业务处理逻辑" class="headerlink" title="业务处理逻辑"></a>业务处理逻辑</h3><p>主要解释上部分处理读写事件中的<code>OnProcess</code>的，这部分代码 线程池里的子线程处理 。注意这里并不是真正的处理逻辑，真正的处理逻辑是<code>client-&gt;process()</code>，他的返回值为真的话，说明处理完一个用户请求了，该做出相应了所以可以看到监听描述符的时间是<code>EPOLLOUT</code>。当监听到TCP缓冲区不满也就是可写，就会开始写的任务。否则就还是处理读（监听读使事件）。注意这里的读写是对于TCP缓冲区而言。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnProcess</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果client-&gt;process()为真 则说明处理完请求，要做出相应 所以事件是EPOLLOUT</span></span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">process</span>()) &#123;</span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（待更新。。。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/11/18/9-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Socket%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/18/9-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Socket%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/" itemprop="url">C++实战——Socket初始化流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-18T20:24:00+08:00">
                2021-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<p>Socket 初始化流程</p>
<ol>
<li>首先检查端口是否合法，不可使用公知端口，以及超出最大端口大小</li>
<li>创建监听文件描述符，当有连接到来时会产生事件，被Epoll监测到</li>
<li>文件描述符绑定ip地址</li>
<li>开始监听，并将监听文件描述符添加进Epoll的事件监听集合中（具体使用那种数据结构没有仔细探究）</li>
<li>设置监听文件描述符非阻塞。这一步很重要，不然如果一直没有连接到来服务器会被阻塞。</li>
</ol>
<p>以上这些步骤所需要的功能底层都用c语言实现（就是一些经典的库函数），但是都做了良好的封装</p>
<h2 id="初始化-Socket代码："><a href="#初始化-Socket代码：" class="headerlink" title="初始化 Socket代码："></a>初始化 Socket代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">* Create listenFd */</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::InitSocket_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="comment">//首先检查端口的合法性</span></span><br><span class="line">    <span class="keyword">if</span>(port_ &gt; <span class="number">65535</span> || port_ &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Port:%d error!&quot;</span>,  port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr.sin_family = AF_INET;                 <span class="comment">//IPv4 </span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//INADDR_ANY 意为可以绑定任意可用的IP地址</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(port_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linger</span> optLinger = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(openLinger_) &#123;</span><br><span class="line">        <span class="comment">/* 优雅关闭: 直到所剩数据发送完毕或超时 */</span></span><br><span class="line">        optLinger.l_onoff = <span class="number">1</span>;</span><br><span class="line">        optLinger.l_linger = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回监听成员描述符</span></span><br><span class="line">    listenFd_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenFd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Create socket error!&quot;</span>, port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger, <span class="built_in">sizeof</span>(optLinger));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Init linger error!&quot;</span>, port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 端口复用 */</span></span><br><span class="line">    <span class="comment">/* 只有最后一个套接字会正常接收数据。 */</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span>*)&amp;optval, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;set socket setsockopt error !&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Bind Port:%d error!&quot;</span>, port_);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenFd_, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Listen port:%d error!&quot;</span>, port_);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将监听文件描述符 与 事件 添加进Epoll</span></span><br><span class="line">    ret = epoller_-&gt;<span class="built_in">AddFd</span>(listenFd_,  listenEvent_ | EPOLLIN);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Add listen error!&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置监听文件描述符非阻塞</span></span><br><span class="line">    <span class="built_in">SetFdNonblock</span>(listenFd_);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Server port:%d&quot;</span>, port_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/07/12/21-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B%E9%A9%B1%E5%8A%A8%E5%88%B0platform%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8D%8E%E4%B8%BD%E8%BD%AC%E8%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/12/21-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B%E9%A9%B1%E5%8A%A8%E5%88%B0platform%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8D%8E%E4%B8%BD%E8%BD%AC%E8%BA%AB/" itemprop="url">Linux内核——字符型驱动到platform驱动的华丽转身</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-12T19:41:57+08:00">
                2021-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<h2 id="platform驱动"><a href="#platform驱动" class="headerlink" title="platform驱动"></a>platform驱动</h2><p>platform驱动是一种模拟的总线驱动。将字符型驱动包装成platform驱动有两大好处。</p>
<ul>
<li>把设备都挂接在一个pseudo总线上，便于管理，同时也符合Linux的设备模型机制。其结果是，配套的sysfs节点、设备电源管理都成为可能;</li>
<li>隔离设备和驱动。在BSP中定义platform设备和它使用的资源、设备的具体配置信息;而在驱动中，只需要通过通用的API去获取资源和数据，做到了BSP相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</li>
</ul>
<p>不在总线上的驱动都可一包装成platform驱动</p>
<p>什么是BSP<a target="_blank" rel="noopener" href="https://blog.csdn.net/shangtang1/article/details/79248947">(14条消息) 嵌入式中的BSP—-BSP到底是什么？_芯片bsp_shangtang的博客-CSDN博客</a></p>
<p>内核里分别用device和driver来表示设备和驱动，面向对象的思想，device是所有设备的基类，driver是所有驱动的基类。将我们瞎写的字符型驱动改造成platform驱动比较规范话，</p>
<h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><ol>
<li><p>首先需要添加头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>hello_init函数 要改成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_probe</span><span class="params">(<span class="keyword">struct</span> platform _device *pdev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载函数改成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hellodev_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义设备资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBASE 0x56000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENDLEN 0x0c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">hello_dev_resource</span>[] =</span> &#123;</span><br><span class="line">	[<span class="number">0</span>] = &#123;</span><br><span class="line">		.start = LEDBASE,</span><br><span class="line">		.end   = LEDBASE + LEDLEN - <span class="number">1</span>,</span><br><span class="line">		.flags = IORESOURCE_MEM,                        <span class="comment">//内存资源</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">hello_device</span> =</span> &#123;</span><br><span class="line">	.name		  = <span class="string">&quot;hello-device&quot;</span>,     <span class="comment">//设备名</span></span><br><span class="line">	.id		  = <span class="number">-1</span>,</span><br><span class="line">	.num_resources	  = ARRAY_SIZE(hello_dev_resource),  <span class="comment">//指定资源  可以是io资源 内存资源 还有ARQ资源？</span></span><br><span class="line">	.resource	  = hello_dev_resource,</span><br><span class="line">	.dev = &#123;</span><br><span class="line">		.release = hello_plat_release,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义驱动</p>
<p>在这里指定驱动模块插入和删除的操作是哪个。并且给驱动起个名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">hellodev_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= hellodev_probe,</span><br><span class="line">	.remove		= hellodev_remove,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">		.name	= <span class="string">&quot;hello-device&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>最后定义内核才插入和删除该设备时 的操作。 注册设备  注册驱动  删除设备  删除驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">charDrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_device_register(&amp;hello_device);</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;hellodev_driver); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">charDrvExit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_device_unregister(&amp;hello_device);</span><br><span class="line">    platform_driver_unregister(&amp;hellodev_driver);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(charDrvInit);</span><br><span class="line">module_exit(charDrvExit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<p><img src="/images/21/1678101131204.png" alt="1678101131204"></p>
</li>
</ol>
<h2 id="Platform驱动设备-匹配注册机制"><a href="#Platform驱动设备-匹配注册机制" class="headerlink" title="Platform驱动设备 匹配注册机制"></a>Platform驱动设备 匹配注册机制</h2><ol>
<li><p>几个重要的结构体一看就能懂。</p>
<p><img src="/images/21/1678101331998.png" alt="1678101331998"></p>
<p>device是linux内核所有设备的基类  resouce就是资源。</p>
<p><img src="/images/21/1678101429981.png" alt="1678101429981"></p>
<p>驱动就是行为，所以大部分都是函数。插入删除关闭休眠唤醒。device_driver 就是所有驱动的基类。</p>
<p>*id_table</p>
<p><img src="/images/21/1678102019401.png" alt="1678102019401"></p>
<p>一般匹配就是通过bus去匹配</p>
</li>
<li><p>注册函数 的实现</p>
<p>设备初始化包括资源初始化，如果设备父设备为空那么会指定一个叫platform的虚拟设备，用来表示总线设备是虚拟的，类型是platformbus，然后使用device_add函数将设备加入内核。</p>
<p>驱动的注册就是把那几个函数地址赋值。bus用于匹配，都是platform类型的就</p>
<p>平台设备是一条链，平台驱动是一条链表，他们都挂在platform bus这个东西上上。那么驱动和设备的匹配就是遍历链表一个一个匹配。只有某一个设备和某一个驱动匹配上了，才会成功地插入驱动。</p>
</li>
</ol>
<p><strong>其实这块可以细究</strong>一下的，但是最近没什么时间了。。。。。发现学内核很需要心境</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/06/12/20-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E8%87%AA%E6%97%8B%E9%94%81-spinlock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/12/20-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E8%87%AA%E6%97%8B%E9%94%81-spinlock/" itemprop="url">Linux内核——自旋锁 spinlock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-12T16:55:19+08:00">
                2021-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<p>与之前学的信号量相比，自旋锁是一种死等的机制。而信号量不会。只有一个执行单元获取锁并进入到临界区，其他的都给我死等。可以在中断上下文执行，因为是不睡眠的。中断上下文代码不允许睡眠，也不允许调用那些可能会引起睡眠的函数。这种死等的实现是不同的架构有不一样的方法。</p>
<h2 id="自旋锁的实现"><a href="#自旋锁的实现" class="headerlink" title="自旋锁的实现"></a>自旋锁的实现</h2><ol>
<li><p>查看结构体定义struct spinlock (/include/linux/spinlock_types.h)<img src="/images/20/1678091181583.png" alt="1678091181583"></p>
<p>然后再去看看，raw_spinlock</p>
<p><img src="/images/20/1678091233794.png" alt="1678091233794"></p>
<p>然后再去看看arch_spinlock_t!!!!然后发现这东西的定义适合cpu架构相关的，多层封装是为了增加灵活性。。以arm为例：</p>
<p>路径（/arch/arm/include/asm/spinlock_types.h）</p>
<p><img src="/images/20/1678091414902.png" alt="1678091414902"></p>
<p>其中owner表示持有这个数字的thread可以获取自旋锁，next表示如果后续有thread请求获取这个自旋锁，给他分配这个数字。</p>
</li>
<li><p>自旋锁的初始化  按照上述所说就是把那两个东西置为0，对spinlock的初始化一层层再找到arm里的初始化实现，就长这样<img src="/images/20/1678091817407.png" alt="1678091817407"></p>
</li>
<li><p>基本所有实现都是spin—&gt;raw_spin-&gt;arch_spin. 由不同的架构去实现，实现的逻辑就是。</p>
<ul>
<li>刚开始owner=next=0;</li>
<li>第一个thread获取spinlock，可获取成功，此时owner==0,next=0;</li>
<li>第二个thread获取spinlock,如果第一个thread还没有释放spinlock，则next++, next变为1;</li>
<li>第三个thread获取spinlock,如果第一个thread还没有释放spinlock，则next++, next变为2;<br>此时第一个thread释放spinlock，则执行ownerowner=1;</li>
<li>虽然此时第二个thread和第三个thread都在等待spinlock,但是因为第二个thread的next=owner,所以第二个thread可以获取到spinlock，第三个thread则继续等待。这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒，保证了公平性。</li>
</ul>
</li>
<li><p>另外，还有一种自旋锁叫做读写自旋锁。读写自旋锁可以让多个读一起读，但是经常让写死等。</p>
</li>
</ol>
<h2 id="自旋锁的使用"><a href="#自旋锁的使用" class="headerlink" title="自旋锁的使用"></a>自旋锁的使用</h2><p>继续修改我们的hello驱动。</p>
<ol>
<li><p>首先定义自旋锁与临界资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> count_lock;</span><br><span class="line"><span class="type">int</span> open_count=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在hello_init中进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自旋锁初始化</span></span><br><span class="line">spin_lock_init(&amp;count_lock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>open与close操作中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;count_lock);</span><br><span class="line">    <span class="keyword">if</span>(!open_count&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        spin_enlock(&amp;count_lock);</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    open_count++;</span><br><span class="line">    spin_lock(&amp;count_lock);</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!open_count!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    spin_enlock(&amp;count_lock);</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之前也说过了自旋锁的特性，尽量要让临界区执行的快一点。不然cpu会经常死等。</p>
<p>结果和信号量结果相同。因为从应用程序来看确实本质区别也不大。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/06/12/19-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/12/19-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" itemprop="url">Linux内核——原子操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-12T15:52:23+08:00">
                2021-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>对原子变量的访问是源自的，linux内核自带的源子变量结构体定义如下（/include/linux/types.h）：</p>
<p><img src="/images/19/1678087835689.png" alt="1678087835689"></p>
<p>竟然就是一个整型么!</p>
<p>对于原子变量的初始化<code>ATOMIC_INIT</code>不同体系架构都不一样。</p>
<h2 id="原子变量的应用"><a href="#原子变量的应用" class="headerlink" title="原子变量的应用"></a>原子变量的应用</h2><p>同样，继续修改helloDev.c。</p>
<ol>
<li><p>定义原子变量并初始化为1，之前的信号量和opencount不要了，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct semaphore sema;</span></span><br><span class="line"> <span class="comment">// int open_count=0;</span></span><br><span class="line"> <span class="type">static</span> <span class="type">atomic_t</span> can_open = ATOMIC_INIT(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>open操作改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!atomic_dec_and_test(&amp;can_open))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        automic_inc(&amp;can_open);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>atomic_dec_and_test</code> 和 <code>automic_inc</code> 这两个里面的操作不同的体系架构有着不一样的实现。以arm架构为例：全是汇编。。。。。 </p>
<p><img src="/images/19/1678088566696.png" alt="1678088566696"></p>
<p>用宏定义去实现，嵌入汇编指令的操作。之前写过mips的汇编。现在忘的有点多。</p>
<p>反正就是汇编语言实现了对原子变量的加减操作。如果是单核的话可以使用开关中断来保证原子操作</p>
</li>
<li><p>close操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    automic_inc(&amp;can_open);</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>本篇的收获仅仅是原子变量的使用吧，初始化，然后加减操作。。至于怎么实现，也就大概那么回事。。。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2021/06/06/18-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/06/18-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F/" itemprop="url">Linux内核——信号量semaphore</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-06T15:15:49+08:00">
                2021-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<h2 id="多进程访问驱动设备带来的问题"><a href="#多进程访问驱动设备带来的问题" class="headerlink" title="多进程访问驱动设备带来的问题"></a>多进程访问驱动设备带来的问题</h2><p>在驱动程序中，有些设备只允许打开一次。那么可以在驱动中定义一个全局变量，判断当前使用数目。比如在某驱动程序的<strong>open函数</strong>中这样定义。当count==0说明没有使用，可以打开。理想状态下是左边的情况，但是cpu对进程的调度是随机的，所以不可避免的发生右边的情况。就会打开多次。</p>
<!-- ![1678081076781](/images/18/1678081076781.png) | ![1678081150110](/images/18/1678081150110.png)

 -->
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="/images/18/1678081076781.png" alt="1678081076781"></th>
<th><img src="/images/18/1678081150110.png" alt="1678081150110"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>为什么没有count—的操作？因为这是驱动的open函数。—肯定是在close函数里边。</p>
<p>老生常谈，并发执行的单元（这里不说进程是因为还有线程，但是他们的问题是一样的）对共享资源（例子里面是count）的访问会引发竞争。访问共享资源的代码区叫做<code>临界区</code>，临界区需要某种内核同步方法来保护。</p>
<h2 id="内核同步机制——信号量源码"><a href="#内核同步机制——信号量源码" class="headerlink" title="内核同步机制——信号量源码"></a>内核同步机制——信号量源码</h2><ol>
<li><p>struct semaphore 结构体定义</p>
<p>内核中信号量通过这样一的结构体<code>struct semaphore</code>来定义，定位到内核源码<code>/include/linux/semaphone.h</code>文件。可以查看到<code>struct semaphore</code>的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Please don&#x27;t access any members of this structure directly */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;      <span class="comment">//说明是以另一种同步机制自旋锁来实现的</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		count;     <span class="comment">//用以表示资源数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span>  <span class="comment">//双向链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/18/1678084503728.png" alt="1678084503728"></p>
</li>
<li><p>初始化函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)				\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\</span></span><br><span class="line"><span class="meta">	.count		= n,						\</span></span><br><span class="line"><span class="meta">	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SEMAPHORE(name)	\</span></span><br><span class="line"><span class="meta">	struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">	*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/18/1678084786042.png" alt="1678084786042"></p>
</li>
<li><p>down操作，就是使用这个信号量资源。定义在内核源码根目录下的/kernel/locking/semaphore.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * down - acquire the semaphore</span></span><br><span class="line"><span class="comment"> * @sem: the semaphore to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Acquires the semaphore.  If no more tasks are allowed to acquire the</span></span><br><span class="line"><span class="comment"> * semaphore, calling this function will put the task to sleep until the</span></span><br><span class="line"><span class="comment"> * semaphore is released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use of this function is deprecated, please use down_interruptible() or</span></span><br><span class="line"><span class="comment"> * down_killable() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">		sem-&gt;count--;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__down(sem);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(down);</span><br></pre></td></tr></table></figure>
<p><img src="/images/18/1678085608439.png" alt="1678085608439"></p>
<p>相当于又用自旋锁，保护了自身的count这个资源是互斥访问的。但是这里代码简单说明具体的实现不在这里</p>
<p>那么一步步ctrl+左键，找到了</p>
</li>
</ol>
<p>   <img src="/images/18/1678085781987.png" alt="1678085781987"></p>
<p>   系统中每个进程都会有一个task结构体，就像有一个pid一样与之相对应。当有进程使用了down之后，该进程的task就会被加入到信号量的wait_list里面。然后就会将自己设为睡眠状态，让cpu去执行其他进程。自旋锁是非常耗费cpu资源的，所以他保护的临界区资源不能睡眠。所以可以看到timeuot那句没有被保护。与cpu调度相关的，后面说。</p>
<p>   当自己醒了之后再次查看自己申请的资源是不是可以访问了，不行就继续睡，行了就返回，跳出down。</p>
<ol>
<li><p>up操作，对临界资源访问结束，释放信号量和down长得差不多，直接找核心的。<img src="/images/18/1678086270368.png" alt="1678086270368"></p>
<p>很好理解  如果信号量资源够了，那么就唤醒进程。</p>
</li>
</ol>
<h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>​    在之前的hellodev驱动中，我们做这样的修改。</p>
<ol>
<li><p>首先定义全局变量，信号量和一个整型用于计数。整型这里就是共享资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema</span>；</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">open_count</span>=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>驱动的初始代码中对信号量进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量的初始化  初始化为1 表明共享资源只有一个</span></span><br><span class="line">sema_init(&amp;sema,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>是临界区代码，开始时down获取信号量，结束时up释放信号量。第一个进程获取到所之后，第二个进程再次访问就会被阻塞，因为他发现这个信号量的值不再是1，而是0；能保证临界代码的访问是原子的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;sema);</span><br><span class="line">    <span class="keyword">if</span>(open_count&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        up(&amp;sema);</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    open_count++;</span><br><span class="line">    up(&amp;sema);</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式可以保证，这部分区域的访问是原子的。如果说临界区的资源不是很复杂，那么建议还是使用原子变量，而不是使用信号量。下次说</p>
</li>
<li><p>相应的，在推出对驱动的访问时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(open_count!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO<span class="string">&quot;something wrong,hello_close fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    open_count--;</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们是没定义这个函数的，所以要在init的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gFile-&gt;release = hello_close;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol>
<li><p>测试程序中加入sleep() 使其打开驱动程序的时间长一点。</p>
</li>
<li><p>首先打开执行第一个进程<img src="/images/18/1678084102081.png" alt="1678084102081"></p>
<p>可以看到写入成功并没有直接推出，与此同时我们新建一个终端在运行一次，<img src="/images/18/1678084174458.png" alt="1678084174458"></p>
<p>Nice！！！！！！！</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>信号量用于线程和进程之间的同步</li>
<li>允许多个进程进入临界区代码执行</li>
<li>进程获取不到信号量锁会陷入休眠，具体的进程相关姐都体task（代表当前。）会加入到信号量结构体维护的一个链表，并且进入休眠（cpu调度）。</li>
<li>被信号量保护的临界区允许睡眠，但是信号量的实现中 自旋锁维护的临界区是不允许休眠的。</li>
<li>基于进程调度器实现，UP和SMP无差异</li>
<li><strong>不支持进程和中断之间的同步</strong>  需要用到自旋锁。</li>
</ol>
<h2 id="helloDev驱动已经更新了多次，再次附目前为止的完整代码"><a href="#helloDev驱动已经更新了多次，再次附目前为止的完整代码" class="headerlink" title="helloDev驱动已经更新了多次，再次附目前为止的完整代码"></a>helloDev驱动已经更新了多次，再次附目前为止的完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//helloDev.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_MAX    (64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK            (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR         (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">gDev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">gFile</span>;</span></span><br><span class="line"><span class="type">dev_t</span>  devNum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> subDevNum = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> reg_major  =  <span class="number">232</span>;    </span><br><span class="line"><span class="type">int</span> reg_minor =   <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buffer[BUFFER_MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema</span>;</span></span><br><span class="line"><span class="type">int</span> open_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;sema);</span><br><span class="line">    <span class="keyword">if</span>(open_count&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        up(&amp;sema);</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    open_count++;</span><br><span class="line">    up(&amp;sema);</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(open_count!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO<span class="string">&quot;something wrong,hello_close fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    open_count--;</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">const</span> <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_write\r\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> writenlen = <span class="number">0</span>;</span><br><span class="line">    writenlen = BUFFER_MAX&gt;s?s:BUFFER_MAX;</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(buffer,u,writenlen))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writenlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_read\r\n&quot;</span>);    </span><br><span class="line">    <span class="type">int</span> readlen;</span><br><span class="line">    readlen = BUFFER_MAX&gt;s?s:BUFFER_MAX;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(u,buffer,readlen))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据主次设备号生成一个devnum 主次设备号可以唯一标识</span></span><br><span class="line">    devNum = MKDEV(reg_major, reg_minor);</span><br><span class="line">    <span class="comment">//将设备号注册到内核 </span></span><br><span class="line">    <span class="keyword">if</span>(OK == register_chrdev_region(devNum, subDevNum, <span class="string">&quot;helloworld&quot;</span>))&#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;register_chrdev_region ok \n&quot;</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;register_chrdev_region error n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot; hello driver init \n&quot;</span>);</span><br><span class="line">    <span class="comment">// struct cdev 是内核中的字符设备</span></span><br><span class="line">    gDev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">    <span class="comment">//初始化一个file结构体 代表设备</span></span><br><span class="line">    gFile = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> file_operations), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给file结构体中的函数操作赋值   右侧是函数指针 指明操作</span></span><br><span class="line">    gFile-&gt;open = hello_open;</span><br><span class="line">    gFile-&gt;read = hello_read;</span><br><span class="line">    gFile-&gt;write = hello_write;</span><br><span class="line"></span><br><span class="line">    gFile-&gt;owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    gFile-&gt;release = hello_close;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核中找到设备号 就能找到cdev 与 file_operations</span></span><br><span class="line">    <span class="comment">//建立gDev 与 gFile之间的联系 里边没看但是肯定有两个之间的互动就是了</span></span><br><span class="line">    cdev_init(gDev, gFile);</span><br><span class="line">    <span class="comment">//又建立了gDev 与 设备号的联系</span></span><br><span class="line">    cdev_add(gDev, devNum, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号量的初始化  初始化为1 表明共享资源只有一个</span></span><br><span class="line">    sema_init(&amp;sema,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动的卸载</span></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(gDev);</span><br><span class="line">    unregister_chrdev_region(devNum, subDevNum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Makefile</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">	obj-m := helloDev.o                        </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">	<span class="comment"># KDIR:= /lib/modules/4.4.0-31-generic/build</span></span><br><span class="line">	<span class="comment"># KDIR:=/home/dawnlake/Downloads/linux-4.9.229</span></span><br><span class="line">KDIR := /lib/modules/`uname -r`/build</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span></span><br><span class="line">	gcc -g read_test.c -o read_test</span><br><span class="line">	gcc -g write_test.c -o write_test</span><br><span class="line">	rmmod helloDev</span><br><span class="line">	insmod helloDev.ko</span><br><span class="line"><span class="section">clean:	</span></span><br><span class="line">	rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_NUM    (32)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    <span class="type">int</span>  w_len;</span><br><span class="line">    fd_set fdset;</span><br><span class="line">    <span class="type">char</span> buf[DATA_NUM]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// memset(buf,0,DATA_NUM);</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd) &#123;</span><br><span class="line">      	perror(<span class="string">&quot;open file error\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open successe\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    w_len = write(fd,buf, DATA_NUM);</span><br><span class="line">    <span class="comment">// r_len = read(fd, buf, DATA_NUM);</span></span><br><span class="line">    <span class="keyword">if</span>(w_len==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;w_len = %d \r\n&quot;</span>, w_len);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_NUM    (64)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    <span class="type">int</span> r_len;</span><br><span class="line">    fd_set fdset;</span><br><span class="line">    <span class="type">char</span> rbuf[DATA_NUM];</span><br><span class="line">    <span class="built_in">memset</span>(rbuf,<span class="number">0</span>,DATA_NUM);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd) &#123;</span><br><span class="line">      	perror(<span class="string">&quot;open file error\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open successe\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// w_len = write(fd,buf, DATA_NUM);</span></span><br><span class="line">    r_len = read(fd, rbuf, DATA_NUM);</span><br><span class="line">    <span class="keyword">if</span>(r_len==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;readlen = %d \r\n&quot;</span>,  r_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,rbuf);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my_avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawnlake</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
