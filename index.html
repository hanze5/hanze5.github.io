<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="也许不会有人进来吧">
<meta property="og:url" content="http://hanze5.github.io/index.html">
<meta property="og:site_name" content="也许不会有人进来吧">
<meta property="og:locale">
<meta property="article:author" content="Dawnlake">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hanze5.github.io/"/>





  <title>也许不会有人进来吧</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">也许不会有人进来吧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/04/05/34-%E4%BA%86%E8%A7%A3NVMe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/05/34-%E4%BA%86%E8%A7%A3NVMe/" itemprop="url">了解NVMe</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-05T16:33:12+08:00">
                2023-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id><a href="#" class="headerlink" title=" "></a> </h1><p>感觉不了解一下NVMe，Femu的代码阅读起来还想确实有点困难。使用FEMU模拟NVMe设备，是需要了解这个协议的。完全参考蛋蛋读NVMe,讲的十分清晰。</p>
<h2 id="1-host-如何使用-NVMe协议与SSD通信"><a href="#1-host-如何使用-NVMe协议与SSD通信" class="headerlink" title="1.host 如何使用 NVMe协议与SSD通信"></a>1.host 如何使用 NVMe协议与SSD通信</h2><p>来源：<a target="_blank" rel="noopener" href="https://www.ssdfans.com/?p=8137">蛋蛋读NVMe之一 (ssdfans.com)</a></p>
<p>PCIe（Peripheral Component Interconnect Express）是一种高速串行总线标准，用于连接计算机内部的各种硬件设备。下图为PCIe系统的简单架构图，图中的NVMe Subsystem一般就是SSD。SSD作为一个PCIe Endpoint通过PCIe连着Root Complex （RC）, 然后RC连接着CPU和内存。Root Complex是PCIe系统中引入的概念，它将CPU、内存子系统和PCIe子系连接起来。Root Complex是PCIe总线的根节点，将PCIe设备与CPU/Memory连接到一起，与其余PCIe设备（包括Switch）连接的端口称为RootPort。</p>
<p><em>”我们可以认为RC就是CPU的代言人，助理，或者小蜜。作为系统中最高层，CPU说：我很忙的，你SSD有什么事情先跟我小蜜说！尽管如此，SSD的地位还是较过去提升了一级，过去SSD别说直接接触霸道总裁，就是连小蜜的面都见不到，SSD和小蜜之间还隔着一座南桥呢。滚蛋吧，南桥君！“——蛋蛋</em></p>
<p><img src="/images/34/1680570283993.png" alt="1680570283993"></p>
<p>NVMe有两种命令，一种叫<strong><code>Admin Command</code></strong>，用以Host管理和控制SSD；另外一种就是<strong><code>I/O Command</code></strong>，用以Host和SSD之间数据的传输。</p>
<p>有了这两种命令还需要，通信的重要三个组件：<strong><code>Submission Queue （SQ）</code></strong>，<strong><code>Completion Queue（CQ）</code></strong>和<strong><code>Doorbell Register</code></strong> （DB）。 SQ和CQ位于Host的内存中，DB则位于SSD的控制器内部。</p>
<p>当Host要发送命令时，先把准备好的命令放在SQ中，然后通知SSD来取；通知的方式就是，通过SSD端的DB寄存器，通知SSD可以来取命令；CQ也是位于Host内存中，一个命令执行完成，成功或失败，SSD总会往CQ中写入命令完成状态。</p>
<p>总结步骤:</p>
<p><img src="file:///C:\Users\DawnLake\AppData\Roaming\Tencent\Users\1479320516\QQ\WinTemp\RichOle\J~KT0{A$`5WIEF_OJTOG[GS.png" alt="img"></p>
<ol>
<li>Host写命令到内存中的SQ；</li>
<li>Host写SSD控制器的DB，通知SSD取指；</li>
<li>SSD控制器收到通知，于是从内存中的SQ取指；</li>
<li>SSD控制器执行指令；</li>
<li>指令执行完成，SSD控制器往内存中的CQ写指令执行结果；</li>
<li>然后SSD控制器产生MSI中断通知Host指令完成；</li>
<li>Host收到MSI中断，处理CQ，查看指令完成状态；</li>
<li>Host处理完CQ中的指令执行结果，通过DB回复SSD：指令执行结果已处理！</li>
</ol>
<h2 id="2-SQ-CQ和DB-详解"><a href="#2-SQ-CQ和DB-详解" class="headerlink" title="2. SQ,CQ和DB 详解"></a>2. SQ,CQ和DB 详解</h2><p>来源：<a target="_blank" rel="noopener" href="https://www.ssdfans.com/?p=8139">蛋蛋读NVMe之二 (ssdfans.com)</a></p>
<p><img src="file:///C:\Users\DawnLake\AppData\Roaming\Tencent\Users\1479320516\QQ\WinTemp\RichOle\X34FLE~Y6%XKUJ@9@~6KG`C.png" alt="img"></p>
<p>SQ与CQ并不一定是一对一的关系。而之前说的NVMe有两种命令，从而也有两种SQ与CQ。一种是Admin，另外一种是I/O，前者放Admin命令，用以Host管理控制SSD，后者放置I/O命令，用以Host与SSD之间传输数据，不可以混着放。系统中只有一对Admin SQ/CQ，I/O SQ/CQ却可以很多，多达65535（64K减去一个SQ/CQ）。Host端每个Core可以有一个或者多个SQ，但只有一个CQ。设置多个core可以利用多线程满足性能需求，一个线程独享一个SQ，且可以为SQ设置不同的优先级，重要的SQ指令优先被执行。</p>
<p>实际系统中用多少个SQ，取决于系统配置和性能需求，可灵活设置I/O SQ个数。</p>
<p>作为队列，每个SQ和CQ都有一定的深度：对Admin SQ/CQ来说，其深度可以是2-4096（4K）；对I/O SQ/CQ，深度可以是2-65536(64K)。队列深度也是可以配置的。 这也是NVMe相较与其他协议更屌的地方。AHCI只有一个命令队列，且队列深度是固定的32。  </p>
<p>还有重要的一点：每个SQ放入的是命令条目，无论是Admin还是I/O命令，每个命令条目大小都是64字节；每个CQ放入的是命令完成状态信息条目，每个条目大小是16字节。</p>
<p>再进行一波小总结：</p>
<ol>
<li><p><strong>SQ用以Host发命令，CQ用以SSD回命令完成状态</strong></p>
</li>
<li><p><strong>SQ/CQ可以在Host的内存中，也可以在SSD中，但一般在Host 内存中（所有系列文章都是基于SQ/CQ在Host内存中讲的）;</strong></p>
</li>
<li><p><strong>两种类型的SQ/CQ：Admin和I/O，前者发送Admin命令，后者发送I/O命令;</strong></p>
</li>
<li><p><strong>系统中只能有一对Admin SQ/CQ，但可以有很多对I/O SQ/CQ;</strong></p>
</li>
<li><p><strong>I/O SQ与CQ可以是一对一的关系，也可以是一对多的关系；</strong></p>
</li>
<li><p><strong>I/O SQ是可以赋予不同优先级的；</strong></p>
</li>
<li><p><strong>I/O SQ/CQ深度可达64K，Admin SQ/CQ深达4K；</strong></p>
</li>
<li><p><strong>I/O SQ/CQ的广度和深度都可以灵活配置；</strong></p>
</li>
<li><p><strong>每条命令大小是64字节，每条命令完成状态是16字节；</strong></p>
</li>
</ol>
<p>SQ与CQ都是是环形队列，DB而就是用来记录一个SQ或者CQ的Head和Tail。<strong>每个SQ或者CQ，都有两个对应的DB: Head DB和Tail DB</strong>。DB是在SSD端的寄存器，记录SQ和CQ的头和尾的位置。这样SQ头尾之间的就是待处理的命令，SSD通过该SQ的两个DB获取这个信息。Host存放命令到SQ后就会更新SSD端的DB寄存器。 SSD controller 把这三个指令取到之后，会更新DB。</p>
<p>同样的，当 SSD执行完命令，会将消息放入CQ，并更新CQ尾的DB寄存器，然后通过MSI中断通知host已经执行完host的命令了。host取出CQ中的完成信息进行处理，并更新CQ的头。<strong>生产者修改尾，消费者修改头。</strong></p>
<p>细细琢磨可能发现一些小漏洞，Host只能写DB，而不能读DB，且只能写SQ尾和写CQ头。那它如何知晓SQ头与CQ尾。Host发了取指通知后，它并不清楚SSD什么时候去取命令，取了多少命令。答：<strong>SSD往CQ中写入命令状态信息，就包含了这几条</strong>。</p>
<p>小总结：</p>
<ol>
<li><strong>DB在SSD Controller端，是寄存器</strong></li>
<li><strong>DB记录着SQ和CQ的Head和Tail</strong></li>
<li><strong>每个SQ或者CQ有两个DB: Head DB 和Tail DB</strong></li>
<li><strong>Host只能写DB，不能读DB</strong></li>
<li><strong>Host通过SSD往CQ中写入的命令完成状态获取Head或者Tail</strong></li>
</ol>
<h2 id="3-数据怎么传递的"><a href="#3-数据怎么传递的" class="headerlink" title="3.数据怎么传递的"></a>3.数据怎么传递的</h2><p>来源：<a target="_blank" rel="noopener" href="https://www.ssdfans.com/?p=8141">蛋蛋读NVMe之三 (ssdfans.com)</a></p>
<p>数据传递无非两种方向，host内存 &lt;==&gt; SSD。</p>
<p><img src="file:///C:\Users\DawnLake\AppData\Roaming\Tencent\Users\1479320516\QQ\WinTemp\RichOle\5Q{UQ_Z]TV0ZG(G{NWCFJ" alt="img">F.png)</p>
<p>Host如果想往SSD上写入用户数据，需要告诉SSD<strong>写入什么数据，写入多少数据</strong>，以及<strong>数据源在内存中的什么位置</strong>，这些信息包含在Host向SSD发送的<strong>Write命令</strong>中。每笔用户数据对应着一个叫做LBA（Logical Block Address）的东西，<strong>Write命令通过指定LBA来告诉SSD写入的是什么数据</strong>。对NVMe/PCIe来说，SSD收到Write命令后，通过PCIe去Host的内存数据所在位置读取数据，然后把这些数据写入到闪存中，<strong>同时得到LBA与闪存位置的映射关系</strong>。</p>
<p>Host如果想读取SSD上的用户数据，同样需要<strong>告诉SSD需要什么数据，需要多少数据</strong>，以及<strong>数据最后需要放到Host内存的哪个位置上去</strong>，这些信息包含在Host向SSD发送的<strong>Read命令</strong>中。SSD<strong>根据LBA，查找映射表</strong>，找到对应闪存物理位置，然后读取闪存获得数据。数据从闪存读上来以后，对NVMe/PCIe来说，SSD会通过PCIe把数据写入到Host指定的内存中。这样就完成了Host对SSD的读访问。<em>（SSD的映射表是用来记录逻辑块地址（LBA）和物理块地址（PBA）之间的对应关系的，它是SSD固件的核心部分。SSD工作时，它的绝大部分映射表是存储在FLASH里面，还有一部分存储在片上RAM上。这样做的目的是为了提高性能和减少对FLASH的磨损。当SSD断电时，会把映射表写回到FLASH中，以防止数据丢失。）</em></p>
<p><em>再说明一下 Root Complex是PCIe总线系统中的一个概念，它将CPU、内存子系统和PCIe子系连接起来。它负责将CPU的访问事务转换为PCIe总线上的访问事务，同时也要解析下游PCIe设备上报的报文，并根据报文内容，将信息或者数据通知CPU。内存和SSD的数据交换需要通过Root Complex作为桥梁，因为Root Complex可以将存储域地址空间转换为PCIe域地址空间。</em></p>
<p>无论是写入还是读取，Host都是发送命令的一方，并不负责数据的主动传输。其中Host关注的是逻辑地址，SSD需要通过逻辑地址找到真正的数据存放位置。Host也有两种方式来告诉SSD数据所在内存位置，一是PRP (Physical Region Page )，二是SGL (Scatter/Gather )。</p>
<h3 id="3-1-PRP-Physical-Region-Page"><a href="#3-1-PRP-Physical-Region-Page" class="headerlink" title="3.1 PRP (Physical Region Page)"></a>3.1 PRP (Physical Region Page)</h3><p>NVMe把Host的内存划分为一个一个页（Page），页的大小可以是4KB,8KB,16KB… 128MB。好像一般都是4KB。</p>
<p><img src="/images/34/1680608024474.png" alt="1680608024474"></p>
<p>PRP Entry本质就是一个64位内存物理地址，只不过把这个物理地址分成两部分：页起始地址和页内偏移。最后两bit是0，说明PRP表示的物理地址只能四字节对齐访问。页内偏移可以是0，也可以是个非零的值。</p>
<p><img src="/images/34/1680608127938.png" alt="1680608127938"></p>
<p>PRP Entry描述的是一段连续的物理内存的起始地址。如果需要描述若干个不连续的物理内存呢？那就需要若干个PRP Entry。把若干个PRP Entry链接起来，就成了PRP List。</p>
<p><img src="/images/34/1680608903047.png" alt="1680608903047"></p>
<p>PRP List中的每个PRP Entry的偏移量都必须是0，PRP List中的每个PRP Entry都是描述一个物理页。它们不允许有相同的物理页，不然SSD往同一个物理页写入几次的数据，导致先写入的数据被覆盖。</p>
<p>每个NVMe命令中有两个域：PRP1和PRP2，Host就是通过这两个域告诉SSD数据在内存中的位置或者数据需要写入的地址。</p>
<p><img src="/images/34/1680609114540.png" alt="1680609114540"></p>
<p>PRP1和PRP2有可能指向数据所在位置，也可能指向PRP List。类似C语言中的指针概念，PRP1和PRP2可能是指针，也可能是指针的指针，还有可能是指针的指针的指针。根据不同的命令，SSD总能一层一层的剥下包装，找到数据在内存的真正物理地址。（个人理解应该是多级页表类似的东西）</p>
<p>下面是一个PRP1指向PRP List的示例：</p>
<p><img src="/images/34/1680609873982.png" alt="1680609873982"></p>
<p>PRP1指向一个PRP List，PRP List位于Page 200，页内偏移50的位置。SSD确定PRP1是个指向PRP List的指针后，就会去Host内存中（Page 200，Offset 50）把PRP List取过来。获得PRP List后，就获得数据的真正物理地址，SSD然后就会往这些物理地址读入或者写入数据。</p>
<h3 id="3-2-SGL-Scatter-Gather"><a href="#3-2-SGL-Scatter-Gather" class="headerlink" title="3.2 SGL (Scatter/Gather )"></a>3.2 SGL (Scatter/Gather )</h3><p>对Admin命令来说，它只用PRP告诉SSD内存物理地址；对I/O 命令来说，除了用PRP，Host还可以用SGL的方式来告诉SSD数据在内存中写入或者读取的物理地址。</p>
<p><img src="/images/34/1680609985979.png" alt="1680609985979"></p>
<p>Host在命令中会告诉SSD采用何种方式。具体来说，如果<strong>命令当中DW0[15：14]是0，就是PRP的方式，否则就是SGL的方式。</strong></p>
<p>SGL是一个数据结构，用以描述一段数据空间，这个空间可以是数据源所在的空间，也可以是数据目标空间。SGL(Scatter Gather List)首先是个List，是个链表，由一个或者多个<code>SGL Segment</code>组成，而每个<code>SGL Segment</code>又由一个或者多个<code>SGL Descriptor</code>组成。<code>SGL Descriptor</code>是SGL最基本的单元，它描述了一段连续的物理内存空间：起始地址+空间大小。</p>
<p>每个SGL Descriptor大小是16字节。一块内存空间，可以用来放用户数据，也可以用来放<code>SGL Segment</code>，根据这段空间的不同用途，<code>SGL Descriptor</code>也分几种类型。</p>
<p><img src="/images/34/1680610218236.png" alt="1680610218236"></p>
<p>有4种SGL Descriptor，一种是<strong>Data Block</strong>，这个好理解，就是描述的这段空间是用户数据空间；一种是<strong>Segment描述符</strong>。SGL是由SGL Segment组成的链表。既然是链表，前面一个Segment就需要有个指针指向下一个Segment，这个指针就是SGL Segment描述符，它描述的是它下个Segment所在的空间。特别地，对链表当中倒数第二个Segment，它的SGL Segment描述符我们把它叫做SGL Last Segment描述符。它本质还是SGL Segment描述符，描述的还是SGL Segment所在的空间。为什么需要把倒数第二个SGL Segment描述符单独的定义成一种类型呢？我认为是让SSD在解析SGL的时候，碰到SGL Last Segment描述符，就知道链表快到头了，后面只有一个Segement了；最后一种，<strong>SGL Bit Bucket</strong>，它只对Host读有用，用以告诉SSD，你往这个内存写入的东西我是不要的。好吧，不要，就不传了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="/images/34/1680610737566.png" alt="1680610737566"></th>
<th><img src="/images/34/1680611590697.png" alt="1680611590697"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>假设Host需要往SSD中读取13KB的数据，其中真正只需要11KB数据，这11KB的数据需要放到3个大小不同的内存中，分别是：3KB,4KB和4KB。</p>
<p>PRP与SGL的区别是：一段数据空间，对PRP来说，它只能映射到一个个物理页，而对SGL来说，它可以映射到任意大小的连续物理空间。有点像内存管理的分页与分段，果然计算机思想到哪都能用。</p>
<p><img src="/images/34/1680610810836.png" alt="1680610810836"></p>
<h2 id="4-NVMe与PCIe传输层交互"><a href="#4-NVMe与PCIe传输层交互" class="headerlink" title="4.NVMe与PCIe传输层交互"></a>4.NVMe与PCIe传输层交互</h2><p>来源：<a target="_blank" rel="noopener" href="https://www.ssdfans.com/?p=8146">蛋蛋读NVMe之四 (ssdfans.com)</a>这部分感觉对个人研究意义不大 所以就直接搬运了。方便以后看</p>
<p><img src="/images/34/1680613119866.png" alt="1680613119866"></p>
<p>任何一种计算机协议，它都是采用这种分层结构的。下层总是为上层服务的。有些协议，上图所有的层次都有定义和实现，而有些协议，只定义了其中的几层。然而，要让一种协议能工作，它需要一个完整的协议栈，PCIe定义了下三层，NVMe定义了最上层，两者一拍即合，构成一个完整的Host与SSD通讯的协议。</p>
<p>PCIe与NVMe最直接接触的是传输层。在NVMe层，我们能看到的是64字节的命令，16字节的命令返回状态，以及跟命令相关的数据。而在PCIe的传输层，我们能看到的是TLP （Transaction Layer Packet）。还是跟快递做类比，你要寄东西，可能是手机，可能是电脑，不管是什么，你交给快递小哥，他总是把你要寄的东西打包，快递员看到的就是包裹，他根本不关心你里面的内容。PCIe传输层作为NVMe最直接的服务者，不管你NVMe发给我的是命令，还是命令状态，还是用户数据，我统统帮你放进包裹，打包后交给下一层，让数据链路层继续处理。</p>
<p>PCIe传输层传输的是TLP，它就是个包裹，一般由包头和数据组成，当然也有可能只有包头没有数据。NVMe传下来的数据都是放在TLP的数据部分的（Payload）。为实现不同的目的，TLP可分为以下几种类型：</p>
<ol>
<li>Configuration Read/Write</li>
<li>I/O Read/Write</li>
<li>Memory Read/write</li>
<li>Message</li>
<li>Completion</li>
</ol>
<p>注意，这个Completion跟NVMe层的Completion不是同一个东西，他们处在不同层。在NVMe命令处理过程中，PCIe传输层基本只用Memory read/write TLP来为NVMe服务，其他TLP我们不用管。</p>
<p>一图看懂NVMe命令处理流程</p>
<p><img src="/images/34/1680654337786.png" alt="1680654337786"></p>
<p><strong>首先，Host准备了一个Read命令给SSD</strong></p>
<p><img src="/images/34/1680654364515.png" alt="1680654364515"></p>
<p>基本意思就是，这是个读指令，Host需要从起始LBA 0x20E0448(SLBA)上读取128个DWORD (512字节)的数据，读到哪里去呢？PRP1给出内存地址是0x14ACCB000。这个命令放在编号为3的SQ里 (SQID = 3)，CQ编号也是3 (CQID = 3)。</p>
<p><strong>第二步就是：Host通过写SQ的Tail DB，通知SSD来取命令</strong>。</p>
<p><img src="/images/34/1680654756554.png" alt="1680654756554"></p>
<p>上图中，上层是NVMe层，下层是PCIe的传输层，这一层我们看到的是TLP。Host想往SQ Tail DB中写入的值是5。PCIe是通过一个<strong>Memory Write TLP</strong>来实现Host写CQ的Tail DB的。</p>
<p>一个Host，下面可能连接着若干个Endpoint，该SSD只是其中的一个Endpoint而已，那有个问题，Host怎么能准确更新该SSD Controller中的Tail DB寄存器呢？怎么寻址？其实，在上电的过程中，每个Endpoint的内部空间都会通过内存映射(memory map)的方式映射到Host的内存中，SSD Controller当中的寄存器会被映射到Host的内存，当然也包括 Tail DB寄存器。Host在用Memory Write写的时候，Address只需设置该寄存器在Host内存中映射的地址，就能准确写入到该寄存器。以上图为例，该Tail DB寄存器应该映射在Host内存地址F7C11018，所以Host写DB，只需指定这个物理地址，就能准确无误的写入到对应的寄存器中去。应该注意的是：<strong>Host并不是往自己内存的那个物理地址写入东西，而是用那个物理地址作为寻址用</strong>，往SSD方向写。否则就太神奇了，往自己内存写东西就能改变SSD中的寄存器值，那不是量子效应吗？我们的东西还没有那么玄乎。</p>
<p><strong>第三步：SSD收到通知，去Host端的SQ中取指。</strong></p>
<p><img src="/images/34/1680655490881.png" alt="1680655490881"></p>
<p>PCIe是通过发一个<strong>Memory Read TLP</strong>到Host的SQ中取指的。可以看到，PCIe需要往Host内存中读取16个DWORD的数据。为什么是16 DWORD数据，因为每个NVMe命令的大小是64个字节。从上图中，我们可以推断SQ 3当前的Head指向的内存地址是0x101A41100？怎么推断来的？因为SSD总是从Host 的SQ的Head取指的，而上图中，Address就是0x101A41100，所以我们有此推断。</p>
<p>在上图中，SSD往Host发送了一个Memory Read的请求，Host通过Completion的方式把命令数据返回给SSD。和前面的Memory Write不同，Memory Read中是不含数据，只是个请求，数据的传输需要对方发个Completion。像这种需要对方返回状态的TLP请求，我们叫它Non-Posted请求。怎么理解呢？Post，有”邮政”的意思，就像你寄信一样，你往邮箱中一扔，对方能不能收到，就看快递员的素养了，反正你是把信发出去了。像Memory Write这种，就是Posted请求，数据传给对方，至于对方有没有处理，我们不在乎；而像Memory Read这种请求，它就必须是Non-Posted了，因为如果对方不响应（不返回数据）给我，Memory Read就是失败的。所以，每个Memory read请求都有相应的Completion。</p>
<p><strong>第四步：SSD执行读命令，把数据从闪存中读到缓存中，然后把数据传给Host。</strong></p>
<p>数据从闪存中读到缓存中，这个是SSD内部的操作，跟PCIe和NVMe没有任何关系，因此，我们捕捉不到SSD的这个行为。我们在PCIe接口上，我们只能捕捉到SSD把数据传给Host的过程。</p>
<p><img src="/images/34/1680655572199.png" alt="1680655572199"></p>
<p>从上图中可以看出，SSD是通过<strong>Memory write TLP</strong> 把Host命令所需的128个DWORD数据写入到Host命令所要求的内存中去。SSD每次写入32个DWORD，一共写了4次。正如之前所说，我们没有看到Completion，合理。</p>
<p><strong>第五步就是：SSD往Host的CQ中返回状态</strong></p>
<p>SSD一旦把数据返回给Host，SSD认为命令以及处理完毕，</p>
<p><img src="/images/34/1680655693047.png" alt="1680655693047"></p>
<p>从上图中可以看出，SSD是通过<strong>Memory write TLP</strong> 把16个字节的命令完成状态信息写入到Host的CQ中。</p>
<p><strong>第六步就是：SSD采用中断的方式告诉Host去处理CQ</strong></p>
<p>SSD往Host的CQ中写入后</p>
<p><img src="/images/34/1680656338713.png" alt="1680656338713"></p>
<p>SSD中断Host，NVMe/PCIe有四种方式：Pin-based interrupt, single message MSI,multiple message MSI,和MSI-X。关于中断，具体的可以参看spec 第171页，有详细介绍，有兴趣的可以去看看。从上图中，这个例子中使用的是MSI-X中断方式。跟传统的中断不一样，它不是通过硬件引脚的方式，而是把中断信息和正常的数据信息一样，PCIe打包把中断信息告知Host。上图告诉我们，SSD还是通过<strong>Memory Write TLP</strong>把中断信息告知Host，这个中断信息长度是1DWORD。</p>
<p>第七步就是：<strong>Host处理相应的CQ。</strong>Host收到中断后，Host处理相应的CQ。这步是在Host端内部发生的事情，在PCIe线上我们捕捉不到这个处理过程。</p>
<p>最后一步，Host处理完相应的CQ后，<strong>需要更新SSD端的CQ Head DB,告知SSD CQ处理完毕。</strong></p>
<p><img src="/images/34/1680656536788.png" alt="1680656536788"></p>
<p>跟前面一样，Host还是通过<strong>Memory Write TLP</strong>更新SSD端的CQ Head DB。</p>
<h2 id="5-NVMe中端到端数据保护功能"><a href="#5-NVMe中端到端数据保护功能" class="headerlink" title="5.NVMe中端到端数据保护功能"></a>5.NVMe中端到端数据保护功能</h2><p>来源：<a target="_blank" rel="noopener" href="http://www.ssdfans.com/?p=8148">蛋蛋读NVMe之五 (ssdfans.com)</a></p>
<p>Host与SSD之间，数据传输的最小单元是逻辑块（Logical Block,LB），每个逻辑块大小可以是512/520/1024/2048/4096字节等，Host在格式化SSD的时候，逻辑块大小就确定了，以后两者就按这个逻辑块大小进行数据交互。</p>
<p>数据从Host到NVM（Non-Volatile Memory，目前一般是闪存，后面我就用闪存来代表NVM），首先要经过PCIe传输到SSD的Controller，然后Controller把数据写入到闪存；反过来，Host想从闪存上读取数据，首先SSD Controller从闪存上获得数据，然后经过PCIe把数据传送给Host。</p>
<p><img src="/images/34/1680657295119.png" alt="1680657295119"></p>
<p>Host与SSD之间，数据在PCIe上传输的时候，由于信道噪声的存在（说白了就是存在干扰），可能导致数据出错；另外，在SSD内部，Controller与闪存之间，数据也可能发生错误。路途凶险。为确保Host与闪存之间数据的完整性，即Host写入到闪存的数据与最初Host写的数据一致，以及Host读到的数据与最初从闪存上读上来的数据一致，NVMe提供了一个端到端数据保护功能。</p>
<p>除了逻辑块数据本身，NVMe还允许每个逻辑块带个助理，叫做元数据（Meta Data）。这个助理的职责，NVMe虽然没有明确的要求，但如果数据需要保护，NVMe要求这个助理必须能充当保镖的角色。</p>
<p>元数据有两种存在方式，一种是作为逻辑块数据的扩展，和逻辑块数据放一起存放，这是贴身保镖：</p>
<p><img src="/images/34/1680657794179.png" alt="1680657794179"></p>
<p>另外一种方式就是逻辑块数据放在一起，元数据单独放在别处。虽不是贴身保护，但保镖在附近时刻注意着主人的安全，属非贴身保镖：</p>
<p><img src="/images/34/1680658047226.png" alt="1680658047226"></p>
<p>贴身保护与否，我们不关心形式，我们只关心元数据是如何保护逻辑块数据的。NVMe要求每个逻辑块数据的保镖配备下面这把武器:</p>
<p><img src="/images/34/1680659045782.png" alt="1680659045782"></p>
<p>其中的”Guard”是16比特的CRC （Cyclic Redundancy Check），它是逻辑块数据算出来的；”Application Tag”和”Reference Tag”包含该数据块的逻辑地址（LBA）等信息。CRC校验能够检测出数据是否有错，后者则是保证数据不会出现张冠李戴的问题。</p>
<p>佩了保镖的数据看起来就是下面这个样子（以512字节的数据块为例）：</p>
<p><img src="/images/34/1680659118271.png" alt="1680659118271"></p>
<p>在Host与SSD数据传输过程中，NVMe可以让每个逻辑块数据都带上保镖，也可以让他们不带保镖，也可以在某个治安差的地方把保镖带上，然后在治安环境好的地方不用保镖。</p>
<p><strong>Host往SSD写入数据，不带保镖的情况：</strong></p>
<p><img src="/images/34/1680659147592.png" alt="1680659147592"></p>
<p>如果是无关紧要的数据，完全没有必要进行端到端的保护，毕竟数据保护需要传输额外的数据 （每个逻辑数据块需要至少额外8字节的数据保护信息，有效带宽减少），还需要SSD做额外的数据完整性校验（耗时，性能变差），最关键的是PCIe通道上，其数据天然就能受到保护。</p>
<p>对每个TLP来说，其中有个Digest域，就是对HDR和Data进行数据保护的，本质就是CRC。这个Digest是可选的。如果使能了Digest，数据在PCIe上传输是毫无风险的，因为有便衣警察保护，在NVMe层完全没有必要进行额外的数据保护。</p>
<p>当然，它不能发现数据张冠李戴的问题。</p>
<p><strong>Host往SSD写入数据，全程带上保镖的情况</strong>：</p>
<p><img src="/images/34/1680659340015.png" alt="1680659340015"></p>
<p>红色<strong>PI</strong>，Protection Information。</p>
<p>Host数据通过PCIe传输到SSD Controller之间，按理来说数据已经受到PCIe的保护，但PCIe保镖也有可能不在情况，那就是TLP中Digest域可能不存在，这是PCIe允许的。这个时候，如果要保证在PCIe上数据传输的可靠性，就需要NVMe自带保镖。数据到达SSD Controller时，SSD Controller会重新计算逻辑块数据的CRC，与保镖的CRC比较，如果两者匹配，说明数据传输是没有问题的；否则，数据就是有问题的，这个时候，SSD Controller就会给Host报错。</p>
<p>除了CRC校验，还要检测有没有张冠李戴的问题，通过检测Reference Tag 和Application Tag，看看这个没有CRC问题的数据是不是该笔Host写命令对应的数据，如果不匹配，同样需要向Host报错。</p>
<p>如果数据检测没有问题，SSD Controller会把逻辑块数据和PI一同写入闪存中。这个PI一同写入到闪存中有什么意义呢？在读的时候有意义。</p>
<p><img src="/images/34/1680659978487.png" alt="1680659978487"></p>
<p>SSD Controller读闪存的时候，会对读上来的数据进行CRC校验，如果写入的时候带有PI，这个时候就能检测出读上来的数据是否正确，从而决定这个数据要不要传给Host。有人要说，对闪存来说，数据不是受ECC保护吗？为什么还要额外进行数据校验？没错，写入到闪存中的数据是受ECC保护，这个没有问题，但在SSD内部，数据从Controller到闪存之间，一般都要经过DRAM或者SRAM，在之前SSD Controller写入到闪存，或者这个时候从闪存读数据到SSD Controller，可能就会发生比特翻转之类的小概率事件，从而导致数据不正确。如果在NVMe层再做个CRC保护，这类数据错误就能被发现了。</p>
<p>除了数据在SSD内发生反转，由于固件问题，或者别的原因，还是会出现数据张冠李戴的问题：数据虽然没有CRC错误，但是它不是我们想要的数据。因此，还需要做Reference Tag和Application Tag检测。</p>
<p>SSD Controller通过PCIe把数据传给Host，Host端也会对数据进行校验，看SSD返回过来的数据是否有错。</p>
<p><strong>Host往SSD写入数据，半程带保镖的情况</strong>：</p>
<p><img src="/images/34/1680660184516.png" alt="1680660184516"></p>
<p>这种情况，Host与Controller端之间是没有数据保护，因为PCIe已经能提供数据完整性保证了（TLP中的Digest使能）。但在SSD内部，Controller到闪存之间，由于乱七八糟的原因（数据反转，LBA数据不匹配），存在数据错误的可能，NVMe要求SSD Controller在把数据写入到闪存前，计算好数据的PI，然后把数据和PI一同写入到闪存。</p>
<p>SSD Controller读闪存的时候，会对读上来的数据进行PI校验，如果没有问题，剥除PI，然后把逻辑块数据返回给Host；如果校验失败，说明数据存在问题，SSD需要向Host报错。如下图所示：</p>
<p><img src="/images/34/1680660680739.png" alt="1680660680739"></p>
<p>数据端到端保护是NVMe的一个特色，其本质就是在数据块当中加入CRC和数据块对应的LBA等冗余信息，SSD Controller或者Host端利用这个这些信息进行数据校验，然后根据校验结果执行相应的操作。加入这些检错信息的好处是能让Host与SSD Controller及时发现数据错误，副作用就是：</p>
<ol>
<li>每个数据块需要额外的至少8字节的数据保护信息，有效带宽减少：数据块大小越小，带宽影响越大。</li>
<li>SSD Controller需要做数据校验，影响性能。</li>
</ol>
<h1 id="6-NVMe的命名空间"><a href="#6-NVMe的命名空间" class="headerlink" title="6.NVMe的命名空间"></a>6.NVMe的命名空间</h1><p>来源：<a target="_blank" rel="noopener" href="http://www.ssdfans.com/?p=8157">蛋蛋读NVMe之六 (ssdfans.com)</a></p>
<p><img src="/images/34/1680661034564.png" alt="1680661034564"></p>
<p>上图中红圈圈起来的是一个NVMe子系统，通常来说就是SSD。一个NVMe SSD主要由<strong>SSD Controller</strong>，<strong>闪存空间</strong>和<strong>PCIe接口</strong>组成。如果把闪存空间划分成若干个独立的逻辑空间，每个空间逻辑块地址（LBA）范围是0到N-1 (N是逻辑空间大小)，这样划分出来的每一个逻辑空间我们就叫做NS。对SATA SSD来说，一个闪存空间只对应着一个逻辑空间，与之不同的是，NVMe SSD可以是一个闪存空间对应多个逻辑空间。</p>
<p>每个NS都有一个名称与ID，如同每个人都有名字和身份证号码，ID是独一无二的，系统就是通过 NS的ID来区分不同的NS。</p>
<p><img src="/images/34/1680661191271.png" alt="1680661191271"></p>
<p>如上图例子，整个闪存空间划分成2个NS，名字分别是NS A和NS B，对应的NS ID分别是1和2。如果NS A大小是M （以逻辑块大小为单位），NS B大小是N，则他们的逻辑地址空间分别是0到M-1和0到N-1。Host读写SSD，都是要在命令中指定读写的是哪个NS中的逻辑块。原因很简单，如果不指定NS，对同一个LBA来说，假设就是LBA 0，SSD根本就不知道去读或者写哪里，因为有两个逻辑空间，每个逻辑空间都有LBA 0。</p>
<p>一个NVMe命令一共64字节，其中第4到第7个Byte指定了要访问的NS。</p>
<p><img src="/images/34/1680661290794.png" alt="1680661290794"></p>
<p>对每个NS来说，都有一个4KB大小的数据结构来描述它</p>
<p><img src="/images/34/1680663023189.png" alt="1680663023189"></p>
<p>该数据结构描述了该NS的大小，整个空间已经写了多少，每个LBA的大小，以及端到端数据保护相关设置，该NS是否属于某个Controller还是几个Controller可以共享，等等。</p>
<p>NS由Host创建和管理，每个创建好的NS，从Host操作系统角度看来，就是一个独立的磁盘，用户可在每个NS做分区等操作。</p>
<p><img src="/images/34/1680663042816.png" alt="1680663042816"></p>
<p>上例中，整个闪存空间划分成两个NS，NS A和NS B，操作系统看到两个完全独立的磁盘。我的天呀，太神奇了，我买一个SSD，居然得到两个磁盘，赚大发了。</p>
<p>每个NS是独立的，逻辑块大小可以不同，端到端数据保护配置也可以不同：你可以让一个NS使用保镖，另一个NS不使用保镖，再一个NS半程使用保镖（见《<a target="_blank" rel="noopener" href="http://www.ssdfans.com/?p=1282">蛋蛋读NVMe之五</a>》）。</p>
<p>其实，NS更多的是应用在企业级，可以根据客户不同需求创建不同特征的NS，也就是在一个SSD上创建出若干个不同功能特征的磁盘（NS）供不同客户使用。</p>
<p>NS的另外一个重要使用场合是：SR-IOV。</p>
<p>什么是SR-IOV？ 英文全称为 Single Root- I/O Virtualization，SR-IOV技术允许在虚拟机之间高效共享PCIe设备，并且它是在硬件中实现的，可以获得能够与本机性能媲美的I/O 性能。单个I/O 资源（单个SSD）可由许多虚拟机共享。共享的设备将提供专用的资源，并且还使用共享的通用资源。这样，每个虚拟机都可访问唯一的资源。</p>
<p><img src="/images/34/1680663067817.png" alt="1680663067817"></p>
<p>如上图所示，该SSD作为PCIe的一个Endpoint，实现了一个物理功能 (Physical Function ,PF)，有4个虚拟功能（Virtual Function，VF）关联该PF。每个VF，都有自己独享的NS，还有公共的NS （NS E)。此功能使得虚拟功能可以共享物理设备，并在没有 CPU 和虚拟机管理程序软件开销的情况下执行 I/O。关于SR-IOV更多知识，请自行百度或者谷歌。这里我们只需知道NVMe中的NS有用武之地就可以。</p>
<p>对一个NVMe子系统来说，除了包含若干个NS，还可以由若干个 SSD Controller。注意，这里不是说一个SSD Controller有多个CPU，而是说一个SSD有几个实现了NVMe功能的Controller。</p>
<p><img src="/images/34/1680663088125.png" alt="1680663088125"></p>
<p>如上图例子，一个NVMe子系统包含了两个Controller，分别实现不同功能（也可以是相同功能）。整个闪存空间分成3个NS，其中NS A由Controller 0（左边）独享，NS C由Controller 1（右边）独享，而NS B是两者共享。独享的意思是说只有与之关联的Controller才能访问该NS，别的Controller是不能对之访问的，上图中Controller 0是不能对NS C进行读写操作的，同样，Controller 1也不能访问 NS A；共享的意思是说，该NS（这里是NS B）是可以被两个Controller共同 访问的。对共享NS，由于几个Controller都可以对它进行访问，所以要求每个Controller对该NS的访问都是原子操作，从而避免同步问题。</p>
<p>事实上，一个NVMe子系统，除了可以有若干个NS，除了可以有若干个Controller，还可以有若干个PCIe接口。</p>
<p><img src="/images/34/1680663130886.png" alt="1680663130886"></p>
<p>与前面的架构不一样，上图的架构是每一个Controller有自己的PCIe接口，而不是两者共享一个。Dual Port，哈哈，在SATA SSD上没有见过吧。这两个接口，往上有可能连着同一个主机，也可能连着不同的主机。现在能提供 Dual PCIe Port的SSD 接口只有SFF-8639 ，也叫U.2，它支持标准的NVMe协议和Dual-Port，号称SSD接口明日之星。</p>
<p><img src="/images/34/1680680846539.png" alt="1680680846539"></p>
<p>下图是两个PCIe接口连着一个主机的情况：</p>
<p><img src="/images/34/1680681617859.png" alt="1680681617859"></p>
<p>为什么要这么玩？</p>
<p>我认为，一方面，Host访问SSD，可以双管齐下，性能可能更好点。不过对访问NS B来说，同一时刻只能被一个Controller访问，双管齐下又如何。考虑到还可以同时操作NS A 和 NS C，性能或多或少的有所提升。</p>
<p>我觉得，更重要的是，这种双接口冗余设计，可以提升系统可靠性。假设 PCIe A接口出现问题，这个时候Host可以通过 PCIe B无缝衔接，继续对NS B进行访问。当然了，NS A是无法访问了。</p>
<p>如果Host突然死机怎么办？据小道消息，阿法狗输给李世石那盘，就是阿法狗死机了，然后重启再战，结果超时认输。哈哈，开个玩笑。在一些很苛刻的场景下，是不允许Host宕机的。但是，是电脑总有死机的时候，怎么办？最直接有效的办法还是采用冗余容错策略：SSD有两个Controller，有两个PCIe接口，那么我主机也弄个双主机：一个主机挂了，另一个主机接管任务，继续执行，你就慢慢重启吧。</p>
<p><img src="/images/34/1680681697873.png" alt="1680681697873"></p>
<p>蛋蛋似乎就更新了六部分。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/04/01/33-FEMU%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94ZNS%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/33-FEMU%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94ZNS%EF%BC%881%EF%BC%89/" itemprop="url">FEMU源码阅读——ZNS（1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T21:55:26+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>FEMU是弗吉尼亚理工学院的<strong>Huaicheng LI</strong>教授团队开发的一款SSD模拟器。基于QEMU，所以模拟出来的SSD设备可以被qemu使用。FEMU可用于模拟多种SSD，个人研究更关注ZNS SSD ，所以找到了相关部分的代码。</p>
<p>代码路径：FEMU/hw/femu/zns</p>
<p>该路径中有两个文件：</p>
<p><img src="/images/33/1680349189919.png" alt="1680349189919"></p>
<h2 id="0-需要明确的一些概念"><a href="#0-需要明确的一些概念" class="headerlink" title="0.需要明确的一些概念"></a>0.需要明确的一些概念</h2><ul>
<li><strong>Namespace</strong>是NVMe SSD中的一个概念，它是将闪存空间划分成若干个独立的逻辑空间，每个空间逻辑块的地址范围为0到N-1（N是逻辑空间大小），这样划分的每个逻辑空间叫做Namespace。每个Namespace都有一个名称和ID，系统是通过NS的ID来区分不同的NS。</li>
<li><strong>Zone</strong>，NVMe Zoned Namespaces是NVMe规范中的一套新命令集，该命令集暴露了一套接口（zoned block storage interface）给主机，该接口将其容量划分为多个Zone，在每个Zone内允许随机读，但只允许顺序写。每个Zone都有一段LBA (Logical Block Address, 逻辑地址空间)区间，这段区间只能顺序写，而且如果要覆盖写，则必须显示的进行一次擦除操作。在这套命令集中，NS由zone组成。似乎官方文档中并没有明确的说明同一NS中的zone大小必须一致。</li>
</ul>
<h2 id="1-头文件zns-h"><a href="#1-头文件zns-h" class="headerlink" title="1. 头文件zns.h"></a>1. 头文件zns.h</h2><p>该文件包含了许多与NVMe Zoned 命名空间的相关定义和结构。其中有很多结构的名称全面都加了一个宏<code>QEMU_PACKED</code>。该宏定义用于指定结构体的对齐方式。在使用QEMU时可以使用这个宏来指定结构体的对齐方式。</p>
<h2 id="2-源文件zns-c"><a href="#2-源文件zns-c" class="headerlink" title="2. 源文件zns.c"></a>2. 源文件zns.c</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/04/01/32-%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/32-%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/" itemprop="url">云存储有关的一些简单概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T16:34:10+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-什么是云存储"><a href="#1-什么是云存储" class="headerlink" title="1.什么是云存储"></a>1.什么是云存储</h2><p>云存储的出现为数据存储提供了一条更加便捷的道路。于使用者而言，他们可以通过互联网技术，无视时间、地方和装置的限制，连接到“云”上方便地存取数据，从而满足用户渴望利用IT资源即时按需访问业务的需求。</p>
<p><img src="/images/32/1680266317937.png" alt="1680266317937"></p>
<p>简单来讲，个人感觉只要，存储服务是远端存储设备提供的，就都可以称作是云存储。 用户无需考虑存储节点如何部署，也无需考虑背后的数据如何在存储设备中进行组织。因为这些都是云存储服务的提供商需要去考虑的事情。用户只需要享受云提供的存储服务即可。</p>
<h2 id="2-云存储架构"><a href="#2-云存储架构" class="headerlink" title="2.云存储架构"></a>2.云存储架构</h2><p>云存储的架构这里指的是云存储设备的部署方式，分为传统的集中式存储与目前云存储主流的分布式系统。</p>
<p><img src="/images/32/1680335522811.png" alt="1680335522811"></p>
<h3 id="2-1-集中式存储"><a href="#2-1-集中式存储" class="headerlink" title="2.1 集中式存储"></a>2.1 集中式存储</h3><p>存储介质集中分布，采用双控或者多控的方式统一管理所有节点，控制器通常使用专业线缆或者网络为一台或多台服务器提供存储服务，需不断升级或更换存储设备来满足容量和性能的需求，数据可靠性与可用性依赖单个或少数存储设备。</p>
<h3 id="2-2-分布式存储"><a href="#2-2-分布式存储" class="headerlink" title="2.2 分布式存储"></a>2.2 分布式存储</h3><p>存储介质分布到不同的地理位置，节点之间相互关联共同管理维护数据，通常使用标准的网络协议和接口，可为更多的服务器或互联网主机访问。通过增加存储节点提高容量和性能。数据可靠性和可用性依赖不同节点多副本备份与故障恢复机制，故障容忍性更强。</p>
<h3 id="2-3-归纳总结"><a href="#2-3-归纳总结" class="headerlink" title="2.3 归纳总结"></a>2.3 归纳总结</h3><p>从这个表格中我们也可以看出分布式存储的优势，也就是为什么云存储现在更多的使用分布式存储的原因。</p>
<p><img src="/images/32/1680335677836.png" alt="1680335677836"></p>
<h2 id="3-云存储的服务类型"><a href="#3-云存储的服务类型" class="headerlink" title="3.云存储的服务类型"></a>3.云存储的服务类型</h2><p>云存储服务类型是从云存储给外界提供的服务形式上划分，主要分为三大类，块存储，文件存储与对象存储。</p>
<h3 id="3-1块存储"><a href="#3-1块存储" class="headerlink" title="3.1块存储"></a>3.1块存储</h3><p><strong>块存储</strong>是较为底层的存储服务<strong>。</strong>将裸磁盘空间映射给主机使用，用户需要对磁盘进行分区和格式化，然后才能读写数据，类似物理硬盘。它的特点是可以提供高速的随机读写能力，适合IO密集型的高性能、低延迟的业务场景，如数据库、虚拟机等。但是扩展能力有限，不利于数据共享，且需要专业的线缆和网络设备支持。</p>
<p><img src="/images/32/1680336179252.png" alt="1680336179252"></p>
<h3 id="3-2文件存储"><a href="#3-2文件存储" class="headerlink" title="3.2文件存储"></a>3.2文件存储</h3><p><strong>文件存储</strong>是在文件系统一层对外提供服务，主机可以直接访问文件系统中的文件和目录，无需进行分区和格式化。文件存储服务支持多个主机同时访问同一个文件系统。相当于在块存储的基础上格式化了一个文件系统给用户去使用，这样大家都是用同一套文件系统。而不是提供一块裸空间，大家根据自己的需求去分区格式化自己的系统。所以文件系统的显著的特点就是方便实现数据共享和协作，只需通过网络对外提供访问文件系统的接口即可。但是读写速度受限于网络带宽和文件系统的处理速度，不适用于海量数据的存储和传输。</p>
<p><img src="/images/32/1680336652684.png" alt="1680336652684"></p>
<h3 id="3-3对象存储"><a href="#3-3对象存储" class="headerlink" title="3.3对象存储"></a>3.3对象存储</h3><p><strong>对象存储</strong>将数据以对象的形式存储在一个扁平的地址空间中，每个对象包含了数据和元数据。访问者可以通过对象标识来获取或修改对象。它的特点具有高可扩展性和高可靠性，可以支持海量数据的存储和传输，而且不受文件系统的限制。适合用于存储海量的非结构化数据，但是不支持文件的随机读写和在线修改。比如视频网站的视频，购物网站的商品图片都是使用对象存储。对象存储的访问过程大家也都比较熟悉，通用的以太网+http协议访问。</p>
<p><img src="/images/32/1680337053266.png" alt="1680337053266"></p>
<h3 id="3-4总结比较"><a href="#3-4总结比较" class="headerlink" title="3.4总结比较"></a>3.4总结比较</h3><p><img src="/images/32/1680337135081.png" alt="1680337135081"></p>
<p>所以说三种服务类型并没有绝对的谁好谁坏 ，不管是商业的 还是开源的云存储系统，基本都会提供这三种用户可以应该针对不同的应用场景。</p>
<p>学习来源：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WE41177Kp/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=981cea5abbe570eed16fd93ab75067d7">块、文件、对象存储概述_哔哩哔哩_bilibili</a></p>
<p>b站：新爷话数据</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/03/24/31-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8E%E5%AD%98%E5%82%A8%E7%A0%94%E7%A9%B6%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B8%8D%E5%A4%A7)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/24/31-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8E%E5%AD%98%E5%82%A8%E7%A0%94%E7%A9%B6%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B8%8D%E5%A4%A7)/" itemprop="url">总线、协议与接口（与存储研究相关性不大)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-24T19:01:35+08:00">
                2023-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id><a href="#" class="headerlink" title=" "></a> </h1><h2 id="0-总线、协议、接口"><a href="#0-总线、协议、接口" class="headerlink" title="0.总线、协议、接口"></a>0.总线<strong>、</strong>协议<strong>、</strong>接口</h2><p>首先，要搞清楚<strong>总线</strong>、<strong>协议</strong>、<strong>接口</strong>这三者之间的关系。</p>
<ul>
<li><p><strong>总线</strong>（BUS）就是不同设备之间交互数据的通路，且有一定的承载能力限制(总线带宽)。</p>
</li>
<li><p><strong>协议</strong>就是两个设备之间通信的规矩。两个设备之间只有使用同样的协议才能够进行通信。和网络协议是一样的，也规定了编码方式表示方式之类的。比如我一秒钟之内的通电断电代表什么意思，想想摩斯电码类似的。但是计算机内部的通信协议肯定比较复杂而且很妙，高效的协议也需要顶尖设备支持。</p>
</li>
<li><p><strong>接口</strong></p>
<p>所以总的来说协议就是，用某种形式，以某种规格利用某种物体把数据传输出去。那么硬盘与其他设备进行沟通，就需要【数据协议】【传输总线作为媒介】【某种物理接口接入】。</p>
</li>
</ul>
<h2 id="1-常见的总写协议以及接口"><a href="#1-常见的总写协议以及接口" class="headerlink" title="1.常见的总写协议以及接口"></a>1.常见的总写协议以及接口</h2><ul>
<li><p>常见的数据协议，协议【<strong>IDE</strong>】是早期硬盘协议已被淘汰，剩下三种，民用的【<strong>AHCI</strong>】【<strong>NVMe</strong>】与服务器常用的【<strong>SCSI</strong>】</p>
</li>
<li><p>传输总线有三种民用的【<strong>SATA</strong>】【<strong>PCIe</strong>】和服务器常用的【<strong>SAS</strong>】</p>
</li>
<li><p>现在有了总线和协议，还需要物理接口讲硬盘接入到总线之上。这里面的关系就直接截视频里的图了。</p>
</li>
</ul>
<p><img src="/images/31/1679654702940.png" alt="1679654702940"></p>
<p>三者均限制数据传输的快慢。相辅相成。</p>
<p>这里只是做简单科普，与研究相关性不大。参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qv411t7ZL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=981cea5abbe570eed16fd93ab75067d7">【硬件科普】硬盘的SATA M.2 NGFF NVME是什么意思，详解硬盘的总线协议与接口_哔哩哔哩_bilibili</a></p>
<h2 id="2-NVMe协议与NVMe驱动。"><a href="#2-NVMe协议与NVMe驱动。" class="headerlink" title="2.NVMe协议与NVMe驱动。"></a>2.NVMe协议与NVMe驱动。</h2><p>NVMe设备就是支持NVMe协议的设备，通常指代的都是NVMe SSD，也就是使用PCIe接口和NVMe协议的固态硬盘。NVMe设备相比于传统的SATA或SAS设备，具有更高的速度、更低的延迟、更多的并行性和更好的可扩展性等优点 。</p>
<p>NVMe协议和NVMe驱动是两个不同的概念，但是它们都是为了提高闪存类存储的性能而设计的<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/48972075">1</a>。</p>
<p>NVMe协议是一种通信协议，它定义了如何在PCIe接口上发送和接收NVMe命令和数据。NVMe协议利用PCIe的高带宽和多队列特性，实现了高效的数据传输和并行处理<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260522647">2</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/363589126">3</a>。</p>
<p>NVMe驱动是一种软件，它实现了NVMe协议的功能，让操作系统能够识别和管理NVMe设备。NVMe驱动比传统的SATA或SAS驱动更简单和轻量，因为它直接与系统CPU通信，减少了不必要的步骤和延迟<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74239027">4</a> 。</p>
<p>简单来说，NVMe协议是一种规范，NVMe驱动是一种实现。它们都是为了让闪存类存储发挥更好的性能而设计的。</p>
<p>SO！ NVMe协议就是 SSD与系统通信的一个规则  ，NVMe驱动就是这套规则的一个实现，我们高存储的根本不需要管这个东西，好那不看了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/02/13/%E5%8A%9B%E6%89%A3%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/02/13/%E5%8A%9B%E6%89%A3%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" itemprop="url">跟着labuladong猛猛刷题（持续更新）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-02-13T09:10:30+08:00">
                2023-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day-1："><a href="#Day-1：" class="headerlink" title="Day 1："></a>Day 1：</h1><ol>
<li><p>两个栈可以实现队列，一个队列就可实现一个栈。</p>
<p>两个栈实现队列的时候，只有在出队列时 ，如果 “出栈”栈为空，需要有  入栈栈到出栈栈的转移操作。</p>
<p>一个队列实现栈时，每次入栈都需要将队列进行“翻转”（重新全部入队列，最终将队尾移动到对头）。</p>
</li>
<li><p>遇到对时间复杂度有要求的就空间换时间。</p>
</li>
<li><p><strong>INT_MAX</strong> 可用来表示正无穷，<strong>INT_MIN</strong>表示负无穷。</p>
</li>
<li><p>倒序一个链表，优先想到栈（先入后出!）</p>
</li>
<li><p>判断链表有无环，快慢双指针。  画图能够迅速帮你找到解决思路！！！！杨老师！谢谢你  画图列方程</p>
</li>
<li><p>由于链表经常要用前一个值操作后一个值，所以经常要考虑边界值。</p>
</li>
<li><p>对于深度克隆，比如随机链表复制，无向图复制，要想到哈希表。</p>
</li>
</ol>
<h1 id="Day-2："><a href="#Day-2：" class="headerlink" title="Day 2："></a>Day 2：</h1><ol>
<li><strong>链表一定要考虑边界值啊！！</strong>第2次了。链表操作A-&gt;next的时候一定要考虑A是否为空；</li>
<li><strong>非递减数列</strong>两数求和，别想那么多，先给大窗口，然后缩小，</li>
<li>双指针，快慢双指针，左右双指针（中心扩张，两边收缩）</li>
<li>如果有正负的情况，千万不要自作从聪明，将某个值设为0，不然比大小时候会出现bug。</li>
<li>如果说写出的代码分为好多种情况，那么思路一定是错了。</li>
<li>树的层序遍历需要用到队列。当需要记录层数时，需要用到额外的变量，并用到for循环</li>
<li>动态规划问题的第一个性质：<strong>重叠子问题</strong> 。 设置备忘录。一般是哈希表。数组也可以。如果可以看出数组长度不会超过某个最大值，就可以用数组。但这是个稀疏数组。</li>
</ol>
<h1 id="Day-3："><a href="#Day-3：" class="headerlink" title="Day 3："></a>Day 3：</h1><ol>
<li><p><strong>回溯代码框架</strong>，设最后返回的集合是res，res里面的元素是方案（路径）,路径中为节点，第一步我们要搞清，方案是什么，路径是什么，节点又是什么。（比如n皇后问题，方案是整个棋盘，选择是在第row行选择第col个点）所以backtrace的参数就是（棋盘，row）</p>
</li>
<li><p>回溯算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(状态参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(设置结束条件)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(路径)；</span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//排除不合法选择 </span></span><br><span class="line">        <span class="keyword">if</span>(！is_valid（)）</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        选择();</span><br><span class="line">        进入下一层</span><br><span class="line">        退选择</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p>
</li>
<li><p>组合问题，给定数组自带顺序，且答案中[1,2] [2,1]算是相同结果的，甚至可以不用is_valid;因为仔细想一下，比如选择到2，那么1 一定选过了  ，3一定没选过。（自行理解其中奥义很简单）。</p>
</li>
<li><p>求 有重复数据的子集 要先排序。然后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为和上一个相同的话， 下一个back_trace(nums,k,i+1)会得到相同的结果</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) </span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    subresult.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">back_trace</span>(nums,k,i+<span class="number">1</span>);</span><br><span class="line">    subresult.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BFS:  将问题抽象为一幅图  ，  找到节点 ，以及节点的邻居。那么算法的流程就是从初始节点开始。比如开密码锁，每个节点就是 密码锁当前的数字，那么邻居就是，转动一位得到的数字。</p>
</li>
</ol>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4 :"></a>Day 4 :</h1><ol>
<li>搞不定边界就尽量不要使用双重二分。</li>
<li><strong>检查是不是break和continue 用混了！！！！</strong></li>
<li>动态寻找最大值最小值的时候要初始化一个结果！不能只声明。</li>
<li>集合之间对比，要想到unordered_map</li>
</ol>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5:"></a>Day 5:</h1><ol>
<li>股票问题因为给的数组不是有序的，所以不能使用双指针法。</li>
<li>动态规划超出时间限制就要反思是否有重叠子问题，设置备忘录解决。</li>
<li>自顶向下的动归是递归，有可能会遇到重复子问题，自底向上的动归是迭代，但是空间复杂度高一点。</li>
<li>如果动态规划的开始和末尾相互影响。就要分出情况。</li>
<li>vector.end() 并不是最后一个元素的指针 而是最后一个元素的下一个指针</li>
<li>回溯法毕竟是穷举，拥有极高的时间复杂度。如果有其他解法尽量不要用穷举。</li>
<li>不该超出时间限制的时候超出时间限制，检查起始条件 ，终止条件，以及变化条件。</li>
</ol>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><ol>
<li>使用双指针时要确保指针移动啊。</li>
<li>差分数组要多一位（其实也没必要，得看情况）。</li>
</ol>
<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><ol>
<li>二分搜索时候左右边界问题别搞错了啊。 左边界查看left==num.size()  右边界查看left-1&lt;0;</li>
<li>二分搜索如果没找到不返回特殊值的话，左右边界还是很好写的。</li>
<li>转换思路才能二分搜索。比如给定天数，让你求运输船最小承载。这个不好算，那就转换成给出承载，返回最小天数。这就可以用二分了。这个转变思路非常巧妙。</li>
<li>无论是升序降序  左边界返回left 右边界返回left-1；</li>
</ol>
<h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><ol>
<li>vector erase和遍历数组没有区别，时间复杂度很高。易超出时间限制</li>
<li>排序的  比较函数  大于为真是降序  小于为真是升序</li>
<li>unordered_set 是不支持随机存取的。所以要用unordered_map 与 vector实现随机读取；</li>
<li>要分清出<strong>子序列</strong>与<strong>子串</strong>的区别，字串必须连续，子序列不必连续；</li>
<li>都tm什么时候了还在 犯”=” 和 “==”的错误。现在还非常容易犯小错误</li>
</ol>
<h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><ol>
<li>树的遍历中，如果遍历结果包含着空指针，那么不需要有别的遍历辅助，也能够确定一棵树。</li>
<li><strong>stoi()</strong>可以把字符串转化成为数字。  <strong>to_string</strong> 可以将数字转化为字符串</li>
<li>可以用  map用于关联字符串与节点, set用于检测字符串重复。</li>
</ol>
<h1 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h1><ol>
<li>涉及到区间和  那就一定会有前缀和数组！！  而对区间进行统一操作，那就一定会有差分数组？</li>
<li>归并排序的一个重要思想，凡是已经在同一部分里的，就一定发生过关系了。只有和另一部分的没有发生过关系。<strong>（非常重要的思想）</strong></li>
<li>而且如果无序很难，但是发现有序很好做，那么可以去想想归并排序，  或者看到题目中有 数组的性质是， 当i&lt;j  </li>
<li>前缀和 要思考 有没有</li>
<li>BST 的中序遍历结果是有序的（升序）。  可以说遇到二叉搜索树，大概率是中序遍历</li>
</ol>
<h1 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h1><ol>
<li><p>快速排序是 树的前序遍历     归并排序是树的后序遍历</p>
</li>
<li><p>快速排序为了达到稳定的快速，数组要是乱序。函数shuffle() 可以随机打乱</p>
</li>
<li><p>快速排序中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(cur&lt;=right &amp;&amp; nums[cur]&gt;=nums[p]) cur++;<span class="comment">//自己体会</span></span><br><span class="line"> <span class="comment">//而且需要特殊的交换操作</span></span><br><span class="line"><span class="built_in">swap</span>(nums[p],nums[cur]);  </span><br><span class="line"><span class="built_in">swap</span>(nums[p+<span class="number">1</span>],nums[cur])；<span class="comment">// 交换后这</span></span><br><span class="line">p+=<span class="number">1</span>;</span><br><span class="line">cur = p+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>srand(time(0)); 生成随机树种子</p>
</li>
<li><p>堆是完全二叉树 ，然后再满足父节点大于等于 或小于等于子节点。所以插入的时候，先插入满足完全二叉树的位置，在满足第二个要求。删除的时候 先交换 再下降。</p>
</li>
<li><p><strong>完全二叉树用数组实现非常方便</strong>。  节点 i 的左子节点  2i  右子节点2i+1</p>
</li>
<li><p>优先级队列定义比较函数必须是静态成员函数的？</p>
</li>
<li><p><strong>判断完全二叉树是否是满二叉树</strong>，左节点一直找下去，右节点一直找下去，看看高度是否相同。</p>
</li>
<li><p>if 后面如果不是一句话 一定不要忘了加花括号啊</p>
</li>
</ol>
<h1 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h1><ol>
<li><p>图结构表示方法，如果目的不是要迅速判断两节点之间是否有边，那还是使用邻接表方便一点。</p>
</li>
<li><p>拓扑排序 需要额外的数组记录节点的入度；</p>
</li>
<li><p>int 类型的0   1  可以用逻辑运算符操作。</p>
</li>
<li><p>连通性使用 并查集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">       		 parent[x] = <span class="built_in">find_root</span>(parent[x]);</span><br><span class="line">    	&#125;    </span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通 联通分量等于节点数</span></span><br><span class="line">        count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        <span class="comment">//尺寸全部初始化为1</span></span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find_root</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find_root</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将两棵树合并为一棵 以下二者选一即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 两个分量合二为一</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getcount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find_root</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find_root</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并查集可以建立虚拟头部，从而排除异己。</p>
</li>
<li><p>在二位坐标中控制方向常用方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125; <span class="comment">//对应下 右 上 左</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类的后面要加；</p>
</li>
<li><p>只有判断无向图是否带环时才能用并查集。</p>
</li>
<li><p>克鲁斯卡尔算法 Kruskal 算法  就是无向有权图 按权重大小一次加边；</p>
</li>
<li><p>并查集的时间复杂度是0(1);</p>
</li>
<li><p>无向有权图的最小生成树算法 prim算法需要转换成图的邻接表格式。 Kruskal 不用 ，给的如果是边的集合 就krusal 如果是 graph prim。</p>
</li>
</ol>
<h1 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h1><ol>
<li>dijkstra 算法： 优先级队列里存放边   因为这样可以通过边的权重来知晓</li>
</ol>
<h1 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a>Day 14</h1><ol>
<li><p>前缀树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//力扣667</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TrieNode *&gt; next;</span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="number">26</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            next[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode * root;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MapSum</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> delta = val;</span><br><span class="line">        <span class="comment">//如果之前存在 算出两数值差好做修改</span></span><br><span class="line">        <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            delta -= cnt[key];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[key] = val;</span><br><span class="line">        </span><br><span class="line">        TrieNode * node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            node-&gt;val += delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode * node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>真不能上来直接写，一定要先想好各种情况。</p>
</li>
</ol>
<h1 id="Day-15"><a href="#Day-15" class="headerlink" title="Day 15"></a>Day 15</h1><ol>
<li><p>优先级队列设置升序降序，less代表降序 ，greater代表升序</p>
</li>
<li><p>单调栈，要把它想象成，个子高挡住个子矮的。从一个方向上望过去，是单调递增做递减的。</p>
</li>
<li><p>单调栈不一定存放数值，也可以存放索引，反正可以通过索引来找值。</p>
</li>
<li><p>for循环一定要检查是i++ 还是 i—</p>
</li>
<li><p>单调栈 找比自己大的  那栈顶就是栈里最小的。好好理解一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//力扣503</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到第一个大于自己的元素 </span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>()&lt;=nums[i%n]) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//没找到  那自己就是最大的</span></span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) result[i%n] = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//找到了保存结果 </span></span><br><span class="line">            <span class="keyword">else</span> result[i%n] = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">//把自己放进去</span></span><br><span class="line">            st.<span class="built_in">push</span>( nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/11/15/8-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Epoll%E5%8A%9F%E8%83%BD%E7%9A%84%E5%B0%81%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/11/15/8-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Epoll%E5%8A%9F%E8%83%BD%E7%9A%84%E5%B0%81%E8%A3%85/" itemprop="url">C++实战——Epoll功能的封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-15T20:08:27+08:00">
                2022-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<p>简单介绍（后面去其他博客搜刮一下补充一波）</p>
<p>非阻塞同步IO所要用到的一个功能。这个项目中对这部分功能进行了很好的封装。简单介绍一下Epoll的作用。当服务器的负责监听的文件描述符发生改动，表示有连接进来。Epoll会将新的文件描述符与其对应事件加入，后面调用自身的一些方法，去监听这些连接文件描述符，有数据变动说明有数据进来，就返回这些有数据的文件描述符的列表。那么主线程通过列表中的这些文件描述符就可以拿到数据，然后分发给各个线程。</p>
<h2 id="API及其具体实现如下："><a href="#API及其具体实现如下：" class="headerlink" title="API及其具体实现如下："></a>API及其具体实现如下：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">//epoll_ctl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Epoller</span><span class="params">(<span class="type">int</span> maxEvent = <span class="number">1024</span>)</span></span>;          <span class="comment">//最大检测到的Epoll数量</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Epoller</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;             <span class="comment">//添加要检测的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;            <span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;                             <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;                   <span class="comment">//让内核去检测</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;                 <span class="comment">//获取</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epollFd_;                                     <span class="comment">//通过这个东西可以操作某个Epoller对象</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;          <span class="comment">//检测到的事件集合</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EPOLLER_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建和释放</span></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvent):<span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(<span class="number">512</span>)), <span class="built_in">events_</span>(maxEvent)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(epollFd_ &gt;= <span class="number">0</span> &amp;&amp; events_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(epollFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件描述符与事件 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的 有数据的 文件描述符  但是是根据索引获取指定的fd</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只是简单获取Events;</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/11/14/7.C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/11/14/7.C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1/" itemprop="url">C++实战——线程池设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-14T19:23:10+08:00">
                2022-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-实战——线程池设计"><a href="#C-实战——线程池设计" class="headerlink" title="C++实战——线程池设计"></a>C++实战——线程池设计</h1><p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<ol>
<li><p>首先,在线程池的私有部分 定义结构体 <code>Pool</code> 并且实例化一个共享智能指针.另外可以看到任务队列实际上，就是一个参数为返回值为<code>void</code> ,参数为空的函数的队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pool</span> </span><br><span class="line">&#123;</span><br><span class="line">    std::mutex mtx;                            <span class="comment">//互斥锁</span></span><br><span class="line">    std::condition_variable cond;              <span class="comment">//条件变量</span></span><br><span class="line">    <span class="type">bool</span> isClosed;                             <span class="comment">//是否关闭</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;   <span class="comment">//任务队列 </span></span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;Pool&gt; pool_; </span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>显式实例化构造函数定义,在这之前需要先看看 std::thread的构造方法，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制显式实例化   放置A a = 8  必须 A a = new A(8); </span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span></span><br><span class="line">    <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建8个子线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="comment">//创建线程表示不需要父线程对线程进行资源的释放</span></span><br><span class="line">        std::<span class="built_in">thread</span>([pool = pool_] &#123; ... &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述thread方法的 <code>...</code>为线程的具体要执行的命令内容。<code>.detach（）</code>代表线程不需要父线程释放资源，该方法会自动释放资源。</p>
<p>具体命令内容如下，可以看到通过互斥锁实现对 <code>pool-&gt;tasks</code>队列的互斥访问，：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">thread</span>([pool = pool_] &#123;                       </span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);  <span class="comment">//设置一个锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从任务队列中取任务</span></span><br><span class="line">        <span class="keyword">if</span>(!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//开关锁</span></span><br><span class="line">            locker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="built_in">task</span>();                        <span class="comment">//具体任务指定的代码 functional库里边的东西</span></span><br><span class="line">            locker.<span class="built_in">lock</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pool-&gt;isClosed) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);             <span class="comment">//条件变量使之阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="built_in">detach</span>();<span class="comment">//设置线程分离？表示不需要父线程对线程进行资源的释放</span></span><br></pre></td></tr></table></figure>
<p>另外上述代码中，使用条件变量在任务队列为空时讲线程阻塞，可以防止他一直不断的循环浪费资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool-&gt;cond.<span class="built_in">wait</span>(locker);</span><br></pre></td></tr></table></figure>
<p>与之相应的，向任务队列中添加任务后，通过条件变量将一个线程唤醒：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">        pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">        &#125;</span><br><span class="line">    pool_-&gt;cond.<span class="built_in">notify_one</span>();                       <span class="comment">//条件变量去唤醒一个线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>析构函数  联系上部分的线程内容，将<code>pool-&gt;isClosed</code>置为真,并且唤醒所有线程，才会让线程执行完推出并自动释放资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            pool_-&gt;isClosed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>整体上来看是一个生产者消费者模型，完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  <span class="comment">//锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span><span class="comment">//条件变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//队列</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">//线程库   c++的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义pool结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">        std::mutex mtx;                            <span class="comment">//互斥锁</span></span><br><span class="line">        std::condition_variable cond;              <span class="comment">//条件变量</span></span><br><span class="line">        <span class="type">bool</span> isClosed;                             <span class="comment">//是否关闭</span></span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;   <span class="comment">//任务队列</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;Pool&gt; pool_;                   <span class="comment">//实例化一个pool指针 而且是共享指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//显式实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span></span><br><span class="line">            <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建8个子线程</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">                std::<span class="built_in">thread</span>([pool = pool_] &#123;                       <span class="comment">//花括号内为线程的具体任务</span></span><br><span class="line">                    </span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);  <span class="comment">//设置一个锁</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="comment">//从任务队列中取任务</span></span><br><span class="line">                        <span class="keyword">if</span>(!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                            locker.<span class="built_in">unlock</span>();</span><br><span class="line">                            <span class="built_in">task</span>();                               <span class="comment">//具体任务指定的代码 functional库里边的东西</span></span><br><span class="line">                            locker.<span class="built_in">lock</span>();</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(pool-&gt;isClosed) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);             <span class="comment">//条件变量使之阻塞</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="built_in">detach</span>();<span class="comment">//设置线程分离？表示不需要父线程对线程进行资源的释放</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;  <span class="comment">//无参用默认</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">//没定义用默认</span></span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">                pool_-&gt;isClosed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">        &#125;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();                       <span class="comment">//条件变量去唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//THREADPOOL_H</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/18/30-DPDK%E2%80%94%E2%80%94%E6%97%A0%E6%89%80%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97-%E5%86%85%E5%AD%98%E6%B1%A0-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/18/30-DPDK%E2%80%94%E2%80%94%E6%97%A0%E6%89%80%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97-%E5%86%85%E5%AD%98%E6%B1%A0-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" itemprop="url">DPDK——无所环形队列+内存池 实现进程间通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-18T20:35:11+08:00">
                2022-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id><a href="#" class="headerlink" title=" "></a> </h1><h3 id="0-概括"><a href="#0-概括" class="headerlink" title="0.概括"></a>0.概括</h3><p>首先通信原理十分简单，先概括一下</p>
<p>首先创建一个内存池，内存池中是一块一块内存，大小由我们指定。作为我们传递消息的单位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">message_pool</span> =</span> rte_mempool_create(_MSG_POOL, pool_size,</span><br><span class="line">                                    STR_TOKEN_SIZE, pool_cache, priv_data_sz,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                    rte_socket_id(), flags);</span><br></pre></td></tr></table></figure>
<p>我们需要指定内存池的名称，大小，元素大小，其他的不太重要看看，就好。首先由一个进程创建好这个缓冲池之后，另一个缓冲池要查找到这个缓冲池。通过下面的方式，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">message_pool</span> <span class="title">message_pool</span> =</span> rte_mempool_lookup(_MSG_POOL);</span><br></pre></td></tr></table></figure>
<p>也就是使用共享内存的方式进行通信，但是固定了每条信息的大小。我愿称之为，结合了共享内存与消息队列。</p>
<h2 id="1-如何进行通信"><a href="#1-如何进行通信" class="headerlink" title="1.如何进行通信"></a>1.如何进行通信</h2><p>通过无所环形队列，存放消息在内存池中的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">send_ring</span> =</span> rte_ring_create(_PRI_2_SEC, ring_size, rte_socket_id(), flags);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">recv_ring</span> =</span> rte_ring_create(_SEC_2_PRI, ring_size, rte_socket_id(), flags);</span><br></pre></td></tr></table></figure>
<p>上面就是创建了两个消息唤醒队列，里面用于存放，消息在内存池中的地址。需要指定名称和大小。那么通信的另一端如何找到呢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">recv_ring</span> =</span> rte_ring_lookup(_PRI_2_SEC);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">send_ring</span> =</span> rte_ring_lookup(_SEC_2_PRI);</span><br></pre></td></tr></table></figure>
<p>可以看到也是通过名称来寻找。而且可以发现名称调换了位置。</p>
<h3 id="1-1-发送消息"><a href="#1-1-发送消息" class="headerlink" title="1.1 发送消息"></a>1.1 发送消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">rte_mempool_get(message_pool, &amp;msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过memcpy等方式将信息存放进msg</span></span><br><span class="line"></span><br><span class="line">rte_ring_enqueue(send_ring, msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先定义一个指针变量，然后去消息缓冲池中拿一块内存区域，起始地址赋给msg。然后将给msg指向的区域赋值过后。就把msg放进发送环形队列。</p>
<h3 id="1-2-接收消息"><a href="#1-2-接收消息" class="headerlink" title="1.2 接收消息"></a>1.2 接收消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *msg;</span><br><span class="line">rte_ring_dequeue(recv_ring, &amp;msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到msg  指向的内存就是消息实体    </span></span><br><span class="line">    </span><br><span class="line">rte_mempool_put(message_pool, msg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先定义一个指针变量，从接收环形队列中拿到一个指针（如果有的话），然后这个指针指向的位置就是内存中的消息实体。拿到消息做处理之后。再把这个东西放回内存池。</p>
<p>总结，其实原理感觉非常简单，主要需要注意的就是两个进程为什么可以通过字符串来找到环形队列和内存池。其实就是同一台机器运行的dpdk程序有着同一套运行时环境。这也就是为什么如果开启第二个dpdk程序时，要指定参数—proc-type secondary 的原因。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/18/29-DPDK%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85-UIO-PMD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/18/29-DPDK%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85-UIO-PMD/" itemprop="url">DPDK——如何获取数据包 UIO+PMD</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-18T19:34:15+08:00">
                2022-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>（绕蒙圈了已经）可直接跳到后面看结论.目前已经不影响项目进展，中间部分当作素材，留着以后看看能不能整理出来吧。</strong></p>
<p>这里主要是想搞清楚具体的，从网卡拿到数据包的流程是什么样的。正常来说，数据包进入网卡队列，由网卡驱动将数据包拷贝到内核缓冲区，然后进行封装，封装成sk_buffer然后就上交内核协议栈了。那么在我们的程序中，我们想要直接拿到网卡队列中的原始数据包。</p>
<h2 id="0-DPDK为我们提供的接口"><a href="#0-DPDK为我们提供的接口" class="headerlink" title="0.DPDK为我们提供的接口"></a>0.DPDK为我们提供的接口</h2><p>想要达到这样的目的很简单，因为dpdk已经为我们提供了这样的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>；</span><br></pre></td></tr></table></figure>
<p>其中，第一个参数代表我们想要从哪个网卡端口获取数据包，第二个参数代表我们想要从哪个队列获取数据包，第三个参数是存放数据包数组指针，这个结构体用于存放原始数据包，第四个参数用于限制依次读取数据包的大小。</p>
<h2 id="1-接口中重要的两步"><a href="#1-接口中重要的两步" class="headerlink" title="1.接口中重要的两步"></a>1.接口中重要的两步</h2><p>在上一部分提到的接口函数的定义中找到两句比较重要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line">nb_rx = (*dev-&gt;rx_pkt_burst)(dev-&gt;data-&gt;rx_queues[queue_id],</span><br><span class="line">				     rx_pkts, nb_pkts);</span><br></pre></td></tr></table></figure>
<p>通过<code>port_id</code>拿到我们具体想要在哪个网卡端口获取数据包。代表网卡端口设备的结构体定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> &#123;</span></span><br><span class="line">	<span class="type">eth_rx_burst_t</span> rx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD receive function. */</span></span><br><span class="line">	<span class="type">eth_tx_burst_t</span> tx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD transmit function. */</span></span><br><span class="line">	<span class="type">eth_tx_prep_t</span> tx_pkt_prepare; <span class="comment">/**&lt; Pointer to PMD transmit prepare function. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_rx_queue_count_t</span>       rx_queue_count; <span class="comment">/**&lt; Get the number of used RX descriptors. */</span></span><br><span class="line">	<span class="type">eth_rx_descriptor_done_t</span>   rx_descriptor_done;   <span class="comment">/**&lt; Check rxd DD bit. */</span></span><br><span class="line">	<span class="type">eth_rx_descriptor_status_t</span> rx_descriptor_status; <span class="comment">/**&lt; Check the status of a Rx descriptor. */</span></span><br><span class="line">	<span class="type">eth_tx_descriptor_status_t</span> tx_descriptor_status; <span class="comment">/**&lt; Check the status of a Tx descriptor. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Next two fields are per-device data but *data is shared between</span></span><br><span class="line"><span class="comment">	 * primary and secondary processes and *process_private is per-process</span></span><br><span class="line"><span class="comment">	 * private. The second one is managed by PMDs if necessary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_data</span> *<span class="title">data</span>;</span>  <span class="comment">/**&lt; Pointer to device data. */</span></span><br><span class="line">	<span class="type">void</span> *process_private; <span class="comment">/**&lt; Pointer to per-process device data. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_dev_ops</span> *<span class="title">dev_ops</span>;</span> <span class="comment">/**&lt; Functions exported by PMD */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_device</span> *<span class="title">device</span>;</span> <span class="comment">/**&lt; Backing device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_intr_handle</span> *<span class="title">intr_handle</span>;</span> <span class="comment">/**&lt; Device interrupt handle */</span></span><br><span class="line">	<span class="comment">/** User application callbacks for NIC interrupts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_cb_list</span> <span class="title">link_intr_cbs</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from rx_burst to post-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">post_rx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from tx_burst to pre-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the driver for transmission.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">pre_tx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_dev_state</span> <span class="title">state</span>;</span> <span class="comment">/**&lt; Flag indicating the port state */</span></span><br><span class="line">	<span class="type">void</span> *security_ctx; <span class="comment">/**&lt; Context for security ops */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">4</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">4</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125; __rte_cache_aligned;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个结构体与每一个以太网设备关联。可以这样理解，这就是网卡的用户态驱动程序。可以看到其中就定义了我们接收数据包所需要的<code>rx_pkt_burst</code>。也就是说，根据我们实际使用的网卡型号，我们在初始化网络设备的时候，会对这个数据结构进行相应的赋值。以实现对应网卡的对应功能。这个在运行dpdk程序之前需要我们去绑定用户态驱动。这个不用多说，绑定之后由dpdk去为我们检测。比如在程序中我们调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_count_avail</span><span class="params">()</span> <span class="comment">//就可以查看当前绑定了用户态驱动的网卡设备数量。</span></span><br><span class="line"><span class="title function_">rte_eth_macaddr_get</span><span class="params">((<span class="type">uint8_t</span>) m_Id, &amp;etherAddr)</span>; <span class="comment">//获取mac地址</span></span><br><span class="line">rte_eth_dev_get_mtu((<span class="type">uint8_t</span>) m_Id, &amp;m_DeviceMtu);<span class="comment">//获取最大帧长</span></span><br></pre></td></tr></table></figure>
<p>等等等等。这些信息都源自下面这个结构体，通过下面的结构体存放这绑定了用户态驱动的网卡端口任何信息，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_device</span> *<span class="title">device</span>;</span> <span class="comment">/** Generic device information */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *driver_name; <span class="comment">/**&lt; Device Driver name. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> if_index; <span class="comment">/**&lt; Index to bound host interface, or 0 if none.</span></span><br><span class="line"><span class="comment">		Use if_indextoname() to translate into an interface name. */</span></span><br><span class="line">	<span class="type">uint16_t</span> min_mtu;	<span class="comment">/**&lt; Minimum MTU allowed */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_mtu;	<span class="comment">/**&lt; Maximum MTU allowed */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">uint32_t</span> *dev_flags; <span class="comment">/**&lt; Device flags */</span></span><br><span class="line">	<span class="type">uint32_t</span> min_rx_bufsize; <span class="comment">/**&lt; Minimum size of RX buffer. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_rx_pktlen; <span class="comment">/**&lt; Maximum configurable length of RX pkt. */</span></span><br><span class="line">	<span class="comment">/** Maximum configurable size of LRO aggregated packet. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_lro_pkt_size;</span><br><span class="line">	<span class="type">uint16_t</span> max_rx_queues; <span class="comment">/**&lt; Maximum number of RX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_tx_queues; <span class="comment">/**&lt; Maximum number of TX queues. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_mac_addrs; <span class="comment">/**&lt; Maximum number of MAC addresses. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_hash_mac_addrs;</span><br><span class="line">	<span class="comment">/** Maximum number of hash MAC addresses for MTA and UTA. */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_vfs; <span class="comment">/**&lt; Maximum number of VFs. */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_vmdq_pools; <span class="comment">/**&lt; Maximum number of VMDq pools. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxseg_capa</span> <span class="title">rx_seg_capa</span>;</span> <span class="comment">/**&lt; Segmentation capability.*/</span></span><br><span class="line">	<span class="type">uint64_t</span> rx_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; All RX offload capabilities including all per-queue ones */</span></span><br><span class="line">	<span class="type">uint64_t</span> tx_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; All TX offload capabilities including all per-queue ones */</span></span><br><span class="line">	<span class="type">uint64_t</span> rx_queue_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; Device per-queue RX offload capabilities. */</span></span><br><span class="line">	<span class="type">uint64_t</span> tx_queue_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; Device per-queue TX offload capabilities. */</span></span><br><span class="line">	<span class="type">uint16_t</span> reta_size;</span><br><span class="line">	<span class="comment">/**&lt; Device redirection table size, the total number of entries. */</span></span><br><span class="line">	<span class="type">uint8_t</span> hash_key_size; <span class="comment">/**&lt; Hash key size in bytes */</span></span><br><span class="line">	<span class="comment">/** Bit mask of RSS offloads, the bit offset also means flow type */</span></span><br><span class="line">	<span class="type">uint64_t</span> flow_type_rss_offloads;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxconf</span> <span class="title">default_rxconf</span>;</span> <span class="comment">/**&lt; Default RX configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">default_txconf</span>;</span> <span class="comment">/**&lt; Default TX configuration */</span></span><br><span class="line">	<span class="type">uint16_t</span> vmdq_queue_base; <span class="comment">/**&lt; First queue ID for VMDQ pools. */</span></span><br><span class="line">	<span class="type">uint16_t</span> vmdq_queue_num;  <span class="comment">/**&lt; Queue number for VMDQ pools. */</span></span><br><span class="line">	<span class="type">uint16_t</span> vmdq_pool_base;  <span class="comment">/**&lt; First ID of VMDQ pools. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_desc_lim</span> <span class="title">rx_desc_lim</span>;</span>  <span class="comment">/**&lt; RX descriptors limits */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_desc_lim</span> <span class="title">tx_desc_lim</span>;</span>  <span class="comment">/**&lt; TX descriptors limits */</span></span><br><span class="line">	<span class="type">uint32_t</span> speed_capa;  <span class="comment">/**&lt; Supported speeds bitmap (ETH_LINK_SPEED_). */</span></span><br><span class="line">	<span class="comment">/** Configured number of rx/tx queues */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_rx_queues; <span class="comment">/**&lt; Number of RX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_tx_queues; <span class="comment">/**&lt; Number of TX queues. */</span></span><br><span class="line">	<span class="comment">/** Rx parameter recommendations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_portconf</span> <span class="title">default_rxportconf</span>;</span></span><br><span class="line">	<span class="comment">/** Tx parameter recommendations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_portconf</span> <span class="title">default_txportconf</span>;</span></span><br><span class="line">	<span class="comment">/** Generic device capabilities (RTE_ETH_DEV_CAPA_). */</span></span><br><span class="line">	<span class="type">uint64_t</span> dev_capa;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Switching information for ports on a device with a</span></span><br><span class="line"><span class="comment">	 * embedded managed interconnect/switch.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_switch_info</span> <span class="title">switch_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">2</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">2</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应用程序中往往执行下面的两行代码就可以拿到，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rte_eth_dev_info portInfo;</span><br><span class="line">rte_eth_dev_info_get(Id, &amp;portInfo);</span><br></pre></td></tr></table></figure>
<p>id一般从0开始，如果系统中有两个网卡绑定了用户态驱动，那么通过0，1就可以获取这两张网卡设备的信息。</p>
<p>查了一下自己用的<code>igb_uio</code>驱动的源码，比较重要的映射功能实现主要是下面的probe函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">igbuio_pci_probe(<span class="keyword">struct</span> pci_dev *dev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_uio_pci_dev</span> *<span class="title">udev</span>;</span></span><br><span class="line">	<span class="type">dma_addr_t</span> map_dma_addr;</span><br><span class="line">	<span class="type">void</span> *map_addr;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PCI_IS_BRIDGE_API</span></span><br><span class="line">	<span class="keyword">if</span> (pci_is_bridge(dev)) &#123;</span><br><span class="line">		dev_warn(&amp;dev-&gt;dev, <span class="string">&quot;Ignoring PCI bridge device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	udev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_uio_pci_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!udev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * enable device: ask low-level code to enable I/O and</span></span><br><span class="line"><span class="comment">	 * memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = pci_enable_device(dev);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev, <span class="string">&quot;Cannot enable PCI device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* enable bus mastering on the device */</span></span><br><span class="line">	pci_set_master(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remap IO memory */</span></span><br><span class="line">	err = igbuio_setup_bars(dev, &amp;udev-&gt;info);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set 64-bit DMA mask */</span></span><br><span class="line">	err = pci_set_dma_mask(dev,  DMA_BIT_MASK(<span class="number">64</span>));</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev, <span class="string">&quot;Cannot set DMA mask\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(<span class="number">64</span>));</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev, <span class="string">&quot;Cannot set consistent DMA mask\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill uio infos */</span></span><br><span class="line">	udev-&gt;info.name = <span class="string">&quot;igb_uio&quot;</span>;</span><br><span class="line">	udev-&gt;info.version = <span class="string">&quot;0.1&quot;</span>;</span><br><span class="line">	udev-&gt;info.irqcontrol = igbuio_pci_irqcontrol;</span><br><span class="line">	udev-&gt;info.open = igbuio_pci_open;</span><br><span class="line">	udev-&gt;info.release = igbuio_pci_release;</span><br><span class="line">	udev-&gt;info.priv = udev;</span><br><span class="line">	udev-&gt;pdev = dev;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;udev-&gt;refcnt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	err = sysfs_create_group(&amp;dev-&gt;dev.kobj, &amp;dev_attr_grp);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register uio driver */</span></span><br><span class="line">	err = uio_register_device(&amp;dev-&gt;dev, &amp;udev-&gt;info);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_remove_group;</span><br><span class="line"></span><br><span class="line">	pci_set_drvdata(dev, udev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Doing a harmless dma mapping for attaching the device to</span></span><br><span class="line"><span class="comment">	 * the iommu identity mapping if kernel boots with iommu=pt.</span></span><br><span class="line"><span class="comment">	 * Note this is not a problem if no IOMMU at all.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	map_addr = dma_alloc_coherent(&amp;dev-&gt;dev, <span class="number">1024</span>, &amp;map_dma_addr,</span><br><span class="line">			GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (map_addr)</span><br><span class="line">		<span class="built_in">memset</span>(map_addr, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!map_addr)</span><br><span class="line">		dev_info(&amp;dev-&gt;dev, <span class="string">&quot;dma mapping failed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dev_info(&amp;dev-&gt;dev, <span class="string">&quot;mapping 1K dma=%#llx host=%p\n&quot;</span>,</span><br><span class="line">			 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)map_dma_addr, map_addr);</span><br><span class="line"></span><br><span class="line">		dma_free_coherent(&amp;dev-&gt;dev, <span class="number">1024</span>, map_addr, map_dma_addr);</span><br><span class="line">		dev_info(&amp;dev-&gt;dev, <span class="string">&quot;unmapping 1K dma=%#llx host=%p\n&quot;</span>,</span><br><span class="line">			 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)map_dma_addr, map_addr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_remove_group:</span><br><span class="line">	sysfs_remove_group(&amp;dev-&gt;dev.kobj, &amp;dev_attr_grp);</span><br><span class="line">fail_release_iomem:</span><br><span class="line">	igbuio_pci_release_iomem(&amp;udev-&gt;info);</span><br><span class="line">	pci_disable_device(dev);</span><br><span class="line">fail_free:</span><br><span class="line">	kfree(udev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = igbuio_setup_bars(dev, &amp;udev-&gt;info);</span><br></pre></td></tr></table></figure>
<p>函数的作用是读取当前设备的所有<code>PCI BAR</code>的信息，并存储到uio_info结构体中。<code>PCI BAR</code>是一种存储基地址的寄存器，它可以指示设备内部的内存或<code>I/O</code>端口的位置和大小。这些信息在后续注册<code>UIO</code>设备时需要使用，以便用户程序可以通过<code>mmap</code>函数映射<code>/dev/uioX</code>文件到用户空间的虚拟地址，并根据偏移量访问不同的<code>PCI BAR</code>区域。</p>
<p>看到下面这两个指针的定义就觉得不简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dma_addr_t</span> map_dma_addr;</span><br><span class="line"><span class="type">void</span> *map_addr;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//之后</span></span><br><span class="line">map_addr = dma_alloc_coherent(&amp;dev-&gt;dev, <span class="number">1024</span>, &amp;map_dma_addr,GFP_KERNEL);</span><br></pre></td></tr></table></figure>
<p><code>dma_alloc_coherent</code>是一个用于分配一致性<code>DMA</code>内存的函数。一致性<code>DMA</code>内存是指可以被设备和<code>CPU</code>同时访问而不需要考虑缓存效应的内存。</p>
<p><code>dma_alloc_coherent</code>函数接受四个参数：第一个参数<code>dev</code>是一个<code>struct device</code>指针，用于指定要执行<code>DMA</code>的设备；第二个参数<code>size</code>是要分配的内存大小；第三个参数是一个<code>dma_addr_t</code>指针，用于返回分配的内存的<code>DMA</code>地址；<code>flag</code>是一个<code>gfp_t</code>类型，用于指定分配内存时的标志位，如<code>GFP_KERNEL</code>等。</p>
<p><code>dma_alloc_coherent</code>函数返回两个值：用于CPU访问的虚拟地址<code>cpu_addr</code>和用于设备访问的<code>DMA</code>地址<code>dma_addr_t</code>。这两个地址可能不相同，因为可能存在物理地址和总线地址之间的转换。因此，在CPU端要使用<code>cpu_addr</code>来操作分配的内存，在设备端要使用<code>dma_addr_t</code>来作为<code>DMA</code>源或目标地址</p>
<p>经历这步之后，打印信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dev_info(&amp;dev-&gt;dev, <span class="string">&quot;mapping 1K dma=%#llx host=%p\n&quot;</span>,</span><br><span class="line">			 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)map_dma_addr, map_addr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>合理推测（不一定对哈），到时候数据包从网卡队列里头拿出来应该就是拿到这里面。</p>
<p>可以将PCI设备的内存空间映射到用户空间，并提供中断处理功能。而PMD驱动程序由具体的网卡驱动程序支持。</p>
<p>那直接总结好了：</p>
<p>首先运行dpdk程序会要求我们将网卡绑定UIO驱动。我绑定的是<code>igb_uio</code></p>
<p>UIO驱动是一种用户空间驱动，它可以让用户空间的程序直接访问和控制某些类型的设备，而不需要编写复杂的内核模块。UIO驱动的优点是简化了驱动程序的开发和维护，降低了内核崩溃的风险，提高了驱动程序的更新效率。UIO驱动适用于那些具有可映射的内存空间，可以通过内存写入来控制，通常会产生中断，并且不属于标准内核子系统范畴的设备。</p>
<p>UIO驱动的工作原理是通过一个字符设备文件和一些sysfs属性文件来访问和管理设备。字符设备文件通常命名为/dev/uio0, /dev/uio1等等。用户空间的程序可以通过mmap()函数将设备文件映射到自己的地址空间，并通过读写该地址空间来访问和控制设备的寄存器或RAM位置。用户空间的程序还可以通过read()或select()函数来等待和处理设备产生的中断。sysfs属性文件则提供了一些关于设备名称、版本、映射大小、中断号等信息。</p>
<p>（Poll Mode Drivers）网卡驱动。该驱动由用户态的 API 以及 PMD Driver 构成，内核态的 UIO Driver 屏蔽了网卡发出的中断信号，然后由用户态的 PMD Driver 采用主动轮询的方式。除了链路状态通知仍必须采用中断方式以外，均使用无中断方式直接操作网卡设备的接收和发送队列。</p>
<p>PMD Driver 从网卡上接收到数据包后，会直接通过 DMA 方式传输到预分配的内存中，同时更新无锁环形队列中的数据包指针，不断轮询的应用程序很快就能感知收到数据包，并在预分配的内存地址上直接处理数据包，这个过程非常简洁。</p>
<p>PMD 极大提升了网卡 I/O 性能。此外，PMD 还同时支持物理和虚拟两种网络接口，支持 Intel、Cisco、Broadcom、Mellanox、Chelsio 等整个行业生态系统的网卡设备，以及支持基于 KVM、VMware、 Xen 等虚拟化网络接口。PMD 实现了 Intel 1GbE、10GbE 和 40GbE 网卡下基于轮询收发包。</p>
<p>UIO+PMD，前者零拷贝，后者主动轮询避免了硬中断，DPDK 从而可以在用户态进行收发包的处理。带来了零拷贝（Zero Copy）、无系统调用（System call）的优化。同时，还避免了软中断的异步处理，也减少了上下文切换带来的 Cache Miss。</p>
<p>igb_uio是一种PCI驱动，它可以将网卡设备绑定到用户态，并绕开内核的网络栈。它的主要工作流程如下：</p>
<ul>
<li>igb_uio模块初始化时，向内核注册一个pci_driver结构体，但不指定任何设备id。</li>
<li>用户通过dpdk-devbind.py脚本将某个网卡设备绑定到igb_uio驱动，触发probe回调函数。</li>
<li>probe回调函数中，首先使能当前设备，并设置DMA模式。</li>
<li>然后调用igbuio_setup_bars函数，读取当前设备的所有PCI BAR的信息，并存储到uio_info结构体中。PCI BAR是一种存储基地址的寄存器，它可以指示设备内部的内存或I/O端口的位置和大小。</li>
<li>接着初始化UIO设备的文件操作函数，如open、release、irqcontrol等。</li>
<li>最后调用uio_register_device函数，将当前设备注册为UIO设备，并在sysfs文件系统下创建/dev/uioX文件接口。</li>
<li>用户程序可以通过mmap函数，映射/dev/uioX文件到用户空间的虚拟地址，并根据偏移量访问不同的PCI BAR区域。这样就可以直接与网卡设备进行通信了。</li>
</ul>
<p>DPDK是一种数据平面开发工具包，它可以实现绕过内核的功能，提高网络I/O性能。DPDK的主要方法是：</p>
<ul>
<li>使用UIO或VFIO等机制，将网卡设备从内核驱动转移到用户态驱动，这样可以避免中断和系统调用的开销，直接访问网卡寄存器和描述符<a target="_blank" rel="noopener" href="https://www.dpdk.org/blog/2020/12/10/dpdk-welcomes-microsoft/">1</a><a target="_blank" rel="noopener" href="https://github.com/demikernel/demikernel">2</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jungle1996/p/12398915.html">3</a>。</li>
<li>使用大页内存和物理连续的内存池，分配和管理数据包缓冲区，这样可以减少TLB的开销，提高缓存命中率，降低延迟<a target="_blank" rel="noopener" href="https://pcapplusplus.github.io/docs/dpdk">4</a><a target="_blank" rel="noopener" href="https://github.com/gamemann/The-DPDK-Examples">5</a>。</li>
<li>使用轮询模式的驱动，不依赖于中断，而是主动检查网卡的状态，并处理数据包<a target="_blank" rel="noopener" href="https://www.dpdk.org/blog/2020/12/10/dpdk-welcomes-microsoft/">3</a><a target="_blank" rel="noopener" href="https://github.com/demikernel/demikernel"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jungle1996/p/12398915.html"></a>。</li>
</ul>
<p>通过这些方法，DPDK可以实现不在内核的高性能网络I/O。</p>
<p><strong>结论！！！！</strong></p>
<p>网卡设备绑定igb_uio之后会将自己的硬件内部的内存空间 保存在sysfs的目录下，用户可以将这部分空间映射到用户空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>；</span><br></pre></td></tr></table></figure>
<p>所以说这个接口底层逻辑就是通过<code>PMD</code>直接从网卡的硬件获取数据包保存在<code>rte_mbuf</code>中</p>
<p>至于PMD的好处！</p>
<p>PMD可以直接把网卡上的数据包存放到用户空间，是因为它使用了一些特殊的机制，如：</p>
<ul>
<li>UIO或VFIO等机制，可以将网卡设备从内核驱动转移到用户态驱动，这样可以避免中断和系统调用的开销，直接访问网卡寄存器和描述符<a target="_blank" rel="noopener" href="https://www.pmd.com/"></a></li>
<li>大页内存和物理连续的内存池，可以分配和管理数据包缓冲区，这样可以减少TLB的开销，提高缓存命中率，降低延迟。</li>
</ul>
<p>通过这些机制，PMD可以实现不经过内核的高效数据传输。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
        
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/17/28-DPDK%E2%80%94%E2%80%94cpu%E4%BA%B2%E5%92%8C%E6%80%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/17/28-DPDK%E2%80%94%E2%80%94cpu%E4%BA%B2%E5%92%8C%E6%80%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url">DPDK——cpu亲和性线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-17T20:53:53+08:00">
                2022-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-为什么要有cpu亲和性"><a href="#0-为什么要有cpu亲和性" class="headerlink" title="0.为什么要有cpu亲和性"></a>0.为什么要有cpu亲和性</h2><p>在多核运行的机器上，每个CPU本身自己会有缓存，在缓存中存着进程使用的数据，而没有绑定CPU的话，进程可能会被操作系统调度到其他CPU上，如此CPU cache（高速缓冲存储器）命中率就低了，也就是说调到的CPU缓存区中原来没有这类数据，要先把内存或硬盘的数据载入缓存。而当缓存区绑定CPU后，程序就会一直在指定的CPU执行，不会被操作系统调度到其他CPU，性能上会有一定的提高。</p>
<p>为了让程序拥有更好的性能，有时候需要将进程或线程绑定到特定的CPU上，这样可以减少调度的开销和保护关键进程或线程。</p>
<h2 id="1-重要的结构体"><a href="#1-重要的结构体" class="headerlink" title="1.重要的结构体"></a>1.重要的结构体</h2><h3 id="1-1-逻辑核心"><a href="#1-1-逻辑核心" class="headerlink" title="1.1 逻辑核心"></a>1.1 逻辑核心</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure storing internal configuration (per-lcore)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcore_config</span> &#123;</span></span><br><span class="line">	<span class="type">pthread_t</span> thread_id;       <span class="comment">/**&lt; pthread identifier */</span></span><br><span class="line">	<span class="type">int</span> pipe_main2worker[<span class="number">2</span>];   <span class="comment">/**&lt; communication pipe with main */</span></span><br><span class="line">	<span class="type">int</span> pipe_worker2main[<span class="number">2</span>];   <span class="comment">/**&lt; communication pipe with main */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">lcore_function_t</span> * <span class="keyword">volatile</span> f; <span class="comment">/**&lt; function to call */</span></span><br><span class="line">	<span class="type">void</span> * <span class="keyword">volatile</span> arg;       <span class="comment">/**&lt; argument of function */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> ret;          <span class="comment">/**&lt; return value of function */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">enum</span> <span class="title">rte_lcore_state_t</span> <span class="title">state</span>;</span> <span class="comment">/**&lt; lcore state */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> socket_id;    <span class="comment">/**&lt; physical socket id for this lcore */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> core_id;      <span class="comment">/**&lt; core number on socket for this lcore */</span></span><br><span class="line">	<span class="type">int</span> core_index;            <span class="comment">/**&lt; relative index, starting from 0 */</span></span><br><span class="line">	<span class="type">uint8_t</span> core_role;         <span class="comment">/**&lt; role of core eg: OFF, RTE, SERVICE */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">rte_cpuset_t</span> cpuset;       <span class="comment">/**&lt; cpu set which the lcore affinity to */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcore_config</span> <span class="title">lcore_config</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br></pre></td></tr></table></figure>
<p>该结构体在下称之为 逻辑核心描述符 用于描述dpdk线程池中的某一个线程。这里面其实就是一个线程任务描述符，（此线程描述符非彼线程描述符）把他抽象成一个核心而已。</p>
<ul>
<li>线程id </li>
<li>与主线程通信的两个管道</li>
<li>该逻辑核心要完成的工作（函数指针，参数，返回值）</li>
<li>当前逻辑核心状态</li>
<li>socket_id core_id 和numa架构有关暂且不管</li>
<li>然后是索引 </li>
<li>然后是状态  是否被dpdk标记使用，是否正在被使用</li>
<li>该逻辑核心与那个cpu集亲和。  比如亲和的是物理编号为（0，1）的cpu那么这个线程就只会被这两个核心去调度运行。我们的程序不做特殊说明，默认的情况下，一个线程与核心是1：1.</li>
</ul>
<h3 id="1-2-运行时环境设置（Run-time-evironment）"><a href="#1-2-运行时环境设置（Run-time-evironment）" class="headerlink" title="1.2 运行时环境设置（Run-time evironment）"></a>1.2 运行时环境设置（Run-time evironment）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global RTE configuration structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> main_lcore;         <span class="comment">/**&lt; Id of the main lcore */</span></span><br><span class="line">	<span class="type">uint32_t</span> lcore_count;        <span class="comment">/**&lt; Number of available logical cores. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_node_count;    <span class="comment">/**&lt; Number of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_nodes[RTE_MAX_NUMA_NODES]; <span class="comment">/**&lt; List of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> service_lcore_count;<span class="comment">/**&lt; Number of available service cores. */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_lcore_role_t</span> <span class="title">lcore_role</span>[<span class="title">RTE_MAX_LCORE</span>];</span> <span class="comment">/**&lt; State of cores. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Primary or secondary configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_proc_type_t</span> <span class="title">process_type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** PA or VA mapping mode */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">iova_mode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Pointer to memory configuration, which may be shared across multiple</span></span><br><span class="line"><span class="comment">	 * DPDK instances</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mem_config</span>;</span></span><br><span class="line">&#125; __rte_packed;</span><br></pre></td></tr></table></figure>
<p>挑重点的说了，</p>
<ul>
<li><p>主线程号</p>
</li>
<li><p>逻辑线程数量</p>
</li>
<li>每个逻辑线程目前的角色（状态）</li>
<li>进程的类型（同一台机器只能运行一个dpdk主进程，其他的需要加上从进程参数）</li>
</ul>
<h2 id="2-线程池的创建和初始化"><a href="#2-线程池的创建和初始化" class="headerlink" title="2.线程池的创建和初始化"></a>2.线程池的创建和初始化</h2><p>线程池的创建和初始化工作均在环境抽象层初始化的时候完成，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = rte_eal_init(initDpdkArgc, (<span class="type">char</span>**)initDpdkArgvBuffer);</span><br></pre></td></tr></table></figure>
<p>其中我们比较关心的参数是，核心数。在我们的代码中我们默认0号核分配给主线程。</p>
<p>首先我们在dpdk环境抽象层的配置中可以找到关于最大核心数的宏定义,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MAX_LCORE 128</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-首先对操作系统的处理器核心做初始化"><a href="#2-1-首先对操作系统的处理器核心做初始化" class="headerlink" title="2.1 首先对操作系统的处理器核心做初始化"></a>2.1 首先对操作系统的处理器核心做初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eal_create_cpu_map() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rte_eal_init_alert(<span class="string">&quot;Cannot discover CPU and NUMA.&quot;</span>);</span><br><span class="line">    <span class="comment">/* rte_errno is set */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_eal_cpu_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rte_eal_init_alert(<span class="string">&quot;Cannot detect lcores.&quot;</span>);</span><br><span class="line">    rte_errno = ENOTSUP;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要涉及到两个主要的函数，<code>eal_create_cpu_map()</code>和<code>rte_eal_cpu_init()</code>。前者没细看，大概就是为后者提供一个物理cpu核心的逻辑标识。后者的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_cpu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* pointer to global configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> *<span class="title">config</span> =</span> rte_eal_get_configuration();</span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line">	<span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> socket_id, prev_socket_id;</span><br><span class="line">	<span class="type">int</span> lcore_to_socket_id[RTE_MAX_LCORE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Parse the maximum set of logical cores, detect the subset of running</span></span><br><span class="line"><span class="comment">	 * ones and enable them by default.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">		lcore_config[lcore_id].core_index = count;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* init cpuset for per lcore config */</span></span><br><span class="line">		CPU_ZERO(&amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find socket first */</span></span><br><span class="line">		socket_id = eal_cpu_socket_id(lcore_id);</span><br><span class="line">		lcore_to_socket_id[lcore_id] = socket_id;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (eal_cpu_detected(lcore_id) == <span class="number">0</span>) &#123;</span><br><span class="line">			config-&gt;lcore_role[lcore_id] = ROLE_OFF;</span><br><span class="line">			lcore_config[lcore_id].core_index = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, lcore 1:1 map to cpu id */</span></span><br><span class="line">		CPU_SET(lcore_id, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, each detected core is enabled */</span></span><br><span class="line">		config-&gt;lcore_role[lcore_id] = ROLE_RTE;</span><br><span class="line">		lcore_config[lcore_id].core_role = ROLE_RTE;</span><br><span class="line">		lcore_config[lcore_id].core_id = eal_cpu_core_id(lcore_id);</span><br><span class="line">		lcore_config[lcore_id].socket_id = socket_id;</span><br><span class="line">		RTE_LOG(DEBUG, EAL, <span class="string">&quot;Detected lcore %u as &quot;</span></span><br><span class="line">				<span class="string">&quot;core %u on socket %u\n&quot;</span>,</span><br><span class="line">				lcore_id, lcore_config[lcore_id].core_id,</span><br><span class="line">				lcore_config[lcore_id].socket_id);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; lcore_id &lt; CPU_SETSIZE; lcore_id++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (eal_cpu_detected(lcore_id) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		RTE_LOG(DEBUG, EAL, <span class="string">&quot;Skipped lcore %u as core %u on socket %u\n&quot;</span>,</span><br><span class="line">			lcore_id, eal_cpu_core_id(lcore_id),</span><br><span class="line">			eal_cpu_socket_id(lcore_id));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the count of enabled logical cores of the EAL configuration */</span></span><br><span class="line">	config-&gt;lcore_count = count;</span><br><span class="line">	RTE_LOG(DEBUG, EAL,</span><br><span class="line">		<span class="string">&quot;Support maximum %u logical core(s) by configuration.\n&quot;</span>,</span><br><span class="line">		RTE_MAX_LCORE);</span><br><span class="line">	RTE_LOG(INFO, EAL, <span class="string">&quot;Detected %u lcore(s)\n&quot;</span>, config-&gt;lcore_count);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sort all socket id&#x27;s in ascending order */</span></span><br><span class="line">	qsort(lcore_to_socket_id, RTE_DIM(lcore_to_socket_id),</span><br><span class="line">			<span class="keyword">sizeof</span>(lcore_to_socket_id[<span class="number">0</span>]), socket_id_cmp);</span><br><span class="line"></span><br><span class="line">	prev_socket_id = <span class="number">-1</span>;</span><br><span class="line">	config-&gt;numa_node_count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">		socket_id = lcore_to_socket_id[lcore_id];</span><br><span class="line">		<span class="keyword">if</span> (socket_id != prev_socket_id)</span><br><span class="line">			config-&gt;numa_nodes[config-&gt;numa_node_count++] =</span><br><span class="line">					socket_id;</span><br><span class="line">		prev_socket_id = socket_id;</span><br><span class="line">	&#125;</span><br><span class="line">	RTE_LOG(INFO, EAL, <span class="string">&quot;Detected %u NUMA nodes\n&quot;</span>, config-&gt;numa_node_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到第一个for循环内，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcore_config[lcore_id].core_index = count;</span><br></pre></td></tr></table></figure>
<p><code>count</code>也是自增的，所以<code>count</code>实际上和索引号 <code>lcore_id</code>是一样的。然后会有检测，不过这个检测只是检测这个lcore_id是否超出了cpu核的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eal_cpu_detected(lcore_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    config-&gt;lcore_role[lcore_id] = ROLE_OFF;</span><br><span class="line">    lcore_config[lcore_id].core_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后继续看这个for循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init cpuset for per lcore config */</span></span><br><span class="line">CPU_ZERO(&amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ZERO(s)							\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		unsigned int _i;					\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">		for (_i = 0; _i &lt; _NUM_SETS(CPU_SETSIZE); _i++)		\</span></span><br><span class="line"><span class="meta">			(s)-&gt;_bits[_i] = 0LL;				\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br></pre></td></tr></table></figure>
<p>这个函数从定义来看的作用是，这个宏定义用于清空一个cpu集合，将其中所有的位都置为0。它的参数是一个指向<code>cpu_set_t</code>类型的指针，这个类型是一个结构体，包含一个数组<code>bits</code>，每个元素是一个64位的整数。<code>NUM_SETS(CPU_SETSIZE)</code>是一个宏函数，用于计算数组<code>bits</code>的长度，它的参数<code>CPU_SETSIZE</code>是<code>cpu</code>集合中能表示的最大cpu数目。这个宏定义使用了<code>do-while</code>循环语句，遍历数组<code>bits</code>中的每个元素，并将其赋值为0LL（表示长整型常量0）。这样就实现了清空<code>cpu</code>集合的功能。</p>
<p>最终也就是将每一个<code>lcore_config[lcore_id].cpuset</code>都初始化为0。初始化之后，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* By default, lcore 1:1 map to cpu id */</span></span><br><span class="line">CPU_SET(lcore_id, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_SET(b, s) ((s)-&gt;_bits[_WHICH_SET(b)] |= (1LL &lt;&lt; _WHICH_BIT(b)))</span></span><br></pre></td></tr></table></figure>
<p>从定义来看， <code>CPU_SET</code>这个宏定义用于将一个<code>cpu</code>集合中的某个位设置为1，表示将对应的<code>cpu</code>加入到集合中。它的参数是一个整数<code>b</code>，表示要设置的位的序号，和一个指向<code>cpu_set_t</code>类型的指针s，表示要操作的<code>cpu</code>集合。<code>WHICH_SET(b)</code>是一个宏函数，用于计算<code>b</code>所在的数组<code>bits</code>中的元素下标。<code>WHICH_BIT(b)</code>是一个宏函数，用于计算b在该元素中的位偏移量。这个宏定义使用了按位或运算符<code>(|=)</code>，将数组<code>bits</code>中相应元素的相应位设置为1，实现了将<code>cpu</code>加入到集合中的功能。</p>
<p>也就是说，将<code>&amp;lcore_config[lcore_id].cpuset</code>中的<code>lcore_id</code>位置为1了，代表用了这个cpu。但这也不是具体的线程与<code>cpu</code>核的绑定过程，可以说这只是一种口头上的绑定。</p>
<p>然后就是对 <code>lcore_config[lcore_id]</code>其他成员的一系列赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* By default, each detected core is enabled */</span></span><br><span class="line">config-&gt;lcore_role[lcore_id] = ROLE_RTE;</span><br><span class="line">lcore_config[lcore_id].core_role = ROLE_RTE;</span><br><span class="line">lcore_config[lcore_id].core_id = eal_cpu_core_id(lcore_id);</span><br><span class="line">lcore_config[lcore_id].socket_id = socket_id;</span><br><span class="line">RTE_LOG(DEBUG, EAL, <span class="string">&quot;Detected lcore %u as &quot;</span></span><br><span class="line">        <span class="string">&quot;core %u on socket %u\n&quot;</span>,</span><br><span class="line">        lcore_id, lcore_config[lcore_id].core_id,</span><br><span class="line">        lcore_config[lcore_id].socket_id);</span><br></pre></td></tr></table></figure>
<p>后面就没什么重要的了（本项目可以不那么关注）。</p>
<h3 id="2-2-线程创建与cpu核的绑定过程"><a href="#2-2-线程创建与cpu核的绑定过程" class="headerlink" title="2.2 线程创建与cpu核的绑定过程"></a>2.2 线程创建与cpu核的绑定过程</h3><p>2.1分析的主要是<code>lcore_config</code> 这个逻辑核描述符的初始化过程。 下面分析线程与cpu核的绑定过程。在环境抽象层的初始化过程中，首先绑定的就是<code>dpdk</code>主线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(<span class="type">rte_cpuset_t</span>),</span><br><span class="line">			&amp;lcore_config[config-&gt;main_lcore].cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot set affinity&quot;</span>);</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用到了<code>`pthread_setaffinity_np</code>，<code>pthread</code>库为我们提供的设置线程的cpu亲和性的接口：</p>
<p><a target="_blank" rel="noopener" href="https://www.noerror.net/blog/pthreadsetaffinitynp函数用法详解">pthread_setaffinity_np函数用法详解 (noerror.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38541212">Linux中CPU亲和性（affinity） - 知乎 (zhihu.com)</a></p>
<p>源码没怎么看懂，不过根据网上关于<code>pthread_setaffinity_np</code> 的解释。简单来说，当调用 <code>pthread_setaffinity_np</code> 时，如果线程不在 <code>cpuset</code> 指定的 CPU 集合中运行，那么调度器会将该线程从当前 <code>CPU</code> 上移除，并将其加入到 <code>cpuset</code> 中某个 <code>CPU</code> 的就绪队列中。然后，调度器会选择一个合适的时机，将该线程从就绪队列中取出，并加载到目标 <code>CPU</code> 上执行。</p>
<p>因此接下来，由主线程创建具有<code>cpu</code>亲和性的线程就是使用的<code>pthread_setaffinity_np</code>。具体流程如下</p>
<p>在 <code>rte_eal_init</code>函数中我们找到了这样一段比较重要的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">RTE_LCORE_FOREACH_WORKER(i) &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * create communication pipes between main thread</span></span><br><span class="line"><span class="comment">		 * and children</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (pipe(lcore_config[i].pipe_main2worker) &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pipe(lcore_config[i].pipe_worker2main) &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		lcore_config[i].state = WAIT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* create a thread for each lcore */</span></span><br><span class="line">		ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>,</span><br><span class="line">				     eal_thread_loop, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Set thread_name for aid in debugging. */</span></span><br><span class="line">		<span class="built_in">snprintf</span>(thread_name, <span class="keyword">sizeof</span>(thread_name),</span><br><span class="line">			<span class="string">&quot;lcore-worker-%d&quot;</span>, i);</span><br><span class="line">		ret = rte_thread_setname(lcore_config[i].thread_id,</span><br><span class="line">						thread_name);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			RTE_LOG(DEBUG, EAL,</span><br><span class="line">				<span class="string">&quot;Cannot set name for lcore thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ret = pthread_setaffinity_np(lcore_config[i].thread_id,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="type">rte_cpuset_t</span>), &amp;lcore_config[i].cpuset);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot set affinity\n&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>RTE_LCORE_FOREACH_WORKER(i)</code>的定义是</p>
<p>也就是找到所有供dpdk使用的逻辑线程。且不为主线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_LCORE_FOREACH_WORKER(i)					\</span></span><br><span class="line"><span class="meta">	for (i = rte_get_next_lcore(-1, 1, 0);				\</span></span><br><span class="line"><span class="meta">	     i &lt; RTE_MAX_LCORE;						\</span></span><br><span class="line"><span class="meta">	     i = rte_get_next_lcore(i, 1, 0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==》</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rte_get_next_lcore</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">int</span> skip_main, <span class="type">int</span> wrap)</span></span><br><span class="line">&#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">if</span> (wrap)</span><br><span class="line">		i %= RTE_MAX_LCORE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; RTE_MAX_LCORE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!rte_lcore_is_enabled(i) ||</span><br><span class="line">		    (skip_main &amp;&amp; (i == rte_get_main_lcore()))) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (wrap)</span><br><span class="line">				i %= RTE_MAX_LCORE;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==》</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_lcore_is_enabled</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> lcore_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> *<span class="title">cfg</span> =</span> rte_eal_get_configuration();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lcore_id &gt;= RTE_MAX_LCORE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> cfg-&gt;lcore_role[lcore_id] == ROLE_RTE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完for循环的是什么东西，再看看for循环里面的内容。首先创建两个通道，用来实现主线程和工作线程的通信。也就是说每个工作线程和主线程之间都有两个通信管道。管道创建之后，再用<code>lcore_config[i].thread_id</code>创建线程。最后线程的id号会赋给<code>lcore_config[i].thread_id</code>。也就是重点关注这两个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create a thread for each lcore */</span></span><br><span class="line">ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>,</span><br><span class="line">                     eal_thread_loop, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">ret = pthread_setaffinity_np(lcore_config[i].thread_id,</span><br><span class="line">                     <span class="keyword">sizeof</span>(<span class="type">rte_cpuset_t</span>), &amp;lcore_config[i].cpuset);</span><br></pre></td></tr></table></figure>
<p>也就是说用前者创建线程，用后者设置<code>cpu</code>亲和性。就通了。至此，总结一下环境抽象层初始化阶段对于<code>cpu</code>亲和性线程池的初始化以及绑定<code>cpu</code>工作。 首先初始化128个，逻辑核描述符，给这个描述符的<code>cpuset</code>进行初始化，后面依次分配。我们默认是一比一分配。也就是一个逻辑核对应一个<code>cpu</code>核。然后再用逻辑描述符的<code>thread_id</code>创建线程（调用<code>pthread_create</code>创建），并调用<code>pthread_setaffinity_np</code>进行线程与cpu核的绑定。绑定之后<code>task_struct</code>也就是PCB(<em>linux并不区分进程线程，所以调度都是以<code>task_struct</code>进行调度</em>)中的<code>cpus_allowed</code>只有一位会是1。</p>
<p><code>注：task_struct 中关于 CPU 集合的成员是 cpus_allowed，它是一个 cpumask_t 类型的变量，用于表示该任务可以运行在哪些 CPU 上。cpumask_t 是一个位图结构，每一位对应一个 CPU 编号，如果该位为 1，则表示该任务可以运行在该 CPU 上；如果为 0，则表示不能运行在该 CPU 上。</code></p>
<h3 id="3-线程池的工作模式"><a href="#3-线程池的工作模式" class="headerlink" title="3.线程池的工作模式"></a>3.线程池的工作模式</h3><p>之前我们创建线程池中的线程的时候，使用到的函数指针是<code>eal_thread_loop</code>，也就是我们的每个工作线程需要去处理的工作，我们看看到底是啥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main loop of threads */</span></span><br><span class="line">__rte_noreturn <span class="type">void</span> *</span><br><span class="line"><span class="title function_">eal_thread_loop</span><span class="params">(__rte_unused <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> n, ret;</span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line">	<span class="type">pthread_t</span> thread_id;</span><br><span class="line">	<span class="type">int</span> m2w, w2m;</span><br><span class="line">	<span class="type">char</span> cpuset[RTE_CPU_AFFINITY_STR_LEN];</span><br><span class="line"></span><br><span class="line">	thread_id = pthread_self();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve our lcore_id from the configuration structure */</span></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		<span class="keyword">if</span> (thread_id == lcore_config[lcore_id].thread_id)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (lcore_id == RTE_MAX_LCORE)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot retrieve lcore id\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	m2w = lcore_config[lcore_id].pipe_main2worker[<span class="number">0</span>];</span><br><span class="line">	w2m = lcore_config[lcore_id].pipe_worker2main[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	__rte_thread_init(lcore_id, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">	ret = eal_thread_dump_current_affinity(cpuset, <span class="keyword">sizeof</span>(cpuset));</span><br><span class="line">	RTE_LOG(DEBUG, EAL, <span class="string">&quot;lcore %u is ready (tid=%zx;cpuset=[%s%s])\n&quot;</span>,</span><br><span class="line">		lcore_id, (<span class="type">uintptr_t</span>)thread_id, cpuset, ret == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	rte_eal_trace_thread_lcore_ready(lcore_id, cpuset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read on our pipe to get commands */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">void</span> *fct_arg;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* wait command */</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			n = read(m2w, &amp;c, <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;cannot read on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		lcore_config[lcore_id].state = RUNNING;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* send ack */</span></span><br><span class="line">		n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (n == <span class="number">0</span> || (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR))</span><br><span class="line">			n = write(w2m, &amp;c, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;cannot write on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].f == <span class="literal">NULL</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;NULL function pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* call the function and store the return value */</span></span><br><span class="line">		fct_arg = lcore_config[lcore_id].arg;</span><br><span class="line">		ret = lcore_config[lcore_id].f(fct_arg);</span><br><span class="line">		lcore_config[lcore_id].ret = ret;</span><br><span class="line">		rte_wmb();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* when a service core returns, it should go directly to WAIT</span></span><br><span class="line"><span class="comment">		 * state, because the application will not lcore_wait() for it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].core_role == ROLE_SERVICE)</span><br><span class="line">			lcore_config[lcore_id].state = WAIT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			lcore_config[lcore_id].state = FINISHED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* never reached */</span></span><br><span class="line">	<span class="comment">/* pthread_exit(NULL); */</span></span><br><span class="line">	<span class="comment">/* return NULL; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-首先拿到自己对应的lcore-config"><a href="#3-1-首先拿到自己对应的lcore-config" class="headerlink" title="3.1 首先拿到自己对应的lcore_config"></a>3.1 首先拿到自己对应的lcore_config</h3><p>通过比对自身的<code>thread_id</code>和<code>lcore_config[lcore_id].thread_id</code>拿到对应的<code>lcore_config</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread_id = pthread_self();</span><br><span class="line"><span class="comment">/* retrieve our lcore_id from the configuration structure */</span></span><br><span class="line">RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">	<span class="keyword">if</span> (thread_id == lcore_config[lcore_id].thread_id)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-根据lcore-config做一些设置"><a href="#3-2-根据lcore-config做一些设置" class="headerlink" title="3.2 根据lcore_config做一些设置"></a>3.2 根据lcore_config做一些设置</h3><p>获取到属于自己的与主进程进行通信的管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m2w = lcore_config[lcore_id].pipe_main2worker[<span class="number">0</span>];</span><br><span class="line">w2m = lcore_config[lcore_id].pipe_worker2main[<span class="number">1</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-3-工作线程一直在做的事情"><a href="#3-3-工作线程一直在做的事情" class="headerlink" title="3.3 工作线程一直在做的事情"></a>3.3 工作线程一直在做的事情</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read on our pipe to get commands */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">void</span> *fct_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait command */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n = read(m2w, &amp;c, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        rte_panic(<span class="string">&quot;cannot read on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lcore_config[lcore_id].state = RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send ack */</span></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n == <span class="number">0</span> || (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR))</span><br><span class="line">        n = write(w2m, &amp;c, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        rte_panic(<span class="string">&quot;cannot write on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lcore_config[lcore_id].f == <span class="literal">NULL</span>)</span><br><span class="line">        rte_panic(<span class="string">&quot;NULL function pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call the function and store the return value */</span></span><br><span class="line">    fct_arg = lcore_config[lcore_id].arg;</span><br><span class="line">    ret = lcore_config[lcore_id].f(fct_arg);</span><br><span class="line">    lcore_config[lcore_id].ret = ret;</span><br><span class="line">    rte_wmb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* when a service core returns, it should go directly to WAIT</span></span><br><span class="line"><span class="comment">		 * state, because the application will not lcore_wait() for it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    <span class="keyword">if</span> (lcore_config[lcore_id].core_role == ROLE_SERVICE)</span><br><span class="line">        lcore_config[lcore_id].state = WAIT;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lcore_config[lcore_id].state = FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，一直阻塞，直到从管道内读到了主线程对自己发出的命令。状态由 <code>WAIT</code>切换为 <code>RUNNING</code>，然后发出相应表明自己收到了这个命令。一般收到命令的时候，<code>lcore_config</code> 的<code>f</code>与<code>arg</code>就已经被赋值完毕了。相当于是先得知要做的任务以及任务参数，然后在收到开始做的命令。</p>
<p>然后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* call the function and store the return value */</span></span><br><span class="line">fct_arg = lcore_config[lcore_id].arg;</span><br><span class="line">ret = lcore_config[lcore_id].f(fct_arg);</span><br><span class="line">lcore_config[lcore_id].ret = ret;</span><br></pre></td></tr></table></figure>
<p>调用这个函数，由于我们的项目function本身就自带一个死循环，只要程序执行就不会跳出，所以一旦一个线程分配了任务，就会把这个任务一直执行下去直到我们的项目程序停止。所以后面就没再看了。</p>
<h2 id="4-线程池初始化首尾"><a href="#4-线程池初始化首尾" class="headerlink" title="4. 线程池初始化首尾"></a>4. 线程池初始化首尾</h2><p>环境抽象层的初始化工作对于线程池的初始化工作进行到了最后的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> rte_eal_mp_remote_launch(sync_func, <span class="literal">NULL</span>, SKIP_MAIN);</span><br><span class="line"> rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以及这两个函数的定义</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_mp_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg,</span></span><br><span class="line"><span class="params">			 <span class="keyword">enum</span> <span class="type">rte_rmt_call_main_t</span> call_main)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lcore_id;</span><br><span class="line">	<span class="type">int</span> main_lcore = rte_get_main_lcore();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check state of lcores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].state != WAIT)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send messages to cores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		rte_eal_remote_launch(f, arg, lcore_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (call_main == CALL_MAIN) &#123;</span><br><span class="line">		lcore_config[main_lcore].ret = f(arg);</span><br><span class="line">		lcore_config[main_lcore].state = FINISHED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do a rte_eal_wait_lcore() for every lcore. The return values are</span></span><br><span class="line"><span class="comment"> * ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">rte_eal_mp_wait_lcore</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line"></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		rte_eal_wait_lcore(lcore_id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait until a lcore finished its job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_wait_lcore</span><span class="params">(<span class="type">unsigned</span> worker_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lcore_config[worker_id].state == WAIT)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (lcore_config[worker_id].state != WAIT &amp;&amp;</span><br><span class="line">	       lcore_config[worker_id].state != FINISHED)</span><br><span class="line">		rte_pause();</span><br><span class="line"></span><br><span class="line">	rte_rmb();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we are in finished state, go to wait state */</span></span><br><span class="line">	lcore_config[worker_id].state = WAIT;</span><br><span class="line">	<span class="keyword">return</span> lcore_config[worker_id].ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-如何使用线程池中的线程"><a href="#5-如何使用线程池中的线程" class="headerlink" title="5.如何使用线程池中的线程"></a>5.如何使用线程池中的线程</h2><p>也就是如何通过主线程给工作线程分配任务呢？主要是通过下面的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Send a message to a worker lcore identified by worker_id to call a</span></span><br><span class="line"><span class="comment"> * function f with argument arg. Once the execution is done, the</span></span><br><span class="line"><span class="comment"> * remote lcore switch in FINISHED state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">int</span> worker_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m2w = lcore_config[worker_id].pipe_main2worker[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> w2m = lcore_config[worker_id].pipe_worker2main[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> rc = -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lcore_config[worker_id].state != WAIT)</span><br><span class="line">		<span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">	lcore_config[worker_id].f = f;</span><br><span class="line">	lcore_config[worker_id].arg = arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send message */</span></span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n == <span class="number">0</span> || (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR))</span><br><span class="line">		n = write(m2w, &amp;c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot write on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* wait ack */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		n = read(w2m, &amp;c, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot read on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">finish:</span><br><span class="line">	rte_eal_trace_thread_remote_launch(f, arg, worker_id, rc);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，给一个<code>lcore_config</code> 分配 <code>f</code>与 <code>arg</code>，再用过队列给他下达开始执行的命令就好了。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p><code>cpu</code>亲和性线程池实现的核心就是 <code>lcore_config</code>。它关联了 线程 ，cpu，任务。首先我们先用主线程<code>id</code>初始化<code>lcore_config</code>并绑定cpu核。我们默认cpu核心与线程是一比一绑定。所以<code>lcore_config</code>的索引就是我们要使用cpu的索引。</p>
<p> 通过主线程初始化指定个数的工作线程，</p>
<ul>
<li><p>首先就是要初始化对应个数的<code>lcore_config</code>，</p>
</li>
<li><p>然后在初始化亲和的<code>cpu</code>。一般用掩码表示，比如64位哪位为1，就代表64个cpu核心我用哪一个。就像我们刚才所讲的我们默认<code>cpu</code>核心与线程是一比一绑定。所以<code>lcore_config</code>的索引就是我们要使用<code>cpu</code>的索引。设置过后</p>
</li>
<li><p>通过调用 <code>pthread_create</code>  创建线程，线程跑的是 <code>eal_thread_loop</code>。</p>
</li>
<li><p>通过调用<code>pthread_setaffinity_np</code>进行亲和性<code>cpu</code>的绑定。</p>
</li>
<li><p>通过调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">rte_eal_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">int</span> worker_id)</span></span><br></pre></td></tr></table></figure>
<p>给线程发布任务。主要就是给<code>lcore_config</code>的<code>f</code>与<code>arg</code>通过消息队列告诉他，可以执行啦，他就去执行了，</p>
</li>
<li><p><code>eal_thread_loop</code>中就是首先根据自己的进程id找到对应的<code>lcore_config</code>。拿到这个就可以通过管道得知有任务交给我了。那么这个时候<code>lcore_config</code>的<code>f</code>与<code>arg</code>往往已经赋值好了，执行就完事儿了。</p>
</li>
</ul>
<p>实际上害有更新亲和性cpu的操作，但是基本用不到所以那块儿我就没看。</p>
<p>哇！！！终于走通了！！！好耶！！！！！！！！ 单纯使用的话，其实不需要搞懂这么多。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my_avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawnlake</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
