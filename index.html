<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="也许不会有人进来吧">
<meta property="og:url" content="http://hanze5.github.io/index.html">
<meta property="og:site_name" content="也许不会有人进来吧">
<meta property="og:locale">
<meta property="article:author" content="Dawnlake">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hanze5.github.io/"/>





  <title>也许不会有人进来吧</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">也许不会有人进来吧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/04/01/32-%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/32-%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/" itemprop="url">云存储有关的一些简单概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T16:34:10+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-什么是云存储"><a href="#1-什么是云存储" class="headerlink" title="1.什么是云存储"></a>1.什么是云存储</h2><p>云存储的出现为数据存储提供了一条更加便捷的道路。于使用者而言，他们可以通过互联网技术，无视时间、地方和装置的限制，连接到“云”上方便地存取数据，从而满足用户渴望利用IT资源即时按需访问业务的需求。</p>
<p><img src="/images/32/1680266317937.png" alt="1680266317937"></p>
<p>简单来讲，个人感觉只要，存储服务是远端存储设备提供的，就都可以称作是云存储。 用户无需考虑存储节点如何部署，也无需考虑背后的数据如何在存储设备中进行组织。因为这些都是云存储服务的提供商需要去考虑的事情。用户只需要享受云提供的存储服务即可。</p>
<h2 id="2-云存储架构"><a href="#2-云存储架构" class="headerlink" title="2.云存储架构"></a>2.云存储架构</h2><p>云存储的架构这里指的是云存储设备的部署方式，分为传统的集中式存储与目前云存储主流的分布式系统。</p>
<p><img src="/images/32/1680335522811.png" alt="1680335522811"></p>
<h3 id="2-1-集中式存储"><a href="#2-1-集中式存储" class="headerlink" title="2.1 集中式存储"></a>2.1 集中式存储</h3><p>存储介质集中分布，采用双控或者多控的方式统一管理所有节点，控制器通常使用专业线缆或者网络为一台或多台服务器提供存储服务，需不断升级或更换存储设备来满足容量和性能的需求，数据可靠性与可用性依赖单个或少数存储设备。</p>
<h3 id="2-2-分布式存储"><a href="#2-2-分布式存储" class="headerlink" title="2.2 分布式存储"></a>2.2 分布式存储</h3><p>存储介质分布到不同的地理位置，节点之间相互关联共同管理维护数据，通常使用标准的网络协议和接口，可为更多的服务器或互联网主机访问。通过增加存储节点提高容量和性能。数据可靠性和可用性依赖不同节点多副本备份与故障恢复机制，故障容忍性更强。</p>
<h3 id="2-3-归纳总结"><a href="#2-3-归纳总结" class="headerlink" title="2.3 归纳总结"></a>2.3 归纳总结</h3><p>从这个表格中我们也可以看出分布式存储的优势，也就是为什么云存储现在更多的使用分布式存储的原因。</p>
<p><img src="/images/32/1680335677836.png" alt="1680335677836"></p>
<h2 id="3-云存储的服务类型"><a href="#3-云存储的服务类型" class="headerlink" title="3.云存储的服务类型"></a>3.云存储的服务类型</h2><p>云存储服务类型是从云存储给外界提供的服务形式上划分，主要分为三大类，块存储，文件存储与对象存储。</p>
<h3 id="3-1块存储"><a href="#3-1块存储" class="headerlink" title="3.1块存储"></a>3.1块存储</h3><p><strong>块存储</strong>是较为底层的存储服务<strong>。</strong>将裸磁盘空间映射给主机使用，用户需要对磁盘进行分区和格式化，然后才能读写数据，类似物理硬盘。它的特点是可以提供高速的随机读写能力，适合IO密集型的高性能、低延迟的业务场景，如数据库、虚拟机等。但是扩展能力有限，不利于数据共享，且需要专业的线缆和网络设备支持。</p>
<p><img src="/images/32/1680336179252.png" alt="1680336179252"></p>
<h3 id="3-2文件存储"><a href="#3-2文件存储" class="headerlink" title="3.2文件存储"></a>3.2文件存储</h3><p><strong>文件存储</strong>是在文件系统一层对外提供服务，主机可以直接访问文件系统中的文件和目录，无需进行分区和格式化。文件存储服务支持多个主机同时访问同一个文件系统。相当于在块存储的基础上格式化了一个文件系统给用户去使用，这样大家都是用同一套文件系统。而不是提供一块裸空间，大家根据自己的需求去分区格式化自己的系统。所以文件系统的显著的特点就是方便实现数据共享和协作，只需通过网络对外提供访问文件系统的接口即可。但是读写速度受限于网络带宽和文件系统的处理速度，不适用于海量数据的存储和传输。</p>
<p><img src="/images/32/1680336652684.png" alt="1680336652684"></p>
<h3 id="3-3对象存储"><a href="#3-3对象存储" class="headerlink" title="3.3对象存储"></a>3.3对象存储</h3><p><strong>对象存储</strong>将数据以对象的形式存储在一个扁平的地址空间中，每个对象包含了数据和元数据。访问者可以通过对象标识来获取或修改对象。它的特点具有高可扩展性和高可靠性，可以支持海量数据的存储和传输，而且不受文件系统的限制。适合用于存储海量的非结构化数据，但是不支持文件的随机读写和在线修改。比如视频网站的视频，购物网站的商品图片都是使用对象存储。对象存储的访问过程大家也都比较熟悉，通用的以太网+http协议访问。</p>
<p><img src="/images/32/1680337053266.png" alt="1680337053266"></p>
<h3 id="3-4总结比较"><a href="#3-4总结比较" class="headerlink" title="3.4总结比较"></a>3.4总结比较</h3><p><img src="/images/32/1680337135081.png" alt="1680337135081"></p>
<p>所以说三种服务类型并没有绝对的谁好谁坏 ，不管是商业的 还是开源的云存储系统，基本都会提供这三种用户可以应该针对不同的应用场景。</p>
<p>学习来源：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WE41177Kp/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=981cea5abbe570eed16fd93ab75067d7">块、文件、对象存储概述_哔哩哔哩_bilibili</a></p>
<p>b站：新爷话数据</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/03/24/31-SPDK%E2%80%94%E2%80%94NVMe%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8E%E5%AD%98%E5%82%A8%E7%A0%94%E7%A9%B6%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B8%8D%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/24/31-SPDK%E2%80%94%E2%80%94NVMe%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8E%E5%AD%98%E5%82%A8%E7%A0%94%E7%A9%B6%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B8%8D%E5%A4%A7/" itemprop="url">总线、协议与接口（与存储研究相关性不大)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-24T19:01:35+08:00">
                2023-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id><a href="#" class="headerlink" title=" "></a> </h1><h2 id="0-总线、协议、接口"><a href="#0-总线、协议、接口" class="headerlink" title="0.总线、协议、接口"></a>0.总线<strong>、</strong>协议<strong>、</strong>接口</h2><p>首先，要搞清楚<strong>总线</strong>、<strong>协议</strong>、<strong>接口</strong>这三者之间的关系。</p>
<ul>
<li><p><strong>总线</strong>（BUS）就是不同设备之间交互数据的通路，且有一定的承载能力限制(总线带宽)。</p>
</li>
<li><p><strong>协议</strong>就是两个设备之间通信的规矩。两个设备之间只有使用同样的协议才能够进行通信。和网络协议是一样的，也规定了编码方式表示方式之类的。比如我一秒钟之内的通电断电代表什么意思，想想摩斯电码类似的。但是计算机内部的通信协议肯定比较复杂而且很妙，高效的协议也需要顶尖设备支持。</p>
</li>
<li><p><strong>接口</strong></p>
<p>所以总的来说协议就是，用某种形式，以某种规格利用某种物体把数据传输出去。那么硬盘与其他设备进行沟通，就需要【数据协议】【传输总线作为媒介】【某种物理接口接入】。</p>
</li>
</ul>
<h2 id="1-常见的总写协议以及接口"><a href="#1-常见的总写协议以及接口" class="headerlink" title="1.常见的总写协议以及接口"></a>1.常见的总写协议以及接口</h2><ul>
<li><p>常见的数据协议，协议【<strong>IDE</strong>】是早期硬盘协议已被淘汰，剩下三种，民用的【<strong>AHCI</strong>】【<strong>NVMe</strong>】与服务器常用的【<strong>SCSI</strong>】</p>
</li>
<li><p>传输总线有三种民用的【<strong>SATA</strong>】【<strong>PCIe</strong>】和服务器常用的【<strong>SAS</strong>】</p>
</li>
<li><p>现在有了总线和协议，还需要物理接口讲硬盘接入到总线之上。这里面的关系就直接截视频里的图了。</p>
</li>
</ul>
<p><img src="/images/31/1679654702940.png" alt="1679654702940"></p>
<p>三者均限制数据传输的快慢。相辅相成。</p>
<p>这里只是做简单科普，与研究相关性不大。参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qv411t7ZL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=981cea5abbe570eed16fd93ab75067d7">【硬件科普】硬盘的SATA M.2 NGFF NVME是什么意思，详解硬盘的总线协议与接口_哔哩哔哩_bilibili</a></p>
<h2 id="2-NVMe协议与NVMe驱动。"><a href="#2-NVMe协议与NVMe驱动。" class="headerlink" title="2.NVMe协议与NVMe驱动。"></a>2.NVMe协议与NVMe驱动。</h2><p>NVMe设备就是支持NVMe协议的设备，通常指代的都是NVMe SSD，也就是使用PCIe接口和NVMe协议的固态硬盘。NVMe设备相比于传统的SATA或SAS设备，具有更高的速度、更低的延迟、更多的并行性和更好的可扩展性等优点 。</p>
<p>NVMe协议和NVMe驱动是两个不同的概念，但是它们都是为了提高闪存类存储的性能而设计的<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/48972075">1</a>。</p>
<p>NVMe协议是一种通信协议，它定义了如何在PCIe接口上发送和接收NVMe命令和数据。NVMe协议利用PCIe的高带宽和多队列特性，实现了高效的数据传输和并行处理<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260522647">2</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/363589126">3</a>。</p>
<p>NVMe驱动是一种软件，它实现了NVMe协议的功能，让操作系统能够识别和管理NVMe设备。NVMe驱动比传统的SATA或SAS驱动更简单和轻量，因为它直接与系统CPU通信，减少了不必要的步骤和延迟<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74239027">4</a> 。</p>
<p>简单来说，NVMe协议是一种规范，NVMe驱动是一种实现。它们都是为了让闪存类存储发挥更好的性能而设计的。</p>
<p>SO！ NVMe协议就是 SSD与系统通信的一个规则  ，NVMe驱动就是这套规则的一个实现，我们高存储的根本不需要管这个东西，好那不看了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/02/13/%E5%8A%9B%E6%89%A3%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/02/13/%E5%8A%9B%E6%89%A3%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" itemprop="url">跟着labuladong猛猛刷题（持续更新）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-02-13T09:10:30+08:00">
                2023-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day-1："><a href="#Day-1：" class="headerlink" title="Day 1："></a>Day 1：</h1><ol>
<li><p>两个栈可以实现队列，一个队列就可实现一个栈。</p>
<p>两个栈实现队列的时候，只有在出队列时 ，如果 “出栈”栈为空，需要有  入栈栈到出栈栈的转移操作。</p>
<p>一个队列实现栈时，每次入栈都需要将队列进行“翻转”（重新全部入队列，最终将队尾移动到对头）。</p>
</li>
<li><p>遇到对时间复杂度有要求的就空间换时间。</p>
</li>
<li><p><strong>INT_MAX</strong> 可用来表示正无穷，<strong>INT_MIN</strong>表示负无穷。</p>
</li>
<li><p>倒序一个链表，优先想到栈（先入后出!）</p>
</li>
<li><p>判断链表有无环，快慢双指针。  画图能够迅速帮你找到解决思路！！！！杨老师！谢谢你  画图列方程</p>
</li>
<li><p>由于链表经常要用前一个值操作后一个值，所以经常要考虑边界值。</p>
</li>
<li><p>对于深度克隆，比如随机链表复制，无向图复制，要想到哈希表。</p>
</li>
</ol>
<h1 id="Day-2："><a href="#Day-2：" class="headerlink" title="Day 2："></a>Day 2：</h1><ol>
<li><strong>链表一定要考虑边界值啊！！</strong>第2次了。链表操作A-&gt;next的时候一定要考虑A是否为空；</li>
<li><strong>非递减数列</strong>两数求和，别想那么多，先给大窗口，然后缩小，</li>
<li>双指针，快慢双指针，左右双指针（中心扩张，两边收缩）</li>
<li>如果有正负的情况，千万不要自作从聪明，将某个值设为0，不然比大小时候会出现bug。</li>
<li>如果说写出的代码分为好多种情况，那么思路一定是错了。</li>
<li>树的层序遍历需要用到队列。当需要记录层数时，需要用到额外的变量，并用到for循环</li>
<li>动态规划问题的第一个性质：<strong>重叠子问题</strong> 。 设置备忘录。一般是哈希表。数组也可以。如果可以看出数组长度不会超过某个最大值，就可以用数组。但这是个稀疏数组。</li>
</ol>
<h1 id="Day-3："><a href="#Day-3：" class="headerlink" title="Day 3："></a>Day 3：</h1><ol>
<li><p><strong>回溯代码框架</strong>，设最后返回的集合是res，res里面的元素是方案（路径）,路径中为节点，第一步我们要搞清，方案是什么，路径是什么，节点又是什么。（比如n皇后问题，方案是整个棋盘，选择是在第row行选择第col个点）所以backtrace的参数就是（棋盘，row）</p>
</li>
<li><p>回溯算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(状态参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(设置结束条件)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(路径)；</span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//排除不合法选择 </span></span><br><span class="line">        <span class="keyword">if</span>(！is_valid（)）</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        选择();</span><br><span class="line">        进入下一层</span><br><span class="line">        退选择</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p>
</li>
<li><p>组合问题，给定数组自带顺序，且答案中[1,2] [2,1]算是相同结果的，甚至可以不用is_valid;因为仔细想一下，比如选择到2，那么1 一定选过了  ，3一定没选过。（自行理解其中奥义很简单）。</p>
</li>
<li><p>求 有重复数据的子集 要先排序。然后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为和上一个相同的话， 下一个back_trace(nums,k,i+1)会得到相同的结果</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) </span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    subresult.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">back_trace</span>(nums,k,i+<span class="number">1</span>);</span><br><span class="line">    subresult.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BFS:  将问题抽象为一幅图  ，  找到节点 ，以及节点的邻居。那么算法的流程就是从初始节点开始。比如开密码锁，每个节点就是 密码锁当前的数字，那么邻居就是，转动一位得到的数字。</p>
</li>
</ol>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4 :"></a>Day 4 :</h1><ol>
<li>搞不定边界就尽量不要使用双重二分。</li>
<li><strong>检查是不是break和continue 用混了！！！！</strong></li>
<li>动态寻找最大值最小值的时候要初始化一个结果！不能只声明。</li>
<li>集合之间对比，要想到unordered_map</li>
</ol>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5:"></a>Day 5:</h1><ol>
<li>股票问题因为给的数组不是有序的，所以不能使用双指针法。</li>
<li>动态规划超出时间限制就要反思是否有重叠子问题，设置备忘录解决。</li>
<li>自顶向下的动归是递归，有可能会遇到重复子问题，自底向上的动归是迭代，但是空间复杂度高一点。</li>
<li>如果动态规划的开始和末尾相互影响。就要分出情况。</li>
<li>vector.end() 并不是最后一个元素的指针 而是最后一个元素的下一个指针</li>
<li>回溯法毕竟是穷举，拥有极高的时间复杂度。如果有其他解法尽量不要用穷举。</li>
<li>不该超出时间限制的时候超出时间限制，检查起始条件 ，终止条件，以及变化条件。</li>
</ol>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><ol>
<li>使用双指针时要确保指针移动啊。</li>
<li>差分数组要多一位（其实也没必要，得看情况）。</li>
</ol>
<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><ol>
<li>二分搜索时候左右边界问题别搞错了啊。 左边界查看left==num.size()  右边界查看left-1&lt;0;</li>
<li>二分搜索如果没找到不返回特殊值的话，左右边界还是很好写的。</li>
<li>转换思路才能二分搜索。比如给定天数，让你求运输船最小承载。这个不好算，那就转换成给出承载，返回最小天数。这就可以用二分了。这个转变思路非常巧妙。</li>
<li>无论是升序降序  左边界返回left 右边界返回left-1；</li>
</ol>
<h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><ol>
<li>vector erase和遍历数组没有区别，时间复杂度很高。易超出时间限制</li>
<li>排序的  比较函数  大于为真是降序  小于为真是升序</li>
<li>unordered_set 是不支持随机存取的。所以要用unordered_map 与 vector实现随机读取；</li>
<li>要分清出<strong>子序列</strong>与<strong>子串</strong>的区别，字串必须连续，子序列不必连续；</li>
<li>都tm什么时候了还在 犯”=” 和 “==”的错误。现在还非常容易犯小错误</li>
</ol>
<h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><ol>
<li>树的遍历中，如果遍历结果包含着空指针，那么不需要有别的遍历辅助，也能够确定一棵树。</li>
<li><strong>stoi()</strong>可以把字符串转化成为数字。  <strong>to_string</strong> 可以将数字转化为字符串</li>
<li>可以用  map用于关联字符串与节点, set用于检测字符串重复。</li>
</ol>
<h1 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h1><ol>
<li>涉及到区间和  那就一定会有前缀和数组！！  而对区间进行统一操作，那就一定会有差分数组？</li>
<li>归并排序的一个重要思想，凡是已经在同一部分里的，就一定发生过关系了。只有和另一部分的没有发生过关系。<strong>（非常重要的思想）</strong></li>
<li>而且如果无序很难，但是发现有序很好做，那么可以去想想归并排序，  或者看到题目中有 数组的性质是， 当i&lt;j  </li>
<li>前缀和 要思考 有没有</li>
<li>BST 的中序遍历结果是有序的（升序）。  可以说遇到二叉搜索树，大概率是中序遍历</li>
</ol>
<h1 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h1><ol>
<li><p>快速排序是 树的前序遍历     归并排序是树的后序遍历</p>
</li>
<li><p>快速排序为了达到稳定的快速，数组要是乱序。函数shuffle() 可以随机打乱</p>
</li>
<li><p>快速排序中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(cur&lt;=right &amp;&amp; nums[cur]&gt;=nums[p]) cur++;<span class="comment">//自己体会</span></span><br><span class="line"> <span class="comment">//而且需要特殊的交换操作</span></span><br><span class="line"><span class="built_in">swap</span>(nums[p],nums[cur]);  </span><br><span class="line"><span class="built_in">swap</span>(nums[p+<span class="number">1</span>],nums[cur])；<span class="comment">// 交换后这</span></span><br><span class="line">p+=<span class="number">1</span>;</span><br><span class="line">cur = p+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>srand(time(0)); 生成随机树种子</p>
</li>
<li><p>堆是完全二叉树 ，然后再满足父节点大于等于 或小于等于子节点。所以插入的时候，先插入满足完全二叉树的位置，在满足第二个要求。删除的时候 先交换 再下降。</p>
</li>
<li><p><strong>完全二叉树用数组实现非常方便</strong>。  节点 i 的左子节点  2i  右子节点2i+1</p>
</li>
<li><p>优先级队列定义比较函数必须是静态成员函数的？</p>
</li>
<li><p><strong>判断完全二叉树是否是满二叉树</strong>，左节点一直找下去，右节点一直找下去，看看高度是否相同。</p>
</li>
<li><p>if 后面如果不是一句话 一定不要忘了加花括号啊</p>
</li>
</ol>
<h1 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h1><ol>
<li><p>图结构表示方法，如果目的不是要迅速判断两节点之间是否有边，那还是使用邻接表方便一点。</p>
</li>
<li><p>拓扑排序 需要额外的数组记录节点的入度；</p>
</li>
<li><p>int 类型的0   1  可以用逻辑运算符操作。</p>
</li>
<li><p>连通性使用 并查集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">       		 parent[x] = <span class="built_in">find_root</span>(parent[x]);</span><br><span class="line">    	&#125;    </span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通 联通分量等于节点数</span></span><br><span class="line">        count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        <span class="comment">//尺寸全部初始化为1</span></span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find_root</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find_root</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将两棵树合并为一棵 以下二者选一即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 两个分量合二为一</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getcount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find_root</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find_root</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并查集可以建立虚拟头部，从而排除异己。</p>
</li>
<li><p>在二位坐标中控制方向常用方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125; <span class="comment">//对应下 右 上 左</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类的后面要加；</p>
</li>
<li><p>只有判断无向图是否带环时才能用并查集。</p>
</li>
<li><p>克鲁斯卡尔算法 Kruskal 算法  就是无向有权图 按权重大小一次加边；</p>
</li>
<li><p>并查集的时间复杂度是0(1);</p>
</li>
<li><p>无向有权图的最小生成树算法 prim算法需要转换成图的邻接表格式。 Kruskal 不用 ，给的如果是边的集合 就krusal 如果是 graph prim。</p>
</li>
</ol>
<h1 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h1><ol>
<li>dijkstra 算法： 优先级队列里存放边   因为这样可以通过边的权重来知晓</li>
</ol>
<h1 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a>Day 14</h1><ol>
<li><p>前缀树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//力扣667</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TrieNode *&gt; next;</span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="number">26</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            next[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode * root;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MapSum</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> delta = val;</span><br><span class="line">        <span class="comment">//如果之前存在 算出两数值差好做修改</span></span><br><span class="line">        <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            delta -= cnt[key];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[key] = val;</span><br><span class="line">        </span><br><span class="line">        TrieNode * node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            node-&gt;val += delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode * node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>真不能上来直接写，一定要先想好各种情况。</p>
</li>
</ol>
<h1 id="Day-15"><a href="#Day-15" class="headerlink" title="Day 15"></a>Day 15</h1><ol>
<li><p>优先级队列设置升序降序，less代表降序 ，greater代表升序</p>
</li>
<li><p>单调栈，要把它想象成，个子高挡住个子矮的。从一个方向上望过去，是单调递增做递减的。</p>
</li>
<li><p>单调栈不一定存放数值，也可以存放索引，反正可以通过索引来找值。</p>
</li>
<li><p>for循环一定要检查是i++ 还是 i—</p>
</li>
<li><p>单调栈 找比自己大的  那栈顶就是栈里最小的。好好理解一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//力扣503</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到第一个大于自己的元素 </span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>()&lt;=nums[i%n]) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//没找到  那自己就是最大的</span></span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) result[i%n] = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//找到了保存结果 </span></span><br><span class="line">            <span class="keyword">else</span> result[i%n] = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">//把自己放进去</span></span><br><span class="line">            st.<span class="built_in">push</span>( nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/11/15/8-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Epoll%E5%8A%9F%E8%83%BD%E7%9A%84%E5%B0%81%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/11/15/8-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Epoll%E5%8A%9F%E8%83%BD%E7%9A%84%E5%B0%81%E8%A3%85/" itemprop="url">C++实战——Epoll功能的封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-15T20:08:27+08:00">
                2022-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<p>简单介绍（后面去其他博客搜刮一下补充一波）</p>
<p>非阻塞同步IO所要用到的一个功能。这个项目中对这部分功能进行了很好的封装。简单介绍一下Epoll的作用。当服务器的负责监听的文件描述符发生改动，表示有连接进来。Epoll会将新的文件描述符与其对应事件加入，后面调用自身的一些方法，去监听这些连接文件描述符，有数据变动说明有数据进来，就返回这些有数据的文件描述符的列表。那么主线程通过列表中的这些文件描述符就可以拿到数据，然后分发给各个线程。</p>
<h2 id="API及其具体实现如下："><a href="#API及其具体实现如下：" class="headerlink" title="API及其具体实现如下："></a>API及其具体实现如下：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">//epoll_ctl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Epoller</span><span class="params">(<span class="type">int</span> maxEvent = <span class="number">1024</span>)</span></span>;          <span class="comment">//最大检测到的Epoll数量</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Epoller</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;             <span class="comment">//添加要检测的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;            <span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;                             <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;                   <span class="comment">//让内核去检测</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;                 <span class="comment">//获取</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epollFd_;                                     <span class="comment">//通过这个东西可以操作某个Epoller对象</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;          <span class="comment">//检测到的事件集合</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EPOLLER_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建和释放</span></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvent):<span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(<span class="number">512</span>)), <span class="built_in">events_</span>(maxEvent)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(epollFd_ &gt;= <span class="number">0</span> &amp;&amp; events_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(epollFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件描述符与事件 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的 有数据的 文件描述符  但是是根据索引获取指定的fd</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只是简单获取Events;</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/11/14/7.C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/11/14/7.C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1/" itemprop="url">C++实战——线程池设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-14T19:23:10+08:00">
                2022-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-实战——线程池设计"><a href="#C-实战——线程池设计" class="headerlink" title="C++实战——线程池设计"></a>C++实战——线程池设计</h1><p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<ol>
<li><p>首先,在线程池的私有部分 定义结构体 <code>Pool</code> 并且实例化一个共享智能指针.另外可以看到任务队列实际上，就是一个参数为返回值为<code>void</code> ,参数为空的函数的队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pool</span> </span><br><span class="line">&#123;</span><br><span class="line">    std::mutex mtx;                            <span class="comment">//互斥锁</span></span><br><span class="line">    std::condition_variable cond;              <span class="comment">//条件变量</span></span><br><span class="line">    <span class="type">bool</span> isClosed;                             <span class="comment">//是否关闭</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;   <span class="comment">//任务队列 </span></span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;Pool&gt; pool_; </span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>显式实例化构造函数定义,在这之前需要先看看 std::thread的构造方法，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制显式实例化   放置A a = 8  必须 A a = new A(8); </span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span></span><br><span class="line">    <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建8个子线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="comment">//创建线程表示不需要父线程对线程进行资源的释放</span></span><br><span class="line">        std::<span class="built_in">thread</span>([pool = pool_] &#123; ... &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述thread方法的 <code>...</code>为线程的具体要执行的命令内容。<code>.detach（）</code>代表线程不需要父线程释放资源，该方法会自动释放资源。</p>
<p>具体命令内容如下，可以看到通过互斥锁实现对 <code>pool-&gt;tasks</code>队列的互斥访问，：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">thread</span>([pool = pool_] &#123;                       </span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);  <span class="comment">//设置一个锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从任务队列中取任务</span></span><br><span class="line">        <span class="keyword">if</span>(!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//开关锁</span></span><br><span class="line">            locker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="built_in">task</span>();                        <span class="comment">//具体任务指定的代码 functional库里边的东西</span></span><br><span class="line">            locker.<span class="built_in">lock</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pool-&gt;isClosed) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);             <span class="comment">//条件变量使之阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="built_in">detach</span>();<span class="comment">//设置线程分离？表示不需要父线程对线程进行资源的释放</span></span><br></pre></td></tr></table></figure>
<p>另外上述代码中，使用条件变量在任务队列为空时讲线程阻塞，可以防止他一直不断的循环浪费资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool-&gt;cond.<span class="built_in">wait</span>(locker);</span><br></pre></td></tr></table></figure>
<p>与之相应的，向任务队列中添加任务后，通过条件变量将一个线程唤醒：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">        pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">        &#125;</span><br><span class="line">    pool_-&gt;cond.<span class="built_in">notify_one</span>();                       <span class="comment">//条件变量去唤醒一个线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>析构函数  联系上部分的线程内容，将<code>pool-&gt;isClosed</code>置为真,并且唤醒所有线程，才会让线程执行完推出并自动释放资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            pool_-&gt;isClosed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>整体上来看是一个生产者消费者模型，完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  <span class="comment">//锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span><span class="comment">//条件变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//队列</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">//线程库   c++的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义pool结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">        std::mutex mtx;                            <span class="comment">//互斥锁</span></span><br><span class="line">        std::condition_variable cond;              <span class="comment">//条件变量</span></span><br><span class="line">        <span class="type">bool</span> isClosed;                             <span class="comment">//是否关闭</span></span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;   <span class="comment">//任务队列</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;Pool&gt; pool_;                   <span class="comment">//实例化一个pool指针 而且是共享指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//显式实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span></span><br><span class="line">            <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建8个子线程</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">                std::<span class="built_in">thread</span>([pool = pool_] &#123;                       <span class="comment">//花括号内为线程的具体任务</span></span><br><span class="line">                    </span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);  <span class="comment">//设置一个锁</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="comment">//从任务队列中取任务</span></span><br><span class="line">                        <span class="keyword">if</span>(!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                            locker.<span class="built_in">unlock</span>();</span><br><span class="line">                            <span class="built_in">task</span>();                               <span class="comment">//具体任务指定的代码 functional库里边的东西</span></span><br><span class="line">                            locker.<span class="built_in">lock</span>();</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(pool-&gt;isClosed) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);             <span class="comment">//条件变量使之阻塞</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="built_in">detach</span>();<span class="comment">//设置线程分离？表示不需要父线程对线程进行资源的释放</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;  <span class="comment">//无参用默认</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">//没定义用默认</span></span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">                pool_-&gt;isClosed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">        &#125;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();                       <span class="comment">//条件变量去唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//THREADPOOL_H</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/18/30-DPDK%E2%80%94%E2%80%94%E6%97%A0%E6%89%80%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97-%E5%86%85%E5%AD%98%E6%B1%A0-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/18/30-DPDK%E2%80%94%E2%80%94%E6%97%A0%E6%89%80%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97-%E5%86%85%E5%AD%98%E6%B1%A0-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" itemprop="url">DPDK——无所环形队列+内存池 实现进程间通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-18T20:35:11+08:00">
                2022-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id><a href="#" class="headerlink" title=" "></a> </h1><h3 id="0-概括"><a href="#0-概括" class="headerlink" title="0.概括"></a>0.概括</h3><p>首先通信原理十分简单，先概括一下</p>
<p>首先创建一个内存池，内存池中是一块一块内存，大小由我们指定。作为我们传递消息的单位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">message_pool</span> =</span> rte_mempool_create(_MSG_POOL, pool_size,</span><br><span class="line">                                    STR_TOKEN_SIZE, pool_cache, priv_data_sz,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                    rte_socket_id(), flags);</span><br></pre></td></tr></table></figure>
<p>我们需要指定内存池的名称，大小，元素大小，其他的不太重要看看，就好。首先由一个进程创建好这个缓冲池之后，另一个缓冲池要查找到这个缓冲池。通过下面的方式，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">message_pool</span> <span class="title">message_pool</span> =</span> rte_mempool_lookup(_MSG_POOL);</span><br></pre></td></tr></table></figure>
<p>也就是使用共享内存的方式进行通信，但是固定了每条信息的大小。我愿称之为，结合了共享内存与消息队列。</p>
<h2 id="1-如何进行通信"><a href="#1-如何进行通信" class="headerlink" title="1.如何进行通信"></a>1.如何进行通信</h2><p>通过无所环形队列，存放消息在内存池中的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">send_ring</span> =</span> rte_ring_create(_PRI_2_SEC, ring_size, rte_socket_id(), flags);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">recv_ring</span> =</span> rte_ring_create(_SEC_2_PRI, ring_size, rte_socket_id(), flags);</span><br></pre></td></tr></table></figure>
<p>上面就是创建了两个消息唤醒队列，里面用于存放，消息在内存池中的地址。需要指定名称和大小。那么通信的另一端如何找到呢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">recv_ring</span> =</span> rte_ring_lookup(_PRI_2_SEC);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">send_ring</span> =</span> rte_ring_lookup(_SEC_2_PRI);</span><br></pre></td></tr></table></figure>
<p>可以看到也是通过名称来寻找。而且可以发现名称调换了位置。</p>
<h3 id="1-1-发送消息"><a href="#1-1-发送消息" class="headerlink" title="1.1 发送消息"></a>1.1 发送消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">rte_mempool_get(message_pool, &amp;msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过memcpy等方式将信息存放进msg</span></span><br><span class="line"></span><br><span class="line">rte_ring_enqueue(send_ring, msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先定义一个指针变量，然后去消息缓冲池中拿一块内存区域，起始地址赋给msg。然后将给msg指向的区域赋值过后。就把msg放进发送环形队列。</p>
<h3 id="1-2-接收消息"><a href="#1-2-接收消息" class="headerlink" title="1.2 接收消息"></a>1.2 接收消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *msg;</span><br><span class="line">rte_ring_dequeue(recv_ring, &amp;msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到msg  指向的内存就是消息实体    </span></span><br><span class="line">    </span><br><span class="line">rte_mempool_put(message_pool, msg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先定义一个指针变量，从接收环形队列中拿到一个指针（如果有的话），然后这个指针指向的位置就是内存中的消息实体。拿到消息做处理之后。再把这个东西放回内存池。</p>
<p>总结，其实原理感觉非常简单，主要需要注意的就是两个进程为什么可以通过字符串来找到环形队列和内存池。其实就是同一台机器运行的dpdk程序有着同一套运行时环境。这也就是为什么如果开启第二个dpdk程序时，要指定参数—proc-type secondary 的原因。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/18/29-DPDK%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85-UIO-PMD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/18/29-DPDK%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85-UIO-PMD/" itemprop="url">DPDK——如何获取数据包 UIO+PMD</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-18T19:34:15+08:00">
                2022-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>（绕蒙圈了已经）可直接跳到后面看结论.目前已经不影响项目进展，中间部分当作素材，留着以后看看能不能整理出来吧。</strong></p>
<p>这里主要是想搞清楚具体的，从网卡拿到数据包的流程是什么样的。正常来说，数据包进入网卡队列，由网卡驱动将数据包拷贝到内核缓冲区，然后进行封装，封装成sk_buffer然后就上交内核协议栈了。那么在我们的程序中，我们想要直接拿到网卡队列中的原始数据包。</p>
<h2 id="0-DPDK为我们提供的接口"><a href="#0-DPDK为我们提供的接口" class="headerlink" title="0.DPDK为我们提供的接口"></a>0.DPDK为我们提供的接口</h2><p>想要达到这样的目的很简单，因为dpdk已经为我们提供了这样的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>；</span><br></pre></td></tr></table></figure>
<p>其中，第一个参数代表我们想要从哪个网卡端口获取数据包，第二个参数代表我们想要从哪个队列获取数据包，第三个参数是存放数据包数组指针，这个结构体用于存放原始数据包，第四个参数用于限制依次读取数据包的大小。</p>
<h2 id="1-接口中重要的两步"><a href="#1-接口中重要的两步" class="headerlink" title="1.接口中重要的两步"></a>1.接口中重要的两步</h2><p>在上一部分提到的接口函数的定义中找到两句比较重要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line">nb_rx = (*dev-&gt;rx_pkt_burst)(dev-&gt;data-&gt;rx_queues[queue_id],</span><br><span class="line">				     rx_pkts, nb_pkts);</span><br></pre></td></tr></table></figure>
<p>通过<code>port_id</code>拿到我们具体想要在哪个网卡端口获取数据包。代表网卡端口设备的结构体定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> &#123;</span></span><br><span class="line">	<span class="type">eth_rx_burst_t</span> rx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD receive function. */</span></span><br><span class="line">	<span class="type">eth_tx_burst_t</span> tx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD transmit function. */</span></span><br><span class="line">	<span class="type">eth_tx_prep_t</span> tx_pkt_prepare; <span class="comment">/**&lt; Pointer to PMD transmit prepare function. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_rx_queue_count_t</span>       rx_queue_count; <span class="comment">/**&lt; Get the number of used RX descriptors. */</span></span><br><span class="line">	<span class="type">eth_rx_descriptor_done_t</span>   rx_descriptor_done;   <span class="comment">/**&lt; Check rxd DD bit. */</span></span><br><span class="line">	<span class="type">eth_rx_descriptor_status_t</span> rx_descriptor_status; <span class="comment">/**&lt; Check the status of a Rx descriptor. */</span></span><br><span class="line">	<span class="type">eth_tx_descriptor_status_t</span> tx_descriptor_status; <span class="comment">/**&lt; Check the status of a Tx descriptor. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Next two fields are per-device data but *data is shared between</span></span><br><span class="line"><span class="comment">	 * primary and secondary processes and *process_private is per-process</span></span><br><span class="line"><span class="comment">	 * private. The second one is managed by PMDs if necessary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_data</span> *<span class="title">data</span>;</span>  <span class="comment">/**&lt; Pointer to device data. */</span></span><br><span class="line">	<span class="type">void</span> *process_private; <span class="comment">/**&lt; Pointer to per-process device data. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_dev_ops</span> *<span class="title">dev_ops</span>;</span> <span class="comment">/**&lt; Functions exported by PMD */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_device</span> *<span class="title">device</span>;</span> <span class="comment">/**&lt; Backing device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_intr_handle</span> *<span class="title">intr_handle</span>;</span> <span class="comment">/**&lt; Device interrupt handle */</span></span><br><span class="line">	<span class="comment">/** User application callbacks for NIC interrupts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_cb_list</span> <span class="title">link_intr_cbs</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from rx_burst to post-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">post_rx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from tx_burst to pre-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the driver for transmission.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">pre_tx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_dev_state</span> <span class="title">state</span>;</span> <span class="comment">/**&lt; Flag indicating the port state */</span></span><br><span class="line">	<span class="type">void</span> *security_ctx; <span class="comment">/**&lt; Context for security ops */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">4</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">4</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125; __rte_cache_aligned;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个结构体与每一个以太网设备关联。可以这样理解，这就是网卡的用户态驱动程序。可以看到其中就定义了我们接收数据包所需要的<code>rx_pkt_burst</code>。也就是说，根据我们实际使用的网卡型号，我们在初始化网络设备的时候，会对这个数据结构进行相应的赋值。以实现对应网卡的对应功能。这个在运行dpdk程序之前需要我们去绑定用户态驱动。这个不用多说，绑定之后由dpdk去为我们检测。比如在程序中我们调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_count_avail</span><span class="params">()</span> <span class="comment">//就可以查看当前绑定了用户态驱动的网卡设备数量。</span></span><br><span class="line"><span class="title function_">rte_eth_macaddr_get</span><span class="params">((<span class="type">uint8_t</span>) m_Id, &amp;etherAddr)</span>; <span class="comment">//获取mac地址</span></span><br><span class="line">rte_eth_dev_get_mtu((<span class="type">uint8_t</span>) m_Id, &amp;m_DeviceMtu);<span class="comment">//获取最大帧长</span></span><br></pre></td></tr></table></figure>
<p>等等等等。这些信息都源自下面这个结构体，通过下面的结构体存放这绑定了用户态驱动的网卡端口任何信息，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_device</span> *<span class="title">device</span>;</span> <span class="comment">/** Generic device information */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *driver_name; <span class="comment">/**&lt; Device Driver name. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> if_index; <span class="comment">/**&lt; Index to bound host interface, or 0 if none.</span></span><br><span class="line"><span class="comment">		Use if_indextoname() to translate into an interface name. */</span></span><br><span class="line">	<span class="type">uint16_t</span> min_mtu;	<span class="comment">/**&lt; Minimum MTU allowed */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_mtu;	<span class="comment">/**&lt; Maximum MTU allowed */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">uint32_t</span> *dev_flags; <span class="comment">/**&lt; Device flags */</span></span><br><span class="line">	<span class="type">uint32_t</span> min_rx_bufsize; <span class="comment">/**&lt; Minimum size of RX buffer. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_rx_pktlen; <span class="comment">/**&lt; Maximum configurable length of RX pkt. */</span></span><br><span class="line">	<span class="comment">/** Maximum configurable size of LRO aggregated packet. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_lro_pkt_size;</span><br><span class="line">	<span class="type">uint16_t</span> max_rx_queues; <span class="comment">/**&lt; Maximum number of RX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_tx_queues; <span class="comment">/**&lt; Maximum number of TX queues. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_mac_addrs; <span class="comment">/**&lt; Maximum number of MAC addresses. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_hash_mac_addrs;</span><br><span class="line">	<span class="comment">/** Maximum number of hash MAC addresses for MTA and UTA. */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_vfs; <span class="comment">/**&lt; Maximum number of VFs. */</span></span><br><span class="line">	<span class="type">uint16_t</span> max_vmdq_pools; <span class="comment">/**&lt; Maximum number of VMDq pools. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxseg_capa</span> <span class="title">rx_seg_capa</span>;</span> <span class="comment">/**&lt; Segmentation capability.*/</span></span><br><span class="line">	<span class="type">uint64_t</span> rx_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; All RX offload capabilities including all per-queue ones */</span></span><br><span class="line">	<span class="type">uint64_t</span> tx_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; All TX offload capabilities including all per-queue ones */</span></span><br><span class="line">	<span class="type">uint64_t</span> rx_queue_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; Device per-queue RX offload capabilities. */</span></span><br><span class="line">	<span class="type">uint64_t</span> tx_queue_offload_capa;</span><br><span class="line">	<span class="comment">/**&lt; Device per-queue TX offload capabilities. */</span></span><br><span class="line">	<span class="type">uint16_t</span> reta_size;</span><br><span class="line">	<span class="comment">/**&lt; Device redirection table size, the total number of entries. */</span></span><br><span class="line">	<span class="type">uint8_t</span> hash_key_size; <span class="comment">/**&lt; Hash key size in bytes */</span></span><br><span class="line">	<span class="comment">/** Bit mask of RSS offloads, the bit offset also means flow type */</span></span><br><span class="line">	<span class="type">uint64_t</span> flow_type_rss_offloads;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxconf</span> <span class="title">default_rxconf</span>;</span> <span class="comment">/**&lt; Default RX configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">default_txconf</span>;</span> <span class="comment">/**&lt; Default TX configuration */</span></span><br><span class="line">	<span class="type">uint16_t</span> vmdq_queue_base; <span class="comment">/**&lt; First queue ID for VMDQ pools. */</span></span><br><span class="line">	<span class="type">uint16_t</span> vmdq_queue_num;  <span class="comment">/**&lt; Queue number for VMDQ pools. */</span></span><br><span class="line">	<span class="type">uint16_t</span> vmdq_pool_base;  <span class="comment">/**&lt; First ID of VMDQ pools. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_desc_lim</span> <span class="title">rx_desc_lim</span>;</span>  <span class="comment">/**&lt; RX descriptors limits */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_desc_lim</span> <span class="title">tx_desc_lim</span>;</span>  <span class="comment">/**&lt; TX descriptors limits */</span></span><br><span class="line">	<span class="type">uint32_t</span> speed_capa;  <span class="comment">/**&lt; Supported speeds bitmap (ETH_LINK_SPEED_). */</span></span><br><span class="line">	<span class="comment">/** Configured number of rx/tx queues */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_rx_queues; <span class="comment">/**&lt; Number of RX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_tx_queues; <span class="comment">/**&lt; Number of TX queues. */</span></span><br><span class="line">	<span class="comment">/** Rx parameter recommendations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_portconf</span> <span class="title">default_rxportconf</span>;</span></span><br><span class="line">	<span class="comment">/** Tx parameter recommendations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_portconf</span> <span class="title">default_txportconf</span>;</span></span><br><span class="line">	<span class="comment">/** Generic device capabilities (RTE_ETH_DEV_CAPA_). */</span></span><br><span class="line">	<span class="type">uint64_t</span> dev_capa;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Switching information for ports on a device with a</span></span><br><span class="line"><span class="comment">	 * embedded managed interconnect/switch.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_switch_info</span> <span class="title">switch_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">2</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">2</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应用程序中往往执行下面的两行代码就可以拿到，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rte_eth_dev_info portInfo;</span><br><span class="line">rte_eth_dev_info_get(Id, &amp;portInfo);</span><br></pre></td></tr></table></figure>
<p>id一般从0开始，如果系统中有两个网卡绑定了用户态驱动，那么通过0，1就可以获取这两张网卡设备的信息。</p>
<p>查了一下自己用的<code>igb_uio</code>驱动的源码，比较重要的映射功能实现主要是下面的probe函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">igbuio_pci_probe(<span class="keyword">struct</span> pci_dev *dev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_uio_pci_dev</span> *<span class="title">udev</span>;</span></span><br><span class="line">	<span class="type">dma_addr_t</span> map_dma_addr;</span><br><span class="line">	<span class="type">void</span> *map_addr;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PCI_IS_BRIDGE_API</span></span><br><span class="line">	<span class="keyword">if</span> (pci_is_bridge(dev)) &#123;</span><br><span class="line">		dev_warn(&amp;dev-&gt;dev, <span class="string">&quot;Ignoring PCI bridge device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	udev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_uio_pci_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!udev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * enable device: ask low-level code to enable I/O and</span></span><br><span class="line"><span class="comment">	 * memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = pci_enable_device(dev);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev, <span class="string">&quot;Cannot enable PCI device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* enable bus mastering on the device */</span></span><br><span class="line">	pci_set_master(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remap IO memory */</span></span><br><span class="line">	err = igbuio_setup_bars(dev, &amp;udev-&gt;info);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set 64-bit DMA mask */</span></span><br><span class="line">	err = pci_set_dma_mask(dev,  DMA_BIT_MASK(<span class="number">64</span>));</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev, <span class="string">&quot;Cannot set DMA mask\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(<span class="number">64</span>));</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev, <span class="string">&quot;Cannot set consistent DMA mask\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill uio infos */</span></span><br><span class="line">	udev-&gt;info.name = <span class="string">&quot;igb_uio&quot;</span>;</span><br><span class="line">	udev-&gt;info.version = <span class="string">&quot;0.1&quot;</span>;</span><br><span class="line">	udev-&gt;info.irqcontrol = igbuio_pci_irqcontrol;</span><br><span class="line">	udev-&gt;info.open = igbuio_pci_open;</span><br><span class="line">	udev-&gt;info.release = igbuio_pci_release;</span><br><span class="line">	udev-&gt;info.priv = udev;</span><br><span class="line">	udev-&gt;pdev = dev;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;udev-&gt;refcnt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	err = sysfs_create_group(&amp;dev-&gt;dev.kobj, &amp;dev_attr_grp);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_release_iomem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register uio driver */</span></span><br><span class="line">	err = uio_register_device(&amp;dev-&gt;dev, &amp;udev-&gt;info);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_remove_group;</span><br><span class="line"></span><br><span class="line">	pci_set_drvdata(dev, udev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Doing a harmless dma mapping for attaching the device to</span></span><br><span class="line"><span class="comment">	 * the iommu identity mapping if kernel boots with iommu=pt.</span></span><br><span class="line"><span class="comment">	 * Note this is not a problem if no IOMMU at all.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	map_addr = dma_alloc_coherent(&amp;dev-&gt;dev, <span class="number">1024</span>, &amp;map_dma_addr,</span><br><span class="line">			GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (map_addr)</span><br><span class="line">		<span class="built_in">memset</span>(map_addr, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!map_addr)</span><br><span class="line">		dev_info(&amp;dev-&gt;dev, <span class="string">&quot;dma mapping failed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dev_info(&amp;dev-&gt;dev, <span class="string">&quot;mapping 1K dma=%#llx host=%p\n&quot;</span>,</span><br><span class="line">			 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)map_dma_addr, map_addr);</span><br><span class="line"></span><br><span class="line">		dma_free_coherent(&amp;dev-&gt;dev, <span class="number">1024</span>, map_addr, map_dma_addr);</span><br><span class="line">		dev_info(&amp;dev-&gt;dev, <span class="string">&quot;unmapping 1K dma=%#llx host=%p\n&quot;</span>,</span><br><span class="line">			 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)map_dma_addr, map_addr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_remove_group:</span><br><span class="line">	sysfs_remove_group(&amp;dev-&gt;dev.kobj, &amp;dev_attr_grp);</span><br><span class="line">fail_release_iomem:</span><br><span class="line">	igbuio_pci_release_iomem(&amp;udev-&gt;info);</span><br><span class="line">	pci_disable_device(dev);</span><br><span class="line">fail_free:</span><br><span class="line">	kfree(udev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = igbuio_setup_bars(dev, &amp;udev-&gt;info);</span><br></pre></td></tr></table></figure>
<p>函数的作用是读取当前设备的所有<code>PCI BAR</code>的信息，并存储到uio_info结构体中。<code>PCI BAR</code>是一种存储基地址的寄存器，它可以指示设备内部的内存或<code>I/O</code>端口的位置和大小。这些信息在后续注册<code>UIO</code>设备时需要使用，以便用户程序可以通过<code>mmap</code>函数映射<code>/dev/uioX</code>文件到用户空间的虚拟地址，并根据偏移量访问不同的<code>PCI BAR</code>区域。</p>
<p>看到下面这两个指针的定义就觉得不简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dma_addr_t</span> map_dma_addr;</span><br><span class="line"><span class="type">void</span> *map_addr;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//之后</span></span><br><span class="line">map_addr = dma_alloc_coherent(&amp;dev-&gt;dev, <span class="number">1024</span>, &amp;map_dma_addr,GFP_KERNEL);</span><br></pre></td></tr></table></figure>
<p><code>dma_alloc_coherent</code>是一个用于分配一致性<code>DMA</code>内存的函数。一致性<code>DMA</code>内存是指可以被设备和<code>CPU</code>同时访问而不需要考虑缓存效应的内存。</p>
<p><code>dma_alloc_coherent</code>函数接受四个参数：第一个参数<code>dev</code>是一个<code>struct device</code>指针，用于指定要执行<code>DMA</code>的设备；第二个参数<code>size</code>是要分配的内存大小；第三个参数是一个<code>dma_addr_t</code>指针，用于返回分配的内存的<code>DMA</code>地址；<code>flag</code>是一个<code>gfp_t</code>类型，用于指定分配内存时的标志位，如<code>GFP_KERNEL</code>等。</p>
<p><code>dma_alloc_coherent</code>函数返回两个值：用于CPU访问的虚拟地址<code>cpu_addr</code>和用于设备访问的<code>DMA</code>地址<code>dma_addr_t</code>。这两个地址可能不相同，因为可能存在物理地址和总线地址之间的转换。因此，在CPU端要使用<code>cpu_addr</code>来操作分配的内存，在设备端要使用<code>dma_addr_t</code>来作为<code>DMA</code>源或目标地址</p>
<p>经历这步之后，打印信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dev_info(&amp;dev-&gt;dev, <span class="string">&quot;mapping 1K dma=%#llx host=%p\n&quot;</span>,</span><br><span class="line">			 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)map_dma_addr, map_addr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>合理推测（不一定对哈），到时候数据包从网卡队列里头拿出来应该就是拿到这里面。</p>
<p>可以将PCI设备的内存空间映射到用户空间，并提供中断处理功能。而PMD驱动程序由具体的网卡驱动程序支持。</p>
<p>那直接总结好了：</p>
<p>首先运行dpdk程序会要求我们将网卡绑定UIO驱动。我绑定的是<code>igb_uio</code></p>
<p>UIO驱动是一种用户空间驱动，它可以让用户空间的程序直接访问和控制某些类型的设备，而不需要编写复杂的内核模块。UIO驱动的优点是简化了驱动程序的开发和维护，降低了内核崩溃的风险，提高了驱动程序的更新效率。UIO驱动适用于那些具有可映射的内存空间，可以通过内存写入来控制，通常会产生中断，并且不属于标准内核子系统范畴的设备。</p>
<p>UIO驱动的工作原理是通过一个字符设备文件和一些sysfs属性文件来访问和管理设备。字符设备文件通常命名为/dev/uio0, /dev/uio1等等。用户空间的程序可以通过mmap()函数将设备文件映射到自己的地址空间，并通过读写该地址空间来访问和控制设备的寄存器或RAM位置。用户空间的程序还可以通过read()或select()函数来等待和处理设备产生的中断。sysfs属性文件则提供了一些关于设备名称、版本、映射大小、中断号等信息。</p>
<p>（Poll Mode Drivers）网卡驱动。该驱动由用户态的 API 以及 PMD Driver 构成，内核态的 UIO Driver 屏蔽了网卡发出的中断信号，然后由用户态的 PMD Driver 采用主动轮询的方式。除了链路状态通知仍必须采用中断方式以外，均使用无中断方式直接操作网卡设备的接收和发送队列。</p>
<p>PMD Driver 从网卡上接收到数据包后，会直接通过 DMA 方式传输到预分配的内存中，同时更新无锁环形队列中的数据包指针，不断轮询的应用程序很快就能感知收到数据包，并在预分配的内存地址上直接处理数据包，这个过程非常简洁。</p>
<p>PMD 极大提升了网卡 I/O 性能。此外，PMD 还同时支持物理和虚拟两种网络接口，支持 Intel、Cisco、Broadcom、Mellanox、Chelsio 等整个行业生态系统的网卡设备，以及支持基于 KVM、VMware、 Xen 等虚拟化网络接口。PMD 实现了 Intel 1GbE、10GbE 和 40GbE 网卡下基于轮询收发包。</p>
<p>UIO+PMD，前者零拷贝，后者主动轮询避免了硬中断，DPDK 从而可以在用户态进行收发包的处理。带来了零拷贝（Zero Copy）、无系统调用（System call）的优化。同时，还避免了软中断的异步处理，也减少了上下文切换带来的 Cache Miss。</p>
<p>igb_uio是一种PCI驱动，它可以将网卡设备绑定到用户态，并绕开内核的网络栈。它的主要工作流程如下：</p>
<ul>
<li>igb_uio模块初始化时，向内核注册一个pci_driver结构体，但不指定任何设备id。</li>
<li>用户通过dpdk-devbind.py脚本将某个网卡设备绑定到igb_uio驱动，触发probe回调函数。</li>
<li>probe回调函数中，首先使能当前设备，并设置DMA模式。</li>
<li>然后调用igbuio_setup_bars函数，读取当前设备的所有PCI BAR的信息，并存储到uio_info结构体中。PCI BAR是一种存储基地址的寄存器，它可以指示设备内部的内存或I/O端口的位置和大小。</li>
<li>接着初始化UIO设备的文件操作函数，如open、release、irqcontrol等。</li>
<li>最后调用uio_register_device函数，将当前设备注册为UIO设备，并在sysfs文件系统下创建/dev/uioX文件接口。</li>
<li>用户程序可以通过mmap函数，映射/dev/uioX文件到用户空间的虚拟地址，并根据偏移量访问不同的PCI BAR区域。这样就可以直接与网卡设备进行通信了。</li>
</ul>
<p>DPDK是一种数据平面开发工具包，它可以实现绕过内核的功能，提高网络I/O性能。DPDK的主要方法是：</p>
<ul>
<li>使用UIO或VFIO等机制，将网卡设备从内核驱动转移到用户态驱动，这样可以避免中断和系统调用的开销，直接访问网卡寄存器和描述符<a target="_blank" rel="noopener" href="https://www.dpdk.org/blog/2020/12/10/dpdk-welcomes-microsoft/">1</a><a target="_blank" rel="noopener" href="https://github.com/demikernel/demikernel">2</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jungle1996/p/12398915.html">3</a>。</li>
<li>使用大页内存和物理连续的内存池，分配和管理数据包缓冲区，这样可以减少TLB的开销，提高缓存命中率，降低延迟<a target="_blank" rel="noopener" href="https://pcapplusplus.github.io/docs/dpdk">4</a><a target="_blank" rel="noopener" href="https://github.com/gamemann/The-DPDK-Examples">5</a>。</li>
<li>使用轮询模式的驱动，不依赖于中断，而是主动检查网卡的状态，并处理数据包<a target="_blank" rel="noopener" href="https://www.dpdk.org/blog/2020/12/10/dpdk-welcomes-microsoft/">3</a><a target="_blank" rel="noopener" href="https://github.com/demikernel/demikernel"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jungle1996/p/12398915.html"></a>。</li>
</ul>
<p>通过这些方法，DPDK可以实现不在内核的高性能网络I/O。</p>
<p><strong>结论！！！！</strong></p>
<p>网卡设备绑定igb_uio之后会将自己的硬件内部的内存空间 保存在sysfs的目录下，用户可以将这部分空间映射到用户空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>；</span><br></pre></td></tr></table></figure>
<p>所以说这个接口底层逻辑就是通过<code>PMD</code>直接从网卡的硬件获取数据包保存在<code>rte_mbuf</code>中</p>
<p>至于PMD的好处！</p>
<p>PMD可以直接把网卡上的数据包存放到用户空间，是因为它使用了一些特殊的机制，如：</p>
<ul>
<li>UIO或VFIO等机制，可以将网卡设备从内核驱动转移到用户态驱动，这样可以避免中断和系统调用的开销，直接访问网卡寄存器和描述符<a target="_blank" rel="noopener" href="https://www.pmd.com/"></a></li>
<li>大页内存和物理连续的内存池，可以分配和管理数据包缓冲区，这样可以减少TLB的开销，提高缓存命中率，降低延迟。</li>
</ul>
<p>通过这些机制，PMD可以实现不经过内核的高效数据传输。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/17/28-DPDK%E2%80%94%E2%80%94cpu%E4%BA%B2%E5%92%8C%E6%80%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/17/28-DPDK%E2%80%94%E2%80%94cpu%E4%BA%B2%E5%92%8C%E6%80%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url">DPDK——cpu亲和性线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-17T20:53:53+08:00">
                2022-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-为什么要有cpu亲和性"><a href="#0-为什么要有cpu亲和性" class="headerlink" title="0.为什么要有cpu亲和性"></a>0.为什么要有cpu亲和性</h2><p>在多核运行的机器上，每个CPU本身自己会有缓存，在缓存中存着进程使用的数据，而没有绑定CPU的话，进程可能会被操作系统调度到其他CPU上，如此CPU cache（高速缓冲存储器）命中率就低了，也就是说调到的CPU缓存区中原来没有这类数据，要先把内存或硬盘的数据载入缓存。而当缓存区绑定CPU后，程序就会一直在指定的CPU执行，不会被操作系统调度到其他CPU，性能上会有一定的提高。</p>
<p>为了让程序拥有更好的性能，有时候需要将进程或线程绑定到特定的CPU上，这样可以减少调度的开销和保护关键进程或线程。</p>
<h2 id="1-重要的结构体"><a href="#1-重要的结构体" class="headerlink" title="1.重要的结构体"></a>1.重要的结构体</h2><h3 id="1-1-逻辑核心"><a href="#1-1-逻辑核心" class="headerlink" title="1.1 逻辑核心"></a>1.1 逻辑核心</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure storing internal configuration (per-lcore)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcore_config</span> &#123;</span></span><br><span class="line">	<span class="type">pthread_t</span> thread_id;       <span class="comment">/**&lt; pthread identifier */</span></span><br><span class="line">	<span class="type">int</span> pipe_main2worker[<span class="number">2</span>];   <span class="comment">/**&lt; communication pipe with main */</span></span><br><span class="line">	<span class="type">int</span> pipe_worker2main[<span class="number">2</span>];   <span class="comment">/**&lt; communication pipe with main */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">lcore_function_t</span> * <span class="keyword">volatile</span> f; <span class="comment">/**&lt; function to call */</span></span><br><span class="line">	<span class="type">void</span> * <span class="keyword">volatile</span> arg;       <span class="comment">/**&lt; argument of function */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> ret;          <span class="comment">/**&lt; return value of function */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">enum</span> <span class="title">rte_lcore_state_t</span> <span class="title">state</span>;</span> <span class="comment">/**&lt; lcore state */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> socket_id;    <span class="comment">/**&lt; physical socket id for this lcore */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> core_id;      <span class="comment">/**&lt; core number on socket for this lcore */</span></span><br><span class="line">	<span class="type">int</span> core_index;            <span class="comment">/**&lt; relative index, starting from 0 */</span></span><br><span class="line">	<span class="type">uint8_t</span> core_role;         <span class="comment">/**&lt; role of core eg: OFF, RTE, SERVICE */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">rte_cpuset_t</span> cpuset;       <span class="comment">/**&lt; cpu set which the lcore affinity to */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcore_config</span> <span class="title">lcore_config</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br></pre></td></tr></table></figure>
<p>该结构体在下称之为 逻辑核心描述符 用于描述dpdk线程池中的某一个线程。这里面其实就是一个线程任务描述符，（此线程描述符非彼线程描述符）把他抽象成一个核心而已。</p>
<ul>
<li>线程id </li>
<li>与主线程通信的两个管道</li>
<li>该逻辑核心要完成的工作（函数指针，参数，返回值）</li>
<li>当前逻辑核心状态</li>
<li>socket_id core_id 和numa架构有关暂且不管</li>
<li>然后是索引 </li>
<li>然后是状态  是否被dpdk标记使用，是否正在被使用</li>
<li>该逻辑核心与那个cpu集亲和。  比如亲和的是物理编号为（0，1）的cpu那么这个线程就只会被这两个核心去调度运行。我们的程序不做特殊说明，默认的情况下，一个线程与核心是1：1.</li>
</ul>
<h3 id="1-2-运行时环境设置（Run-time-evironment）"><a href="#1-2-运行时环境设置（Run-time-evironment）" class="headerlink" title="1.2 运行时环境设置（Run-time evironment）"></a>1.2 运行时环境设置（Run-time evironment）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global RTE configuration structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> main_lcore;         <span class="comment">/**&lt; Id of the main lcore */</span></span><br><span class="line">	<span class="type">uint32_t</span> lcore_count;        <span class="comment">/**&lt; Number of available logical cores. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_node_count;    <span class="comment">/**&lt; Number of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_nodes[RTE_MAX_NUMA_NODES]; <span class="comment">/**&lt; List of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> service_lcore_count;<span class="comment">/**&lt; Number of available service cores. */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_lcore_role_t</span> <span class="title">lcore_role</span>[<span class="title">RTE_MAX_LCORE</span>];</span> <span class="comment">/**&lt; State of cores. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Primary or secondary configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_proc_type_t</span> <span class="title">process_type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** PA or VA mapping mode */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">iova_mode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Pointer to memory configuration, which may be shared across multiple</span></span><br><span class="line"><span class="comment">	 * DPDK instances</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mem_config</span>;</span></span><br><span class="line">&#125; __rte_packed;</span><br></pre></td></tr></table></figure>
<p>挑重点的说了，</p>
<ul>
<li><p>主线程号</p>
</li>
<li><p>逻辑线程数量</p>
</li>
<li>每个逻辑线程目前的角色（状态）</li>
<li>进程的类型（同一台机器只能运行一个dpdk主进程，其他的需要加上从进程参数）</li>
</ul>
<h2 id="2-线程池的创建和初始化"><a href="#2-线程池的创建和初始化" class="headerlink" title="2.线程池的创建和初始化"></a>2.线程池的创建和初始化</h2><p>线程池的创建和初始化工作均在环境抽象层初始化的时候完成，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = rte_eal_init(initDpdkArgc, (<span class="type">char</span>**)initDpdkArgvBuffer);</span><br></pre></td></tr></table></figure>
<p>其中我们比较关心的参数是，核心数。在我们的代码中我们默认0号核分配给主线程。</p>
<p>首先我们在dpdk环境抽象层的配置中可以找到关于最大核心数的宏定义,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MAX_LCORE 128</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-首先对操作系统的处理器核心做初始化"><a href="#2-1-首先对操作系统的处理器核心做初始化" class="headerlink" title="2.1 首先对操作系统的处理器核心做初始化"></a>2.1 首先对操作系统的处理器核心做初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eal_create_cpu_map() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rte_eal_init_alert(<span class="string">&quot;Cannot discover CPU and NUMA.&quot;</span>);</span><br><span class="line">    <span class="comment">/* rte_errno is set */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_eal_cpu_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rte_eal_init_alert(<span class="string">&quot;Cannot detect lcores.&quot;</span>);</span><br><span class="line">    rte_errno = ENOTSUP;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要涉及到两个主要的函数，<code>eal_create_cpu_map()</code>和<code>rte_eal_cpu_init()</code>。前者没细看，大概就是为后者提供一个物理cpu核心的逻辑标识。后者的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_cpu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* pointer to global configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> *<span class="title">config</span> =</span> rte_eal_get_configuration();</span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line">	<span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> socket_id, prev_socket_id;</span><br><span class="line">	<span class="type">int</span> lcore_to_socket_id[RTE_MAX_LCORE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Parse the maximum set of logical cores, detect the subset of running</span></span><br><span class="line"><span class="comment">	 * ones and enable them by default.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">		lcore_config[lcore_id].core_index = count;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* init cpuset for per lcore config */</span></span><br><span class="line">		CPU_ZERO(&amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find socket first */</span></span><br><span class="line">		socket_id = eal_cpu_socket_id(lcore_id);</span><br><span class="line">		lcore_to_socket_id[lcore_id] = socket_id;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (eal_cpu_detected(lcore_id) == <span class="number">0</span>) &#123;</span><br><span class="line">			config-&gt;lcore_role[lcore_id] = ROLE_OFF;</span><br><span class="line">			lcore_config[lcore_id].core_index = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, lcore 1:1 map to cpu id */</span></span><br><span class="line">		CPU_SET(lcore_id, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, each detected core is enabled */</span></span><br><span class="line">		config-&gt;lcore_role[lcore_id] = ROLE_RTE;</span><br><span class="line">		lcore_config[lcore_id].core_role = ROLE_RTE;</span><br><span class="line">		lcore_config[lcore_id].core_id = eal_cpu_core_id(lcore_id);</span><br><span class="line">		lcore_config[lcore_id].socket_id = socket_id;</span><br><span class="line">		RTE_LOG(DEBUG, EAL, <span class="string">&quot;Detected lcore %u as &quot;</span></span><br><span class="line">				<span class="string">&quot;core %u on socket %u\n&quot;</span>,</span><br><span class="line">				lcore_id, lcore_config[lcore_id].core_id,</span><br><span class="line">				lcore_config[lcore_id].socket_id);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; lcore_id &lt; CPU_SETSIZE; lcore_id++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (eal_cpu_detected(lcore_id) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		RTE_LOG(DEBUG, EAL, <span class="string">&quot;Skipped lcore %u as core %u on socket %u\n&quot;</span>,</span><br><span class="line">			lcore_id, eal_cpu_core_id(lcore_id),</span><br><span class="line">			eal_cpu_socket_id(lcore_id));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the count of enabled logical cores of the EAL configuration */</span></span><br><span class="line">	config-&gt;lcore_count = count;</span><br><span class="line">	RTE_LOG(DEBUG, EAL,</span><br><span class="line">		<span class="string">&quot;Support maximum %u logical core(s) by configuration.\n&quot;</span>,</span><br><span class="line">		RTE_MAX_LCORE);</span><br><span class="line">	RTE_LOG(INFO, EAL, <span class="string">&quot;Detected %u lcore(s)\n&quot;</span>, config-&gt;lcore_count);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sort all socket id&#x27;s in ascending order */</span></span><br><span class="line">	qsort(lcore_to_socket_id, RTE_DIM(lcore_to_socket_id),</span><br><span class="line">			<span class="keyword">sizeof</span>(lcore_to_socket_id[<span class="number">0</span>]), socket_id_cmp);</span><br><span class="line"></span><br><span class="line">	prev_socket_id = <span class="number">-1</span>;</span><br><span class="line">	config-&gt;numa_node_count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">		socket_id = lcore_to_socket_id[lcore_id];</span><br><span class="line">		<span class="keyword">if</span> (socket_id != prev_socket_id)</span><br><span class="line">			config-&gt;numa_nodes[config-&gt;numa_node_count++] =</span><br><span class="line">					socket_id;</span><br><span class="line">		prev_socket_id = socket_id;</span><br><span class="line">	&#125;</span><br><span class="line">	RTE_LOG(INFO, EAL, <span class="string">&quot;Detected %u NUMA nodes\n&quot;</span>, config-&gt;numa_node_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到第一个for循环内，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcore_config[lcore_id].core_index = count;</span><br></pre></td></tr></table></figure>
<p><code>count</code>也是自增的，所以<code>count</code>实际上和索引号 <code>lcore_id</code>是一样的。然后会有检测，不过这个检测只是检测这个lcore_id是否超出了cpu核的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eal_cpu_detected(lcore_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    config-&gt;lcore_role[lcore_id] = ROLE_OFF;</span><br><span class="line">    lcore_config[lcore_id].core_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后继续看这个for循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init cpuset for per lcore config */</span></span><br><span class="line">CPU_ZERO(&amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ZERO(s)							\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		unsigned int _i;					\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">		for (_i = 0; _i &lt; _NUM_SETS(CPU_SETSIZE); _i++)		\</span></span><br><span class="line"><span class="meta">			(s)-&gt;_bits[_i] = 0LL;				\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br></pre></td></tr></table></figure>
<p>这个函数从定义来看的作用是，这个宏定义用于清空一个cpu集合，将其中所有的位都置为0。它的参数是一个指向<code>cpu_set_t</code>类型的指针，这个类型是一个结构体，包含一个数组<code>bits</code>，每个元素是一个64位的整数。<code>NUM_SETS(CPU_SETSIZE)</code>是一个宏函数，用于计算数组<code>bits</code>的长度，它的参数<code>CPU_SETSIZE</code>是<code>cpu</code>集合中能表示的最大cpu数目。这个宏定义使用了<code>do-while</code>循环语句，遍历数组<code>bits</code>中的每个元素，并将其赋值为0LL（表示长整型常量0）。这样就实现了清空<code>cpu</code>集合的功能。</p>
<p>最终也就是将每一个<code>lcore_config[lcore_id].cpuset</code>都初始化为0。初始化之后，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* By default, lcore 1:1 map to cpu id */</span></span><br><span class="line">CPU_SET(lcore_id, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_SET(b, s) ((s)-&gt;_bits[_WHICH_SET(b)] |= (1LL &lt;&lt; _WHICH_BIT(b)))</span></span><br></pre></td></tr></table></figure>
<p>从定义来看， <code>CPU_SET</code>这个宏定义用于将一个<code>cpu</code>集合中的某个位设置为1，表示将对应的<code>cpu</code>加入到集合中。它的参数是一个整数<code>b</code>，表示要设置的位的序号，和一个指向<code>cpu_set_t</code>类型的指针s，表示要操作的<code>cpu</code>集合。<code>WHICH_SET(b)</code>是一个宏函数，用于计算<code>b</code>所在的数组<code>bits</code>中的元素下标。<code>WHICH_BIT(b)</code>是一个宏函数，用于计算b在该元素中的位偏移量。这个宏定义使用了按位或运算符<code>(|=)</code>，将数组<code>bits</code>中相应元素的相应位设置为1，实现了将<code>cpu</code>加入到集合中的功能。</p>
<p>也就是说，将<code>&amp;lcore_config[lcore_id].cpuset</code>中的<code>lcore_id</code>位置为1了，代表用了这个cpu。但这也不是具体的线程与<code>cpu</code>核的绑定过程，可以说这只是一种口头上的绑定。</p>
<p>然后就是对 <code>lcore_config[lcore_id]</code>其他成员的一系列赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* By default, each detected core is enabled */</span></span><br><span class="line">config-&gt;lcore_role[lcore_id] = ROLE_RTE;</span><br><span class="line">lcore_config[lcore_id].core_role = ROLE_RTE;</span><br><span class="line">lcore_config[lcore_id].core_id = eal_cpu_core_id(lcore_id);</span><br><span class="line">lcore_config[lcore_id].socket_id = socket_id;</span><br><span class="line">RTE_LOG(DEBUG, EAL, <span class="string">&quot;Detected lcore %u as &quot;</span></span><br><span class="line">        <span class="string">&quot;core %u on socket %u\n&quot;</span>,</span><br><span class="line">        lcore_id, lcore_config[lcore_id].core_id,</span><br><span class="line">        lcore_config[lcore_id].socket_id);</span><br></pre></td></tr></table></figure>
<p>后面就没什么重要的了（本项目可以不那么关注）。</p>
<h3 id="2-2-线程创建与cpu核的绑定过程"><a href="#2-2-线程创建与cpu核的绑定过程" class="headerlink" title="2.2 线程创建与cpu核的绑定过程"></a>2.2 线程创建与cpu核的绑定过程</h3><p>2.1分析的主要是<code>lcore_config</code> 这个逻辑核描述符的初始化过程。 下面分析线程与cpu核的绑定过程。在环境抽象层的初始化过程中，首先绑定的就是<code>dpdk</code>主线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(<span class="type">rte_cpuset_t</span>),</span><br><span class="line">			&amp;lcore_config[config-&gt;main_lcore].cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot set affinity&quot;</span>);</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用到了<code>`pthread_setaffinity_np</code>，<code>pthread</code>库为我们提供的设置线程的cpu亲和性的接口：</p>
<p><a target="_blank" rel="noopener" href="https://www.noerror.net/blog/pthreadsetaffinitynp函数用法详解">pthread_setaffinity_np函数用法详解 (noerror.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38541212">Linux中CPU亲和性（affinity） - 知乎 (zhihu.com)</a></p>
<p>源码没怎么看懂，不过根据网上关于<code>pthread_setaffinity_np</code> 的解释。简单来说，当调用 <code>pthread_setaffinity_np</code> 时，如果线程不在 <code>cpuset</code> 指定的 CPU 集合中运行，那么调度器会将该线程从当前 <code>CPU</code> 上移除，并将其加入到 <code>cpuset</code> 中某个 <code>CPU</code> 的就绪队列中。然后，调度器会选择一个合适的时机，将该线程从就绪队列中取出，并加载到目标 <code>CPU</code> 上执行。</p>
<p>因此接下来，由主线程创建具有<code>cpu</code>亲和性的线程就是使用的<code>pthread_setaffinity_np</code>。具体流程如下</p>
<p>在 <code>rte_eal_init</code>函数中我们找到了这样一段比较重要的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">RTE_LCORE_FOREACH_WORKER(i) &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * create communication pipes between main thread</span></span><br><span class="line"><span class="comment">		 * and children</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (pipe(lcore_config[i].pipe_main2worker) &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pipe(lcore_config[i].pipe_worker2main) &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		lcore_config[i].state = WAIT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* create a thread for each lcore */</span></span><br><span class="line">		ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>,</span><br><span class="line">				     eal_thread_loop, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Set thread_name for aid in debugging. */</span></span><br><span class="line">		<span class="built_in">snprintf</span>(thread_name, <span class="keyword">sizeof</span>(thread_name),</span><br><span class="line">			<span class="string">&quot;lcore-worker-%d&quot;</span>, i);</span><br><span class="line">		ret = rte_thread_setname(lcore_config[i].thread_id,</span><br><span class="line">						thread_name);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			RTE_LOG(DEBUG, EAL,</span><br><span class="line">				<span class="string">&quot;Cannot set name for lcore thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ret = pthread_setaffinity_np(lcore_config[i].thread_id,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="type">rte_cpuset_t</span>), &amp;lcore_config[i].cpuset);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot set affinity\n&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>RTE_LCORE_FOREACH_WORKER(i)</code>的定义是</p>
<p>也就是找到所有供dpdk使用的逻辑线程。且不为主线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_LCORE_FOREACH_WORKER(i)					\</span></span><br><span class="line"><span class="meta">	for (i = rte_get_next_lcore(-1, 1, 0);				\</span></span><br><span class="line"><span class="meta">	     i &lt; RTE_MAX_LCORE;						\</span></span><br><span class="line"><span class="meta">	     i = rte_get_next_lcore(i, 1, 0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==》</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rte_get_next_lcore</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">int</span> skip_main, <span class="type">int</span> wrap)</span></span><br><span class="line">&#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">if</span> (wrap)</span><br><span class="line">		i %= RTE_MAX_LCORE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; RTE_MAX_LCORE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!rte_lcore_is_enabled(i) ||</span><br><span class="line">		    (skip_main &amp;&amp; (i == rte_get_main_lcore()))) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (wrap)</span><br><span class="line">				i %= RTE_MAX_LCORE;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==》</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_lcore_is_enabled</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> lcore_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> *<span class="title">cfg</span> =</span> rte_eal_get_configuration();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lcore_id &gt;= RTE_MAX_LCORE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> cfg-&gt;lcore_role[lcore_id] == ROLE_RTE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完for循环的是什么东西，再看看for循环里面的内容。首先创建两个通道，用来实现主线程和工作线程的通信。也就是说每个工作线程和主线程之间都有两个通信管道。管道创建之后，再用<code>lcore_config[i].thread_id</code>创建线程。最后线程的id号会赋给<code>lcore_config[i].thread_id</code>。也就是重点关注这两个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create a thread for each lcore */</span></span><br><span class="line">ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>,</span><br><span class="line">                     eal_thread_loop, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">ret = pthread_setaffinity_np(lcore_config[i].thread_id,</span><br><span class="line">                     <span class="keyword">sizeof</span>(<span class="type">rte_cpuset_t</span>), &amp;lcore_config[i].cpuset);</span><br></pre></td></tr></table></figure>
<p>也就是说用前者创建线程，用后者设置<code>cpu</code>亲和性。就通了。至此，总结一下环境抽象层初始化阶段对于<code>cpu</code>亲和性线程池的初始化以及绑定<code>cpu</code>工作。 首先初始化128个，逻辑核描述符，给这个描述符的<code>cpuset</code>进行初始化，后面依次分配。我们默认是一比一分配。也就是一个逻辑核对应一个<code>cpu</code>核。然后再用逻辑描述符的<code>thread_id</code>创建线程（调用<code>pthread_create</code>创建），并调用<code>pthread_setaffinity_np</code>进行线程与cpu核的绑定。绑定之后<code>task_struct</code>也就是PCB(<em>linux并不区分进程线程，所以调度都是以<code>task_struct</code>进行调度</em>)中的<code>cpus_allowed</code>只有一位会是1。</p>
<p><code>注：task_struct 中关于 CPU 集合的成员是 cpus_allowed，它是一个 cpumask_t 类型的变量，用于表示该任务可以运行在哪些 CPU 上。cpumask_t 是一个位图结构，每一位对应一个 CPU 编号，如果该位为 1，则表示该任务可以运行在该 CPU 上；如果为 0，则表示不能运行在该 CPU 上。</code></p>
<h3 id="3-线程池的工作模式"><a href="#3-线程池的工作模式" class="headerlink" title="3.线程池的工作模式"></a>3.线程池的工作模式</h3><p>之前我们创建线程池中的线程的时候，使用到的函数指针是<code>eal_thread_loop</code>，也就是我们的每个工作线程需要去处理的工作，我们看看到底是啥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main loop of threads */</span></span><br><span class="line">__rte_noreturn <span class="type">void</span> *</span><br><span class="line"><span class="title function_">eal_thread_loop</span><span class="params">(__rte_unused <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> n, ret;</span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line">	<span class="type">pthread_t</span> thread_id;</span><br><span class="line">	<span class="type">int</span> m2w, w2m;</span><br><span class="line">	<span class="type">char</span> cpuset[RTE_CPU_AFFINITY_STR_LEN];</span><br><span class="line"></span><br><span class="line">	thread_id = pthread_self();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve our lcore_id from the configuration structure */</span></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		<span class="keyword">if</span> (thread_id == lcore_config[lcore_id].thread_id)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (lcore_id == RTE_MAX_LCORE)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot retrieve lcore id\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	m2w = lcore_config[lcore_id].pipe_main2worker[<span class="number">0</span>];</span><br><span class="line">	w2m = lcore_config[lcore_id].pipe_worker2main[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	__rte_thread_init(lcore_id, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">	ret = eal_thread_dump_current_affinity(cpuset, <span class="keyword">sizeof</span>(cpuset));</span><br><span class="line">	RTE_LOG(DEBUG, EAL, <span class="string">&quot;lcore %u is ready (tid=%zx;cpuset=[%s%s])\n&quot;</span>,</span><br><span class="line">		lcore_id, (<span class="type">uintptr_t</span>)thread_id, cpuset, ret == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	rte_eal_trace_thread_lcore_ready(lcore_id, cpuset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read on our pipe to get commands */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">void</span> *fct_arg;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* wait command */</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			n = read(m2w, &amp;c, <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;cannot read on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		lcore_config[lcore_id].state = RUNNING;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* send ack */</span></span><br><span class="line">		n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (n == <span class="number">0</span> || (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR))</span><br><span class="line">			n = write(w2m, &amp;c, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;cannot write on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].f == <span class="literal">NULL</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;NULL function pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* call the function and store the return value */</span></span><br><span class="line">		fct_arg = lcore_config[lcore_id].arg;</span><br><span class="line">		ret = lcore_config[lcore_id].f(fct_arg);</span><br><span class="line">		lcore_config[lcore_id].ret = ret;</span><br><span class="line">		rte_wmb();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* when a service core returns, it should go directly to WAIT</span></span><br><span class="line"><span class="comment">		 * state, because the application will not lcore_wait() for it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].core_role == ROLE_SERVICE)</span><br><span class="line">			lcore_config[lcore_id].state = WAIT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			lcore_config[lcore_id].state = FINISHED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* never reached */</span></span><br><span class="line">	<span class="comment">/* pthread_exit(NULL); */</span></span><br><span class="line">	<span class="comment">/* return NULL; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-首先拿到自己对应的lcore-config"><a href="#3-1-首先拿到自己对应的lcore-config" class="headerlink" title="3.1 首先拿到自己对应的lcore_config"></a>3.1 首先拿到自己对应的lcore_config</h3><p>通过比对自身的<code>thread_id</code>和<code>lcore_config[lcore_id].thread_id</code>拿到对应的<code>lcore_config</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread_id = pthread_self();</span><br><span class="line"><span class="comment">/* retrieve our lcore_id from the configuration structure */</span></span><br><span class="line">RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">	<span class="keyword">if</span> (thread_id == lcore_config[lcore_id].thread_id)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-根据lcore-config做一些设置"><a href="#3-2-根据lcore-config做一些设置" class="headerlink" title="3.2 根据lcore_config做一些设置"></a>3.2 根据lcore_config做一些设置</h3><p>获取到属于自己的与主进程进行通信的管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m2w = lcore_config[lcore_id].pipe_main2worker[<span class="number">0</span>];</span><br><span class="line">w2m = lcore_config[lcore_id].pipe_worker2main[<span class="number">1</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-3-工作线程一直在做的事情"><a href="#3-3-工作线程一直在做的事情" class="headerlink" title="3.3 工作线程一直在做的事情"></a>3.3 工作线程一直在做的事情</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read on our pipe to get commands */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">void</span> *fct_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait command */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n = read(m2w, &amp;c, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        rte_panic(<span class="string">&quot;cannot read on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lcore_config[lcore_id].state = RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send ack */</span></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n == <span class="number">0</span> || (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR))</span><br><span class="line">        n = write(w2m, &amp;c, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        rte_panic(<span class="string">&quot;cannot write on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lcore_config[lcore_id].f == <span class="literal">NULL</span>)</span><br><span class="line">        rte_panic(<span class="string">&quot;NULL function pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call the function and store the return value */</span></span><br><span class="line">    fct_arg = lcore_config[lcore_id].arg;</span><br><span class="line">    ret = lcore_config[lcore_id].f(fct_arg);</span><br><span class="line">    lcore_config[lcore_id].ret = ret;</span><br><span class="line">    rte_wmb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* when a service core returns, it should go directly to WAIT</span></span><br><span class="line"><span class="comment">		 * state, because the application will not lcore_wait() for it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    <span class="keyword">if</span> (lcore_config[lcore_id].core_role == ROLE_SERVICE)</span><br><span class="line">        lcore_config[lcore_id].state = WAIT;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lcore_config[lcore_id].state = FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，一直阻塞，直到从管道内读到了主线程对自己发出的命令。状态由 <code>WAIT</code>切换为 <code>RUNNING</code>，然后发出相应表明自己收到了这个命令。一般收到命令的时候，<code>lcore_config</code> 的<code>f</code>与<code>arg</code>就已经被赋值完毕了。相当于是先得知要做的任务以及任务参数，然后在收到开始做的命令。</p>
<p>然后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* call the function and store the return value */</span></span><br><span class="line">fct_arg = lcore_config[lcore_id].arg;</span><br><span class="line">ret = lcore_config[lcore_id].f(fct_arg);</span><br><span class="line">lcore_config[lcore_id].ret = ret;</span><br></pre></td></tr></table></figure>
<p>调用这个函数，由于我们的项目function本身就自带一个死循环，只要程序执行就不会跳出，所以一旦一个线程分配了任务，就会把这个任务一直执行下去直到我们的项目程序停止。所以后面就没再看了。</p>
<h2 id="4-线程池初始化首尾"><a href="#4-线程池初始化首尾" class="headerlink" title="4. 线程池初始化首尾"></a>4. 线程池初始化首尾</h2><p>环境抽象层的初始化工作对于线程池的初始化工作进行到了最后的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> rte_eal_mp_remote_launch(sync_func, <span class="literal">NULL</span>, SKIP_MAIN);</span><br><span class="line"> rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以及这两个函数的定义</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_mp_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg,</span></span><br><span class="line"><span class="params">			 <span class="keyword">enum</span> <span class="type">rte_rmt_call_main_t</span> call_main)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lcore_id;</span><br><span class="line">	<span class="type">int</span> main_lcore = rte_get_main_lcore();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check state of lcores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].state != WAIT)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send messages to cores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		rte_eal_remote_launch(f, arg, lcore_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (call_main == CALL_MAIN) &#123;</span><br><span class="line">		lcore_config[main_lcore].ret = f(arg);</span><br><span class="line">		lcore_config[main_lcore].state = FINISHED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do a rte_eal_wait_lcore() for every lcore. The return values are</span></span><br><span class="line"><span class="comment"> * ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">rte_eal_mp_wait_lcore</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line"></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		rte_eal_wait_lcore(lcore_id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait until a lcore finished its job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_wait_lcore</span><span class="params">(<span class="type">unsigned</span> worker_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lcore_config[worker_id].state == WAIT)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (lcore_config[worker_id].state != WAIT &amp;&amp;</span><br><span class="line">	       lcore_config[worker_id].state != FINISHED)</span><br><span class="line">		rte_pause();</span><br><span class="line"></span><br><span class="line">	rte_rmb();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we are in finished state, go to wait state */</span></span><br><span class="line">	lcore_config[worker_id].state = WAIT;</span><br><span class="line">	<span class="keyword">return</span> lcore_config[worker_id].ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-如何使用线程池中的线程"><a href="#5-如何使用线程池中的线程" class="headerlink" title="5.如何使用线程池中的线程"></a>5.如何使用线程池中的线程</h2><p>也就是如何通过主线程给工作线程分配任务呢？主要是通过下面的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Send a message to a worker lcore identified by worker_id to call a</span></span><br><span class="line"><span class="comment"> * function f with argument arg. Once the execution is done, the</span></span><br><span class="line"><span class="comment"> * remote lcore switch in FINISHED state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">int</span> worker_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m2w = lcore_config[worker_id].pipe_main2worker[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> w2m = lcore_config[worker_id].pipe_worker2main[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> rc = -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lcore_config[worker_id].state != WAIT)</span><br><span class="line">		<span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">	lcore_config[worker_id].f = f;</span><br><span class="line">	lcore_config[worker_id].arg = arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send message */</span></span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n == <span class="number">0</span> || (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR))</span><br><span class="line">		n = write(m2w, &amp;c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot write on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* wait ack */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		n = read(w2m, &amp;c, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot read on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">finish:</span><br><span class="line">	rte_eal_trace_thread_remote_launch(f, arg, worker_id, rc);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，给一个<code>lcore_config</code> 分配 <code>f</code>与 <code>arg</code>，再用过队列给他下达开始执行的命令就好了。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p><code>cpu</code>亲和性线程池实现的核心就是 <code>lcore_config</code>。它关联了 线程 ，cpu，任务。首先我们先用主线程<code>id</code>初始化<code>lcore_config</code>并绑定cpu核。我们默认cpu核心与线程是一比一绑定。所以<code>lcore_config</code>的索引就是我们要使用cpu的索引。</p>
<p> 通过主线程初始化指定个数的工作线程，</p>
<ul>
<li><p>首先就是要初始化对应个数的<code>lcore_config</code>，</p>
</li>
<li><p>然后在初始化亲和的<code>cpu</code>。一般用掩码表示，比如64位哪位为1，就代表64个cpu核心我用哪一个。就像我们刚才所讲的我们默认<code>cpu</code>核心与线程是一比一绑定。所以<code>lcore_config</code>的索引就是我们要使用<code>cpu</code>的索引。设置过后</p>
</li>
<li><p>通过调用 <code>pthread_create</code>  创建线程，线程跑的是 <code>eal_thread_loop</code>。</p>
</li>
<li><p>通过调用<code>pthread_setaffinity_np</code>进行亲和性<code>cpu</code>的绑定。</p>
</li>
<li><p>通过调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">rte_eal_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">int</span> worker_id)</span></span><br></pre></td></tr></table></figure>
<p>给线程发布任务。主要就是给<code>lcore_config</code>的<code>f</code>与<code>arg</code>通过消息队列告诉他，可以执行啦，他就去执行了，</p>
</li>
<li><p><code>eal_thread_loop</code>中就是首先根据自己的进程id找到对应的<code>lcore_config</code>。拿到这个就可以通过管道得知有任务交给我了。那么这个时候<code>lcore_config</code>的<code>f</code>与<code>arg</code>往往已经赋值好了，执行就完事儿了。</p>
</li>
</ul>
<p>实际上害有更新亲和性cpu的操作，但是基本用不到所以那块儿我就没看。</p>
<p>哇！！！终于走通了！！！好耶！！！！！！！！ 单纯使用的话，其实不需要搞懂这么多。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/12/6.%E6%96%87%E4%BB%B6I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/12/6.%E6%96%87%E4%BB%B6I-O/" itemprop="url">文件I/O</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-12T19:45:26+08:00">
                2022-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="标准c库IO函数"><a href="#标准c库IO函数" class="headerlink" title="标准c库IO函数"></a>标准c库IO函数</h2><p><img src="/images/6/1677755794700.png" alt="1677755794700"></p>
<h2 id="标准c库IO和linux系统IO的关系"><a href="#标准c库IO和linux系统IO的关系" class="headerlink" title="标准c库IO和linux系统IO的关系"></a>标准c库IO和linux系统IO的关系</h2><p><img src="/images/6/1677755995584.png" alt="1677755995584"></p>
<p>系统IO就是read write</p>
<h2 id="虚拟空间地址"><a href="#虚拟空间地址" class="headerlink" title="虚拟空间地址"></a>虚拟空间地址</h2><p><img src="/images/6/1677756149401.png" alt="1677756149401"></p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><img src="/images/6/1677756495794.png" alt="1677756495794"></p>
<h2 id="linux系统IO函数（Linux系统API一般也称为系统调用）"><a href="#linux系统IO函数（Linux系统API一般也称为系统调用）" class="headerlink" title="linux系统IO函数（Linux系统API一般也称为系统调用）"></a>linux系统IO函数（Linux系统API一般也称为系统调用）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以使用man命令查看标准库函数的原型</span></span><br><span class="line">man open</span><br></pre></td></tr></table></figure>
<p>这里不打算详细分析源码，打算在日后学习linux内核的时候再看。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/10/02/5.%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/10/02/5.%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/" itemprop="url">静态库和动态库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-02T19:11:53+08:00">
                2022-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><h2 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h2><p>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、类、函数等<br>库是一种特殊的程序，编写库文件和编写一般的程序的区别不大，只是库文件不能单独运行。<br>库文件有两种，静态库和动态库(共享库) ，他们的<strong>区别是</strong></p>
<ul>
<li>​    静态库在程序的链接阶段就被复制到了程序中，</li>
<li>​    而动态库在链接阶段只是被记录的一些信息(如文件名)，而没有把动态库复制到程序中，而是在程序运行 阶段由系统动态加载到内存中供程序调用。</li>
</ul>
<p>库的好处：代码保密(c++程序即使被反编译也只能还原20%左右) 、方便部署和发布    </p>
<h2 id="静态库命名规则："><a href="#静态库命名规则：" class="headerlink" title="静态库命名规则："></a>静态库命名规则：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">linux：libxxx.a</span><br><span class="line">	lib:固定前缀</span><br><span class="line">	xxx:库的名字</span><br><span class="line">	 .a:固定后缀</span><br><span class="line">windows：libxxx.lib</span><br></pre></td></tr></table></figure>
<h2 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h2><p>​    gcc获得.o文件</p>
<p>​    将.o文件打包，使用ar工具（archive)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">r - 将文件插入备存文件中</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">c - 建立备存文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">s - 索引</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/5/1677754140889.png" alt="1677754140889"></p>
<p>库文件需要头文件配合一起使用，因为头文件知名库文件里实现的函数。</p>
<p>编译时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-I 头文件目录  -l库文件 -L库文件路径</span><br></pre></td></tr></table></figure>
<h2 id="动态库命名规则："><a href="#动态库命名规则：" class="headerlink" title="动态库命名规则："></a>动态库命名规则：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">linux：libxxx.so</span><br><span class="line">	lib:固定前缀</span><br><span class="line">	xxx:库的名字</span><br><span class="line">	.so:固定后缀</span><br><span class="line">	linux下动态库是一个可执行文件</span><br><span class="line">windows：libxxx.dll</span><br></pre></td></tr></table></figure>
<h2 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h2><p>​    gcc获得.o文件,得到和位置无关的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC a.c b.c</span><br><span class="line">gcc -share a.o b.o -o libxxx.so</span><br></pre></td></tr></table></figure>
<p>​    这里就不制作了 挺简单的。</p>
<h2 id="静态库和动态库的工作原理"><a href="#静态库和动态库的工作原理" class="headerlink" title="静态库和动态库的工作原理"></a>静态库和动态库的工作原理</h2><p>静态库:GCC进行链接时,会把静态库中的代码打包到可执行程序中</p>
<p>动态库:GCC进行链接时,动态库的代码不会被打包到可执行程序中 在程序启动之后，动态库会被动态加载到内存中。但是可以被多个程序共享（shared）</p>
<p>通过ldd(list dynamic dependcies)命令检查可执行文件动态库依赖关系 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd a.out</span><br></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><img src="/images/5/1677755090849.png" alt="1677755090849"></p>
<p><img src="/images/5/1677755114608.png" alt="1677755114608"></p>
<p><img src="/images/5/1677755128214.png" alt="1677755128214"></p>
<p><img src="/images/5/1677755166902.png" alt="1677755166902"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my_avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawnlake</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
