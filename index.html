<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="也许不会有人进来吧">
<meta property="og:url" content="http://hanze5.github.io/index.html">
<meta property="og:site_name" content="也许不会有人进来吧">
<meta property="og:locale">
<meta property="article:author" content="Dawnlake">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hanze5.github.io/"/>





  <title>也许不会有人进来吧</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">也许不会有人进来吧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2023/02/13/%E5%8A%9B%E6%89%A3%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/02/13/%E5%8A%9B%E6%89%A3%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" itemprop="url">力扣刷题经验教训（持续更新）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-02-13T09:10:30+08:00">
                2023-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Day-1："><a href="#Day-1：" class="headerlink" title="Day 1："></a>Day 1：</h1><ol>
<li><p>两个栈可以实现队列，一个队列就可实现一个栈。</p>
<p>两个栈实现队列的时候，只有在出队列时 ，如果 “出栈”栈为空，需要有  入栈栈到出栈栈的转移操作。</p>
<p>一个队列实现栈时，每次入栈都需要将队列进行“翻转”（重新全部入队列，最终将队尾移动到对头）。</p>
</li>
<li><p>遇到对时间复杂度有要求的就空间换时间。</p>
</li>
<li><p><strong>INT_MAX</strong> 可用来表示正无穷，<strong>INT_MIN</strong>表示负无穷。</p>
</li>
<li><p>倒序一个链表，优先想到栈（先入后出!）</p>
</li>
<li><p>判断链表有无环，快慢双指针。  画图能够迅速帮你找到解决思路！！！！杨老师！谢谢你  画图列方程</p>
</li>
<li><p>由于链表经常要用前一个值操作后一个值，所以经常要考虑边界值。</p>
</li>
<li><p>对于深度克隆，比如随机链表复制，无向图复制，要想到哈希表。</p>
</li>
</ol>
<h1 id="Day-2："><a href="#Day-2：" class="headerlink" title="Day 2："></a>Day 2：</h1><ol>
<li><strong>链表一定要考虑边界值啊！！</strong>第2次了。链表操作A-&gt;next的时候一定要考虑A是否为空；</li>
<li><strong>非递减数列</strong>两数求和，别想那么多，先给大窗口，然后缩小，</li>
<li>双指针，快慢双指针，左右双指针（中心扩张，两边收缩）</li>
<li>如果有正负的情况，千万不要自作从聪明，将某个值设为0，不然比大小时候会出现bug。</li>
<li>如果说写出的代码分为好多种情况，那么思路一定是错了。</li>
<li>树的层序遍历需要用到队列。当需要记录层数时，需要用到额外的变量，并用到for循环</li>
<li>动态规划问题的第一个性质：<strong>重叠子问题</strong> 。 设置备忘录。一般是哈希表。数组也可以。如果可以看出数组长度不会超过某个最大值，就可以用数组。但这是个稀疏数组。</li>
</ol>
<h1 id="Day-3："><a href="#Day-3：" class="headerlink" title="Day 3："></a>Day 3：</h1><ol>
<li><p><strong>回溯代码框架</strong>，设最后返回的集合是res，res里面的元素是方案（路径）,路径中为节点，第一步我们要搞清，方案是什么，路径是什么，节点又是什么。（比如n皇后问题，方案是整个棋盘，选择是在第row行选择第col个点）所以backtrace的参数就是（棋盘，row）</p>
</li>
<li><p>回溯算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(状态参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(设置结束条件)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(路径)；</span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//排除不合法选择 </span></span><br><span class="line">        <span class="keyword">if</span>(！is_valid（)）</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        选择();</span><br><span class="line">        进入下一层</span><br><span class="line">        退选择</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p>
</li>
<li><p>组合问题，给定数组自带顺序，且答案中[1,2] [2,1]算是相同结果的，甚至可以不用is_valid;因为仔细想一下，比如选择到2，那么1 一定选过了  ，3一定没选过。（自行理解其中奥义很简单）。</p>
</li>
<li><p>求 有重复数据的子集 要先排序。然后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为和上一个相同的话， 下一个back_trace(nums,k,i+1)会得到相同的结果</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) </span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    subresult.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">back_trace</span>(nums,k,i+<span class="number">1</span>);</span><br><span class="line">    subresult.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BFS:  将问题抽象为一幅图  ，  找到节点 ，以及节点的邻居。那么算法的流程就是从初始节点开始。比如开密码锁，每个节点就是 密码锁当前的数字，那么邻居就是，转动一位得到的数字。</p>
</li>
</ol>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4 :"></a>Day 4 :</h1><ol>
<li>搞不定边界就尽量不要使用双重二分。</li>
<li><strong>检查是不是break和continue 用混了！！！！</strong></li>
<li>动态寻找最大值最小值的时候要初始化一个结果！不能只声明。</li>
<li>集合之间对比，要想到unordered_map</li>
</ol>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5:"></a>Day 5:</h1><ol>
<li>股票问题因为给的数组不是有序的，所以不能使用双指针法。</li>
<li>动态规划超出时间限制就要反思是否有重叠子问题，设置备忘录解决。</li>
<li>自顶向下的动归是递归，有可能会遇到重复子问题，自底向上的动归是迭代，但是空间复杂度高一点。</li>
<li>如果动态规划的开始和末尾相互影响。就要分出情况。</li>
<li>vector.end() 并不是最后一个元素的指针 而是最后一个元素的下一个指针</li>
<li>回溯法毕竟是穷举，拥有极高的时间复杂度。如果有其他解法尽量不要用穷举。</li>
<li>不该超出时间限制的时候超出时间限制，检查起始条件 ，终止条件，以及变化条件。</li>
</ol>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><ol>
<li>使用双指针时要确保指针移动啊。</li>
<li>差分数组要多一位（其实也没必要，得看情况）。</li>
</ol>
<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><ol>
<li>二分搜索时候左右边界问题别搞错了啊。 左边界查看left==num.size()  右边界查看left-1&lt;0;</li>
<li>二分搜索如果没找到不返回特殊值的话，左右边界还是很好写的。</li>
<li>转换思路才能二分搜索。比如给定天数，让你求运输船最小承载。这个不好算，那就转换成给出承载，返回最小天数。这就可以用二分了。这个转变思路非常巧妙。</li>
<li>无论是升序降序  左边界返回left 右边界返回left-1；</li>
</ol>
<h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><ol>
<li>vector erase和遍历数组没有区别，时间复杂度很高。易超出时间限制</li>
<li>排序的  比较函数  大于为真是降序  小于为真是升序</li>
<li>unordered_set 是不支持随机存取的。所以要用unordered_map 与 vector实现随机读取；</li>
<li>要分清出<strong>子序列</strong>与<strong>子串</strong>的区别，字串必须连续，子序列不必连续；</li>
<li>都tm什么时候了还在 犯”=” 和 “==”的错误。现在还非常容易犯小错误</li>
</ol>
<h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><ol>
<li>树的遍历中，如果遍历结果包含着空指针，那么不需要有别的遍历辅助，也能够确定一棵树。</li>
<li><strong>stoi()</strong>可以把字符串转化成为数字。  <strong>to_string</strong> 可以将数字转化为字符串</li>
<li>可以用  map用于关联字符串与节点, set用于检测字符串重复。</li>
</ol>
<h1 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h1><ol>
<li>涉及到区间和  那就一定会有前缀和数组！！  而对区间进行统一操作，那就一定会有差分数组？</li>
<li>归并排序的一个重要思想，凡是已经在同一部分里的，就一定发生过关系了。只有和另一部分的没有发生过关系。<strong>（非常重要的思想）</strong></li>
<li>而且如果无序很难，但是发现有序很好做，那么可以去想想归并排序，  或者看到题目中有 数组的性质是， 当i&lt;j  </li>
<li>前缀和 要思考 有没有</li>
<li>BST 的中序遍历结果是有序的（升序）。  可以说遇到二叉搜索树，大概率是中序遍历</li>
</ol>
<h1 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h1><ol>
<li><p>快速排序是 树的前序遍历     归并排序是树的后序遍历</p>
</li>
<li><p>快速排序为了达到稳定的快速，数组要是乱序。函数shuffle() 可以随机打乱</p>
</li>
<li><p>快速排序中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(cur&lt;=right &amp;&amp; nums[cur]&gt;=nums[p]) cur++;<span class="comment">//自己体会</span></span><br><span class="line"> <span class="comment">//而且需要特殊的交换操作</span></span><br><span class="line"><span class="built_in">swap</span>(nums[p],nums[cur]);  </span><br><span class="line"><span class="built_in">swap</span>(nums[p+<span class="number">1</span>],nums[cur])；<span class="comment">// 交换后这</span></span><br><span class="line">p+=<span class="number">1</span>;</span><br><span class="line">cur = p+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>srand(time(0)); 生成随机树种子</p>
</li>
<li><p>堆是完全二叉树 ，然后再满足父节点大于等于 或小于等于子节点。所以插入的时候，先插入满足完全二叉树的位置，在满足第二个要求。删除的时候 先交换 再下降。</p>
</li>
<li><p><strong>完全二叉树用数组实现非常方便</strong>。  节点 i 的左子节点  2i  右子节点2i+1</p>
</li>
<li><p>优先级队列定义比较函数必须是静态成员函数的？</p>
</li>
<li><p><strong>判断完全二叉树是否是满二叉树</strong>，左节点一直找下去，右节点一直找下去，看看高度是否相同。</p>
</li>
<li><p>if 后面如果不是一句话 一定不要忘了加花括号啊</p>
</li>
</ol>
<h1 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h1><ol>
<li><p>图结构表示方法，如果目的不是要迅速判断两节点之间是否有边，那还是使用邻接表方便一点。</p>
</li>
<li><p>拓扑排序 需要额外的数组记录节点的入度；</p>
</li>
<li><p>int 类型的0   1  可以用逻辑运算符操作。</p>
</li>
<li><p>连通性使用 并查集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">       		 parent[x] = <span class="built_in">find_root</span>(parent[x]);</span><br><span class="line">    	&#125;    </span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通 联通分量等于节点数</span></span><br><span class="line">        count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        <span class="comment">//尺寸全部初始化为1</span></span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find_root</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find_root</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将两棵树合并为一棵 以下二者选一即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 两个分量合二为一</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getcount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find_root</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find_root</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并查集可以建立虚拟头部，从而排除异己。</p>
</li>
<li><p>在二位坐标中控制方向常用方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125; <span class="comment">//对应下 右 上 左</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类的后面要加；</p>
</li>
<li><p>只有判断无向图是否带环时才能用并查集。</p>
</li>
<li><p>克鲁斯卡尔算法 Kruskal 算法  就是无向有权图 按权重大小一次加边；</p>
</li>
<li><p>并查集的时间复杂度是0(1);</p>
</li>
<li><p>无向有权图的最小生成树算法 prim算法需要转换成图的邻接表格式。 Kruskal 不用 ，给的如果是边的集合 就krusal 如果是 graph prim。</p>
</li>
</ol>
<h1 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h1><ol>
<li>dijkstra 算法： 优先级队列里存放边   因为这样可以通过边的权重来知晓</li>
</ol>
<h1 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a>Day 14</h1><ol>
<li><p>前缀树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//力扣667</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TrieNode *&gt; next;</span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="number">26</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            next[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode * root;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MapSum</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> delta = val;</span><br><span class="line">        <span class="comment">//如果之前存在 算出两数值差好做修改</span></span><br><span class="line">        <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            delta -= cnt[key];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[key] = val;</span><br><span class="line">        </span><br><span class="line">        TrieNode * node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            node-&gt;val += delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode * node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>真不能上来直接写，一定要先想好各种情况。</p>
</li>
</ol>
<h1 id="Day-15"><a href="#Day-15" class="headerlink" title="Day 15"></a>Day 15</h1><ol>
<li><p>优先级队列设置升序降序，less代表降序 ，greater代表升序</p>
</li>
<li><p>单调栈，要把它想象成，个子高挡住个子矮的。从一个方向上望过去，是单调递增做递减的。</p>
</li>
<li><p>单调栈不一定存放数值，也可以存放索引，反正可以通过索引来找值。</p>
</li>
<li><p>for循环一定要检查是i++ 还是 i—</p>
</li>
<li><p>单调栈 找比自己大的  那栈顶就是栈里最小的。好好理解一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//力扣503</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到第一个大于自己的元素 </span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>()&lt;=nums[i%n]) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//没找到  那自己就是最大的</span></span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) result[i%n] = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//找到了保存结果 </span></span><br><span class="line">            <span class="keyword">else</span> result[i%n] = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">//把自己放进去</span></span><br><span class="line">            st.<span class="built_in">push</span>( nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/06/12/20-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E8%87%AA%E6%97%8B%E9%94%81-spinlock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/12/20-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E8%87%AA%E6%97%8B%E9%94%81-spinlock/" itemprop="url">Linux内核——自旋锁 spinlock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-06-12T16:55:19+08:00">
                2022-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<p>与之前学的信号量相比，自旋锁是一种死等的机制。而信号量不会。只有一个执行单元获取锁并进入到临界区，其他的都给我死等。可以在中断上下文执行，因为是不睡眠的。中断上下文代码不允许睡眠，也不允许调用那些可能会引起睡眠的函数。这种死等的实现是不同的架构有不一样的方法。</p>
<h2 id="自旋锁的实现"><a href="#自旋锁的实现" class="headerlink" title="自旋锁的实现"></a>自旋锁的实现</h2><ol>
<li><p>查看结构体定义struct spinlock (/include/linux/spinlock_types.h)<img src="/images/20/1678091181583.png" alt="1678091181583"></p>
<p>然后再去看看，raw_spinlock</p>
<p><img src="/images/20/1678091233794.png" alt="1678091233794"></p>
<p>然后再去看看arch_spinlock_t!!!!然后发现这东西的定义适合cpu架构相关的，多层封装是为了增加灵活性。。以arm为例：</p>
<p>路径（/arch/arm/include/asm/spinlock_types.h）</p>
<p><img src="/images/20/1678091414902.png" alt="1678091414902"></p>
<p>其中owner表示持有这个数字的thread可以获取自旋锁，next表示如果后续有thread请求获取这个自旋锁，给他分配这个数字。</p>
</li>
<li><p>自旋锁的初始化  按照上述所说就是把那两个东西置为0，对spinlock的初始化一层层再找到arm里的初始化实现，就长这样<img src="/images/20/1678091817407.png" alt="1678091817407"></p>
</li>
<li><p>基本所有实现都是spin—&gt;raw_spin-&gt;arch_spin. 由不同的架构去实现，实现的逻辑就是。</p>
<ul>
<li>刚开始owner=next=0;</li>
<li>第一个thread获取spinlock，可获取成功，此时owner==0,next=0;</li>
<li>第二个thread获取spinlock,如果第一个thread还没有释放spinlock，则next++, next变为1;</li>
<li>第三个thread获取spinlock,如果第一个thread还没有释放spinlock，则next++, next变为2;<br>此时第一个thread释放spinlock，则执行ownerowner=1;</li>
<li>虽然此时第二个thread和第三个thread都在等待spinlock,但是因为第二个thread的next=owner,所以第二个thread可以获取到spinlock，第三个thread则继续等待。这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒，保证了公平性。</li>
</ul>
</li>
<li><p>另外，还有一种自旋锁叫做读写自旋锁。读写自旋锁可以让多个读一起读，但是经常让写死等。</p>
</li>
</ol>
<h2 id="自旋锁的使用"><a href="#自旋锁的使用" class="headerlink" title="自旋锁的使用"></a>自旋锁的使用</h2><p>继续修改我们的hello驱动。</p>
<ol>
<li><p>首先定义自旋锁与临界资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> count_lock;</span><br><span class="line"><span class="type">int</span> open_count=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在hello_init中进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自旋锁初始化</span></span><br><span class="line">spin_lock_init(&amp;count_lock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>open与close操作中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;count_lock);</span><br><span class="line">    <span class="keyword">if</span>(!open_count&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        spin_enlock(&amp;count_lock);</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    open_count++;</span><br><span class="line">    spin_lock(&amp;count_lock);</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!open_count!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    spin_enlock(&amp;count_lock);</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之前也说过了自旋锁的特性，尽量要让临界区执行的快一点。不然cpu会经常死等。</p>
<p>结果和信号量结果相同。因为从应用程序来看确实本质区别也不大。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/06/12/19-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/12/19-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" itemprop="url">Linux内核——原子操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-06-12T15:52:23+08:00">
                2022-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>对原子变量的访问是源自的，linux内核自带的源子变量结构体定义如下（/include/linux/types.h）：</p>
<p><img src="/images/19/1678087835689.png" alt="1678087835689"></p>
<p>竟然就是一个整型么!</p>
<p>对于原子变量的初始化<code>ATOMIC_INIT</code>不同体系架构都不一样。</p>
<h2 id="原子变量的应用"><a href="#原子变量的应用" class="headerlink" title="原子变量的应用"></a>原子变量的应用</h2><p>同样，继续修改helloDev.c。</p>
<ol>
<li><p>定义原子变量并初始化为1，之前的信号量和opencount不要了，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct semaphore sema;</span></span><br><span class="line"> <span class="comment">// int open_count=0;</span></span><br><span class="line"> <span class="type">static</span> <span class="type">atomic_t</span> can_open = ATOMIC_INIT(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>open操作改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!atomic_dec_and_test(&amp;can_open))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        automic_inc(&amp;can_open);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>atomic_dec_and_test</code> 和 <code>automic_inc</code> 这两个里面的操作不同的体系架构有着不一样的实现。以arm架构为例：全是汇编。。。。。 </p>
<p><img src="/images/19/1678088566696.png" alt="1678088566696"></p>
<p>用宏定义去实现，嵌入汇编指令的操作。之前写过mips的汇编。现在忘的有点多。</p>
<p>反正就是汇编语言实现了对原子变量的加减操作。如果是单核的话可以使用开关中断来保证原子操作</p>
</li>
<li><p>close操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    automic_inc(&amp;can_open);</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>本篇的收获仅仅是原子变量的使用吧，初始化，然后加减操作。。至于怎么实现，也就大概那么回事。。。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/06/06/18-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/06/18-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F/" itemprop="url">Linux内核——信号量semaphore</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-06-06T15:15:49+08:00">
                2022-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索 <strong>简说linux</strong></p>
<h2 id="多进程访问驱动设备带来的问题"><a href="#多进程访问驱动设备带来的问题" class="headerlink" title="多进程访问驱动设备带来的问题"></a>多进程访问驱动设备带来的问题</h2><p>在驱动程序中，有些设备只允许打开一次。那么可以在驱动中定义一个全局变量，判断当前使用数目。比如在某驱动程序的<strong>open函数</strong>中这样定义。当count==0说明没有使用，可以打开。理想状态下是左边的情况，但是cpu对进程的调度是随机的，所以不可避免的发生右边的情况。就会打开多次。</p>
<!-- ![1678081076781](/images/18/1678081076781.png) | ![1678081150110](/images/18/1678081150110.png)

 -->
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="/images/18/1678081076781.png" alt="1678081076781"></th>
<th><img src="/images/18/1678081150110.png" alt="1678081150110"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>为什么没有count—的操作？因为这是驱动的open函数。—肯定是在close函数里边。</p>
<p>老生常谈，并发执行的单元（这里不说进程是因为还有线程，但是他们的问题是一样的）对共享资源（例子里面是count）的访问会引发竞争。访问共享资源的代码区叫做<code>临界区</code>，临界区需要某种内核同步方法来保护。</p>
<h2 id="内核同步机制——信号量源码"><a href="#内核同步机制——信号量源码" class="headerlink" title="内核同步机制——信号量源码"></a>内核同步机制——信号量源码</h2><ol>
<li><p>struct semaphore 结构体定义</p>
<p>内核中信号量通过这样一的结构体<code>struct semaphore</code>来定义，定位到内核源码<code>/include/linux/semaphone.h</code>文件。可以查看到<code>struct semaphore</code>的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Please don&#x27;t access any members of this structure directly */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;      <span class="comment">//说明是以另一种同步机制自旋锁来实现的</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		count;     <span class="comment">//用以表示资源数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span>  <span class="comment">//双向链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/18/1678084503728.png" alt="1678084503728"></p>
</li>
<li><p>初始化函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)				\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\</span></span><br><span class="line"><span class="meta">	.count		= n,						\</span></span><br><span class="line"><span class="meta">	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SEMAPHORE(name)	\</span></span><br><span class="line"><span class="meta">	struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">	*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/18/1678084786042.png" alt="1678084786042"></p>
</li>
<li><p>down操作，就是使用这个信号量资源。定义在内核源码根目录下的/kernel/locking/semaphore.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * down - acquire the semaphore</span></span><br><span class="line"><span class="comment"> * @sem: the semaphore to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Acquires the semaphore.  If no more tasks are allowed to acquire the</span></span><br><span class="line"><span class="comment"> * semaphore, calling this function will put the task to sleep until the</span></span><br><span class="line"><span class="comment"> * semaphore is released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use of this function is deprecated, please use down_interruptible() or</span></span><br><span class="line"><span class="comment"> * down_killable() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">		sem-&gt;count--;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__down(sem);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(down);</span><br></pre></td></tr></table></figure>
<p><img src="/images/18/1678085608439.png" alt="1678085608439"></p>
<p>相当于又用自旋锁，保护了自身的count这个资源是互斥访问的。但是这里代码简单说明具体的实现不在这里</p>
<p>那么一步步ctrl+左键，找到了</p>
</li>
</ol>
<p>   <img src="/images/18/1678085781987.png" alt="1678085781987"></p>
<p>   系统中每个进程都会有一个task结构体，就像有一个pid一样与之相对应。当有进程使用了down之后，该进程的task就会被加入到信号量的wait_list里面。然后就会将自己设为睡眠状态，让cpu去执行其他进程。自旋锁是非常耗费cpu资源的，所以他保护的临界区资源不能睡眠。所以可以看到timeuot那句没有被保护。与cpu调度相关的，后面说。</p>
<p>   当自己醒了之后再次查看自己申请的资源是不是可以访问了，不行就继续睡，行了就返回，跳出down。</p>
<ol>
<li><p>up操作，对临界资源访问结束，释放信号量和down长得差不多，直接找核心的。<img src="/images/18/1678086270368.png" alt="1678086270368"></p>
<p>很好理解  如果信号量资源够了，那么就唤醒进程。</p>
</li>
</ol>
<h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>​    在之前的hellodev驱动中，我们做这样的修改。</p>
<ol>
<li><p>首先定义全局变量，信号量和一个整型用于计数。整型这里就是共享资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema</span>；</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">open_count</span>=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>驱动的初始代码中对信号量进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量的初始化  初始化为1 表明共享资源只有一个</span></span><br><span class="line">sema_init(&amp;sema,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>是临界区代码，开始时down获取信号量，结束时up释放信号量。第一个进程获取到所之后，第二个进程再次访问就会被阻塞，因为他发现这个信号量的值不再是1，而是0；能保证临界代码的访问是原子的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;sema);</span><br><span class="line">    <span class="keyword">if</span>(open_count&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        up(&amp;sema);</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    open_count++;</span><br><span class="line">    up(&amp;sema);</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式可以保证，这部分区域的访问是原子的。如果说临界区的资源不是很复杂，那么建议还是使用原子变量，而不是使用信号量。下次说</p>
</li>
<li><p>相应的，在推出对驱动的访问时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(open_count!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO<span class="string">&quot;something wrong,hello_close fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    open_count--;</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们是没定义这个函数的，所以要在init的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gFile-&gt;release = hello_close;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol>
<li><p>测试程序中加入sleep() 使其打开驱动程序的时间长一点。</p>
</li>
<li><p>首先打开执行第一个进程<img src="/images/18/1678084102081.png" alt="1678084102081"></p>
<p>可以看到写入成功并没有直接推出，与此同时我们新建一个终端在运行一次，<img src="/images/18/1678084174458.png" alt="1678084174458"></p>
<p>Nice！！！！！！！</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>信号量用于线程和进程之间的同步</li>
<li>允许多个进程进入临界区代码执行</li>
<li>进程获取不到信号量锁会陷入休眠，具体的进程相关姐都体task（代表当前。）会加入到信号量结构体维护的一个链表，并且进入休眠（cpu调度）。</li>
<li>被信号量保护的临界区允许睡眠，但是信号量的实现中 自旋锁维护的临界区是不允许休眠的。</li>
<li>基于进程调度器实现，UP和SMP无差异</li>
<li><strong>不支持进程和中断之间的同步</strong>  需要用到自旋锁。</li>
</ol>
<h2 id="helloDev驱动已经更新了多次，再次附目前为止的完整代码"><a href="#helloDev驱动已经更新了多次，再次附目前为止的完整代码" class="headerlink" title="helloDev驱动已经更新了多次，再次附目前为止的完整代码"></a>helloDev驱动已经更新了多次，再次附目前为止的完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//helloDev.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_MAX    (64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK            (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR         (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">gDev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">gFile</span>;</span></span><br><span class="line"><span class="type">dev_t</span>  devNum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> subDevNum = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> reg_major  =  <span class="number">232</span>;    </span><br><span class="line"><span class="type">int</span> reg_minor =   <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buffer[BUFFER_MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema</span>;</span></span><br><span class="line"><span class="type">int</span> open_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;sema);</span><br><span class="line">    <span class="keyword">if</span>(open_count&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        up(&amp;sema);</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;device is busy,helloopen fall!!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">    &#125;</span><br><span class="line">    open_count++;</span><br><span class="line">    up(&amp;sema);</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open ok~~~\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_close</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(open_count!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO<span class="string">&quot;something wrong,hello_close fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    open_count--;</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;hello_close ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">const</span> <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_write\r\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> writenlen = <span class="number">0</span>;</span><br><span class="line">    writenlen = BUFFER_MAX&gt;s?s:BUFFER_MAX;</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(buffer,u,writenlen))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writenlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_read\r\n&quot;</span>);    </span><br><span class="line">    <span class="type">int</span> readlen;</span><br><span class="line">    readlen = BUFFER_MAX&gt;s?s:BUFFER_MAX;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(u,buffer,readlen))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据主次设备号生成一个devnum 主次设备号可以唯一标识</span></span><br><span class="line">    devNum = MKDEV(reg_major, reg_minor);</span><br><span class="line">    <span class="comment">//将设备号注册到内核 </span></span><br><span class="line">    <span class="keyword">if</span>(OK == register_chrdev_region(devNum, subDevNum, <span class="string">&quot;helloworld&quot;</span>))&#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;register_chrdev_region ok \n&quot;</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;register_chrdev_region error n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot; hello driver init \n&quot;</span>);</span><br><span class="line">    <span class="comment">// struct cdev 是内核中的字符设备</span></span><br><span class="line">    gDev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">    <span class="comment">//初始化一个file结构体 代表设备</span></span><br><span class="line">    gFile = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> file_operations), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给file结构体中的函数操作赋值   右侧是函数指针 指明操作</span></span><br><span class="line">    gFile-&gt;open = hello_open;</span><br><span class="line">    gFile-&gt;read = hello_read;</span><br><span class="line">    gFile-&gt;write = hello_write;</span><br><span class="line"></span><br><span class="line">    gFile-&gt;owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    gFile-&gt;release = hello_close;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核中找到设备号 就能找到cdev 与 file_operations</span></span><br><span class="line">    <span class="comment">//建立gDev 与 gFile之间的联系 里边没看但是肯定有两个之间的互动就是了</span></span><br><span class="line">    cdev_init(gDev, gFile);</span><br><span class="line">    <span class="comment">//又建立了gDev 与 设备号的联系</span></span><br><span class="line">    cdev_add(gDev, devNum, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号量的初始化  初始化为1 表明共享资源只有一个</span></span><br><span class="line">    sema_init(&amp;sema,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动的卸载</span></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(gDev);</span><br><span class="line">    unregister_chrdev_region(devNum, subDevNum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Makefile</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">	obj-m := helloDev.o                        </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">	<span class="comment"># KDIR:= /lib/modules/4.4.0-31-generic/build</span></span><br><span class="line">	<span class="comment"># KDIR:=/home/dawnlake/Downloads/linux-4.9.229</span></span><br><span class="line">KDIR := /lib/modules/`uname -r`/build</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span></span><br><span class="line">	gcc -g read_test.c -o read_test</span><br><span class="line">	gcc -g write_test.c -o write_test</span><br><span class="line">	rmmod helloDev</span><br><span class="line">	insmod helloDev.ko</span><br><span class="line"><span class="section">clean:	</span></span><br><span class="line">	rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_NUM    (32)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    <span class="type">int</span>  w_len;</span><br><span class="line">    fd_set fdset;</span><br><span class="line">    <span class="type">char</span> buf[DATA_NUM]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// memset(buf,0,DATA_NUM);</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd) &#123;</span><br><span class="line">      	perror(<span class="string">&quot;open file error\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open successe\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    w_len = write(fd,buf, DATA_NUM);</span><br><span class="line">    <span class="comment">// r_len = read(fd, buf, DATA_NUM);</span></span><br><span class="line">    <span class="keyword">if</span>(w_len==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;w_len = %d \r\n&quot;</span>, w_len);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_NUM    (64)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    <span class="type">int</span> r_len;</span><br><span class="line">    fd_set fdset;</span><br><span class="line">    <span class="type">char</span> rbuf[DATA_NUM];</span><br><span class="line">    <span class="built_in">memset</span>(rbuf,<span class="number">0</span>,DATA_NUM);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd) &#123;</span><br><span class="line">      	perror(<span class="string">&quot;open file error\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open successe\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// w_len = write(fd,buf, DATA_NUM);</span></span><br><span class="line">    r_len = read(fd, rbuf, DATA_NUM);</span><br><span class="line">    <span class="keyword">if</span>(r_len==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;readlen = %d \r\n&quot;</span>,  r_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,rbuf);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/06/03/17-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/03/17-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D/" itemprop="url">Linux内核——内核空间与用户空间的数据拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-06-03T13:22:25+08:00">
                2022-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟着简叔学的，可以B站搜索简说linux</p>
<h2 id="1-32位系统内核空间和用户空间的默认大小"><a href="#1-32位系统内核空间和用户空间的默认大小" class="headerlink" title="1.32位系统内核空间和用户空间的默认大小"></a>1.32位系统内核空间和用户空间的默认大小</h2><p><img src="/images/17/1678066147846.png" alt="1678066147846"></p>
<p>内核空间运行在高地址空间，用户空间在低地址空间。之所以要做这样的划分。出于安全考量，内核需要更高的权限，已屏蔽用户区的不安全操作。从软件设计思想来开，内核代码偏重于系统管理；用户空间的代码偏重于业务逻辑代码的实现。  注意这只是逻辑地址，并不是物理地址。这中间有一个映射的过程。</p>
<p>陷入内核态一般有三种情况：</p>
<p>​    <strong>系统调用，定时器中断，外设中断</strong>  处理完中断再返回用户空间的应用程序</p>
<h2 id="2-x86段页式内存管理荷叶表映射机制"><a href="#2-x86段页式内存管理荷叶表映射机制" class="headerlink" title="2.x86段页式内存管理荷叶表映射机制"></a>2.x86段页式内存管理荷叶表映射机制</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv8129309?spm_id_from=333.999.0.0">linux内核页表映射机制：线性地址如何转为物理地址？ - 哔哩哔哩 (bilibili.com)</a></p>
<p>两步走，逻辑地址转化成线性地址，再转化成物理地址。部分架构逻辑地址就是线性地址，基址+offset 找到线性地址空间，通过把基址设为0来实现。那么从线性地址转化成逻辑地址就是我们说的页表映射。。</p>
<p><img src="/images/17/1678079204392.png" alt="1678079204392"></p>
<p>不同进程有不同的页目录表，所以他们可以不冲突的访问相同的逻辑地址（在他们各自的视角里），因为他们的页目录表不一样。  线性地址 总共32位（页表目录索引找到页表10位，页表索引找到物理地址基址10位，偏移12位）</p>
<h2 id="3-对之前写的hello驱动的读写函数进行简单修改"><a href="#3-对之前写的hello驱动的读写函数进行简单修改" class="headerlink" title="3.对之前写的hello驱动的读写函数进行简单修改"></a>3.对之前写的hello驱动的读写函数进行简单修改</h2><ol>
<li><p>代码改动如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">const</span> <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_write\r\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> writenlen = <span class="number">0</span>;</span><br><span class="line">    writenlen = BUFFER_MAX&gt;s?s:BUFFER_MAX;</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(buffer,u,writenlen))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writelen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_read\r\n&quot;</span>);    </span><br><span class="line">    <span class="type">int</span> readlen;</span><br><span class="line">    readlen = BUFFER_MAX&gt;s?s:BUFFER_MAX;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(u,buffer,readlen))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>copy_from_user</code>与<code>copy_to_user</code>实现了用户空间和内核空间的数据拷贝。驱动程序肯定是在内核空间 <code>const char __user *u</code>则是用户空间的地址。所以看起来可能是反的，因为以前我们的视角是用户程序在用户空间。而且要注意，<code>copy_from_user</code>与<code>copy_to_user</code>他们的参数顺序哦。</p>
<p>重新对驱动代码进行编译，插入。然后编译测试代码，进行测试，产生了段错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">open successe</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>写入操作发生段错误,经过检查发现，原来驱动代码中，定义了内核空间的buffer指针，却没有开辟空间。</p>
<p>将</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * buffer；</span><br></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[BUFFER_MAX];</span><br></pre></td></tr></table></figure>
<p>重新测试。</p>
<p><img src="/images/17/1678070706739.png" alt="1678070706739"></p>
<p>发现success拼写错了，无伤大雅无伤大雅。。。。。</p>
<p>代码表示两个用户程序，读写内核空间数据。</p>
</li>
</ol>
<p><img src="/images/17/1678070706739.png" alt="1678070706739">|<img src="/images/17/1678070706739.png" alt="1678070706739"><br>—- | —-</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/06/02/16-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%B0%86%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/02/16-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%B0%86%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E6%A0%91/" itemprop="url">Linux内核——如何将驱动代码添加到内核源码树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-06-02T09:24:42+08:00">
                2022-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="以字符设备驱动为例"><a href="#以字符设备驱动为例" class="headerlink" title="以字符设备驱动为例"></a>以字符设备驱动为例</h1><ol>
<li><p>首先，把.c文件拷贝到/driver/char中要修改源码给目录下的/driver/char中的Kconfig文件，这样才能在编译内核时看到我们驱动的配置选单，参考其他的config 有样学样</p>
<p><img src="/images/16/1678061581009.png" alt="1678061581009"></p>
<p>tristate字段说明 该驱动有三个选项 y m n 。 y代表编译到内核里面，m是编程驱动.ko n是不编译。</p>
</li>
<li><p>接下来到内核源码根目录下执行，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/dawnlake/Downloads/linux-4.9.229$ make memuconfig</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <img src="/images/16/1678061753376.png" alt="1678061753376"></p>
<p>   <img src="/images/16/1678061802952.png" alt="1678061802952"></p>
<p>   <img src="/images/16/1678061851658.png" alt="1678061851658"></p>
<p>   查看help</p>
<p>   <img src="/images/16/1678061906964.png" alt="1678061906964"></p>
<ol>
<li><p>接下来需要修改/drivers/char目录下的makefile文件 </p>
<p><img src="/images/16/1678065704335.png" alt="1678065704335"></p>
</li>
</ol>
<ol>
<li><p>然后再回到内核源码根目录下执行，make</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/linux-4.9.229$ make</span><br><span class="line">scripts/kconfig/conf  --silentoldconfig Kconfig</span><br><span class="line">  CHK     include/config/kernel.release</span><br><span class="line">  CHK     include/generated/uapi/linux/version.h</span><br><span class="line">  CHK     include/generated/utsrelease.h</span><br><span class="line">  CHK     include/generated/bounds.h</span><br><span class="line">  CHK     include/generated/timeconst.h</span><br><span class="line">  CHK     include/generated/asm-offsets.h</span><br><span class="line">  CALL    scripts/checksyscalls.sh</span><br><span class="line">  CHK     scripts/mod/devicetable-offsets.h</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  CC      drivers/char/helloDev.o</span><br><span class="line">  LD      drivers/char/built-in.o</span><br><span class="line">  LD      drivers/built-in.o</span><br><span class="line">  LD      vmlinux.o</span><br><span class="line">  MODPOST vmlinux.o</span><br><span class="line">  GEN     .version</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  UPD     include/generated/compile.h</span><br><span class="line">  CC      init/version.o</span><br><span class="line">  LD      init/built-in.o</span><br><span class="line">  KSYM    .tmp_kallsyms1.o</span><br><span class="line">  KSYM    .tmp_kallsyms2.o</span><br><span class="line">  LD      vmlinux</span><br><span class="line">  SORTEX  vmlinux</span><br><span class="line">  SYSMAP  System.map</span><br><span class="line">  VOFFSET arch/x86/boot/compressed/../voffset.h</span><br><span class="line">  CC      arch/x86/boot/compressed/misc.o</span><br><span class="line">  OBJCOPY arch/x86/boot/compressed/vmlinux.bin</span><br><span class="line">  GZIP    arch/x86/boot/compressed/vmlinux.bin.gz</span><br><span class="line">  MKPIGGY arch/x86/boot/compressed/piggy.S</span><br><span class="line">  AS      arch/x86/boot/compressed/piggy.o</span><br><span class="line">  LD      arch/x86/boot/compressed/vmlinux</span><br><span class="line">ld: arch/x86/boot/compressed/head_64.o: warning: relocation in read-only section `.head.text&#x27;</span><br><span class="line">ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">  ZOFFSET arch/x86/boot/zoffset.h</span><br><span class="line">  AS      arch/x86/boot/header.o</span><br><span class="line">  CC      arch/x86/boot/version.o</span><br><span class="line">  LD      arch/x86/boot/setup.elf</span><br><span class="line">  OBJCOPY arch/x86/boot/setup.bin</span><br><span class="line">  OBJCOPY arch/x86/boot/vmlinux.bin</span><br><span class="line">  BUILD   arch/x86/boot/bzImage</span><br><span class="line">Setup is 15580 bytes (padded to 15872 bytes).</span><br><span class="line">System is 6681 kB</span><br><span class="line">CRC 959cc45</span><br><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#2)</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 18 modules</span><br></pre></td></tr></table></figure>
<p>现在内核启动时候就会自动加载我们的hello驱动，如果在menuconfig设置m而不是y（*） ，就会只生成.ko文件而不是直接加载，需要手动插入。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/05/23/15-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E7%BC%96%E5%86%99%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/23/15-Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94%E7%BC%96%E5%86%99%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop="url">Linux内核——编写最简单的字符设备驱动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-05-23T21:54:41+08:00">
                2022-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考链接：<a target="_blank" rel="noopener" href="https://www.toutiao.com/article/6848065724905161228/?tt_from=mobile_qq&amp;utm_campaign=client_share&amp;timestamp=1597801678&amp;app=news_article&amp;utm_source=mobile_qq&amp;utm_medium=toutiao_android&amp;use_new_style=1&amp;req_id=202008190947570100140471952C5FB432&amp;group_id=6848065724905161228&amp;wid=1678007899106">linux驱动开发第1讲：带你编写一个最简单的字符设备驱动-今日头条 (toutiao.com)</a></p>
<h1 id="驱动内容"><a href="#驱动内容" class="headerlink" title="驱动内容"></a>驱动内容</h1><ol>
<li><p>首先，驱动文件与一般的c文件不同，他有着自己独有的入口函数与出口函数，通过一下方式定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module_init(hello_init); <span class="comment">//入口函数 </span></span><br><span class="line">module_exit(hello_exit); <span class="comment">//出口函数 </span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);   <span class="comment">//版权</span></span><br></pre></td></tr></table></figure>
<p>入口函数会在插入驱动<code>insmod</code>时执行，出口函数会在<code>rmmod</code>时执行。</p>
</li>
<li><p>接下来看看，入口函数，出口函数也就是驱动插入删除时要做的事情。</p>
<p><strong>入口函数 hello_init 。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据主次设备号生成一个devnum 主次设备号可以唯一标识</span></span><br><span class="line">    devNum = MKDEV(reg_major, reg_minor);</span><br><span class="line">    <span class="comment">//将设备号注册到内核 </span></span><br><span class="line">    <span class="keyword">if</span>(OK == register_chrdev_region(devNum, subDevNum, <span class="string">&quot;helloworld&quot;</span>))&#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;register_chrdev_region ok \n&quot;</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;register_chrdev_region error n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot; hello driver init \n&quot;</span>);</span><br><span class="line">    <span class="comment">// struct cdev 是内核中的字符设备</span></span><br><span class="line">    gDev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">    <span class="comment">//初始化一个file结构体 代表设备</span></span><br><span class="line">    gFile = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> file_operations), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给file结构体中的函数操作赋值   右侧是函数指针 指明操作</span></span><br><span class="line">    gFile-&gt;open = hello_open;</span><br><span class="line">    gFile-&gt;read = hello_read;</span><br><span class="line">    gFile-&gt;write = hello_write;</span><br><span class="line">    gFile-&gt;owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核中找到设备号 就能找到cdev 与 file_operations</span></span><br><span class="line">    <span class="comment">//建立gDev 与 gFile之间的联系 cdev的成员</span></span><br><span class="line">    cdev_init(gDev, gFile);</span><br><span class="line">    <span class="comment">//又建立了gDev 与 设备号的联系</span></span><br><span class="line">    cdev_add(gDev, devNum, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <img src="/images/15/1678012806064.png" alt="1678012806064"><img src="/images/15/1678012844545.png" alt="1678012844545"></p>
<p>总结下来，设备插入时要完成的核心功能：</p>
<ul>
<li>用设备的主设备号和次设备号去生成一个驱动ID方便程序调用与给驱动划分归类，暂且认为是这个作用。</li>
<li>然后申请两块地址用于初始化两个构造体，一个构造体代表设备，一个构造体代表函数操作。内核操作设备实际上就是像操作文件一样。所以从上图<code>function_operation</code>结构体的定义可以看出有很多成员是函数指针。到时候就是要把设备要做的操作赋给这些函数指针。</li>
<li>然后看到设备字符型<code>cDev</code>的定义中有一个成员是<code>function_operation</code>。所以接下来通过 <code>cdev_init(gDev, gFile)</code>建立起二者的联系，然后再通过<code>cdev_add(gDev, devNum, 3)</code>，让<code>devNum</code>也就是第一步获得的驱动ID也与cDev建立其联系</li>
</ul>
<p>至此，驱动初始化工作完成。这也是<code>insmod</code>命令执行时候要做的工作。</p>
<p>对文件描述符的读写操作，最终会操作到一个叫做file的结构体上，这个结构体似乎和dev是一个东西。</p>
<p><strong>出口函数hello_exit</strong> 很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//驱动的卸载</span></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(gDev);</span><br><span class="line">    unregister_chrdev_region(devNum, subDevNum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后简单定义驱动的一些功能也就是<code>function_operation</code>的成员将要被赋值的函数指针的函数的定义，就是一些简单的打印：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">const</span> <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_write\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_read\r\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让我们看看makefile文件都做了什么：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m := helloDev.o                        </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KDIR := /lib/modules/`uname -r`/build</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span></span><br><span class="line"><span class="section">clean:	</span></span><br><span class="line">	rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量 KERNELRELEASE  由内核定义</span></span><br></pre></td></tr></table></figure>
<p>首先，有一个寻找环境变量的判断语句，如果没找到的话，就会去到内核的根目录下执行内核的Makefile。这是因为驱动也需要链接c运行时库和glibc库，但是驱动不能链接和使用应用层的任何lib库，驱动需要引用内核的头文件和函数。所以，编译的时候需要指定内核源码的地址。这里我想在自己的环境里做实验比较方便，所以就把内核源码根目录设置为了本机内核源码的根目录。执行过后环境变量中便有了<code>KERNELRELEASE</code>。其实当前内核是否编译成功正常工作。,内核的编译系统会将所有的obj-m变量中的.o文件链接成为.ko文件,如果是obj-y 就编译内核里面。这就是驱动文件的生成。</p>
</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li><p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$ make</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=/home/dawnlake/Downloads/hellodev</span><br><span class="line">make[1]: Entering directory &#x27;/usr/src/linux-headers-5.19.0-35-generic&#x27;</span><br><span class="line">warning: the compiler differs from the one used to build the kernel</span><br><span class="line">  The kernel was built by: x86_64-linux-gnu-gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0</span><br><span class="line">  You are using:           gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0</span><br><span class="line">  CC [M]  /home/dawnlake/Downloads/hellodev/helloDev.o</span><br><span class="line">  MODPOST /home/dawnlake/Downloads/hellodev/Module.symvers</span><br><span class="line">  CC [M]  /home/dawnlake/Downloads/hellodev/helloDev.mod.o</span><br><span class="line">  LD [M]  /home/dawnlake/Downloads/hellodev/helloDev.ko</span><br><span class="line">  BTF [M] /home/dawnlake/Downloads/hellodev/helloDev.ko</span><br><span class="line">Skipping BTF generation for /home/dawnlake/Downloads/hellodev/helloDev.ko due to unavailability of vmlinux</span><br><span class="line">make[1]: Leaving directory &#x27;/usr/src/linux-headers-5.19.0-35-generic&#x27;</span><br><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev# ls</span><br><span class="line">helloDev.c  helloDev.ko  helloDev.mod  helloDev.mod.c  helloDev.mod.o  helloDev.o  Makefile  modules.order  Module.symvers  test.c</span><br></pre></td></tr></table></figure>
<p>可以看到先编译到<code>helloDev.mod.o</code>，再链接到<code>helloDev.ko</code></p>
</li>
<li><p>检查驱动的插入删除操作，<code>dmesg -c</code>清除内核日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$ insmod helloDev.ko </span><br><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$ dmesg -c</span><br><span class="line">[20663.380995] register_chrdev_region ok </span><br><span class="line">[20663.381004]  hello driver init </span><br><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$ lsmod | grep hell</span><br><span class="line">helloDev               16384  0</span><br><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$ rmmod helloDev</span><br><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$ lsmod | grep hell</span><br><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$</span><br></pre></td></tr></table></figure>
<p>看看就能懂。</p>
</li>
<li><p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_NUM    (64)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    <span class="type">int</span> r_len, w_len;</span><br><span class="line">    fd_set fdset;</span><br><span class="line">    <span class="type">char</span> buf[DATA_NUM]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,DATA_NUM);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd) &#123;</span><br><span class="line">      	perror(<span class="string">&quot;open file error\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open successe\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    w_len = write(fd,buf, DATA_NUM);</span><br><span class="line">    r_len = read(fd, buf, DATA_NUM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\r\n&quot;</span>, w_len, r_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之前需要还需要创建hello驱动的设备文件，创建设备文件，不然会显示打不开</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/hellodev$ ./a.out </span><br><span class="line">-1</span><br><span class="line">open file error</span><br><span class="line">: No such device or address</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/hello c 232 0</span><br></pre></td></tr></table></figure>
<p>这里的232和0要跟驱动文件里定义的主次设备号对应起来！</p>
<p><img src="/images/15/1678022494911.png" alt="1678022494911"></p>
</li>
</ol>
<p>​        分析：</p>
<p>​        正常应用里面的read write函数是c库里面的函数，这两个函数的实现使用了系统调用。由应用层产生中断，陷入到内核里面，系统调用执行响相应动作，再把返回值返回给应用层用户空间。</p>
<p>​        </p>
<p>​    然后再次执行dmesg查看驱动输出，发现驱动里的hell_open, hello_write, hello_read被依次调用了。</p>
<p>​   <img src="/images/15/1678022546541.png" alt="1678022546541"></p>
<pre><code>忽略两次初始化。。。。。。
</code></pre><h2 id="添加到内核源码树"><a href="#添加到内核源码树" class="headerlink" title="添加到内核源码树"></a>添加到内核源码树</h2><pre><code>字符型设备放在 /driver/char 里头
</code></pre><h1 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a><strong>完整代码：</strong></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//helloDev.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_MAX    (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK            (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR         (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">gDev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">gFile</span>;</span></span><br><span class="line"><span class="type">dev_t</span>  devNum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> subDevNum = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> reg_major  =  <span class="number">232</span>;    </span><br><span class="line"><span class="type">int</span> reg_minor =   <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *p, <span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_write</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">const</span> <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_write\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_read</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">char</span> __user *u, <span class="type">size_t</span> s, <span class="type">loff_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_read\r\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据主次设备号生成一个devnum 主次设备号可以唯一标识</span></span><br><span class="line">    devNum = MKDEV(reg_major, reg_minor);</span><br><span class="line">    <span class="comment">//将设备号注册到内核 </span></span><br><span class="line">    <span class="keyword">if</span>(OK == register_chrdev_region(devNum, subDevNum, <span class="string">&quot;helloworld&quot;</span>))&#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;register_chrdev_region ok \n&quot;</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;register_chrdev_region error n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot; hello driver init \n&quot;</span>);</span><br><span class="line">    <span class="comment">// struct cdev 是内核中的字符设备</span></span><br><span class="line">    gDev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">    <span class="comment">//初始化一个file结构体 代表设备</span></span><br><span class="line">    gFile = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> file_operations), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给file结构体中的函数操作赋值   右侧是函数指针 指明操作</span></span><br><span class="line">    gFile-&gt;open = hello_open;</span><br><span class="line">    gFile-&gt;read = hello_read;</span><br><span class="line">    gFile-&gt;write = hello_write;</span><br><span class="line">    gFile-&gt;owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核中找到设备号 就能找到cdev 与 file_operations</span></span><br><span class="line">    <span class="comment">//建立gDev 与 gFile之间的联系 里边没看但是肯定有两个之间的互动就是了</span></span><br><span class="line">    cdev_init(gDev, gFile);</span><br><span class="line">    <span class="comment">//又建立了gDev 与 设备号的联系</span></span><br><span class="line">    cdev_add(gDev, devNum, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//驱动的卸载</span></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(gDev);</span><br><span class="line">    unregister_chrdev_region(devNum, subDevNum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##Makefile</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m := helloDev.o                        </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="comment"># KDIR:= /lib/modules/4.4.0-31-generic/build</span></span><br><span class="line"><span class="comment"># KDIR:=/home/dawnlake/Downloads/linux-4.9.229</span></span><br><span class="line">KDIR := /lib/modules/`uname -r`/build</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span></span><br><span class="line"><span class="section">clean:	</span></span><br><span class="line">	rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_NUM    (64)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    <span class="type">int</span> r_len, w_len;</span><br><span class="line">    fd_set fdset;</span><br><span class="line">    <span class="type">char</span> buf[DATA_NUM]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,DATA_NUM);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd) &#123;</span><br><span class="line">      	perror(<span class="string">&quot;open file error\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open successe\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    w_len = write(fd,buf, DATA_NUM);</span><br><span class="line">    r_len = read(fd, buf, DATA_NUM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\r\n&quot;</span>, w_len, r_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/05/21/14.Linux%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E4%B8%8Ebusybox%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BD%BF%E7%94%A8qemu%E5%90%AF%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/21/14.Linux%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E4%B8%8Ebusybox%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BD%BF%E7%94%A8qemu%E5%90%AF%E5%8A%A8/" itemprop="url">Linux内核——编译内核与busybox文件系统并使用qemu启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-05-21T16:49:43+08:00">
                2022-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/song_lee/article/details/105815237">https://blog.csdn.net/song_lee/article/details/105815237</a></p>
<p>参考连接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv11271232?spm_id_from=333.999.0.0">从源码编译linux-4.9内核并运行一个最小的busybox文件系统（最新整理版） - 哔哩哔哩 (bilibili.com)</a></p>
<h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><ul>
<li><p>实验环境</p>
<ul>
<li>vmware 16 pro</li>
<li>ubuntu 22.04</li>
</ul>
</li>
<li><p>首先需要确认CPU是支持虚拟化的</p>
<ul>
<li>```shell<br>dawnlake@dawnlake-virtual-machine:~$ lsmod | grep kvm<br>kvm_intel             434176  0<br>kvm                  1130496  1 kvm_intel<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - vmware可以通过编辑虚拟机设置来开启处理器的虚拟化功能![1677995747801](/images/14/1677995747801.png)</span><br><span class="line"></span><br><span class="line">- 下载配置内核所需要的依赖</span><br><span class="line"></span><br><span class="line">  ```shell</span><br><span class="line">  sudo apt-get install ncurses-dev libncurses-dev flex bison bc</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>安装交叉编译工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里先使用Ubuntu自带的qemu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br><span class="line">sudo apt install qemu-system-x86 </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-下载linux内核源码"><a href="#2-下载linux内核源码" class="headerlink" title="2.下载linux内核源码"></a>2.下载linux内核源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.9.229.tar.xz  </span><br></pre></td></tr></table></figure>
<p>太慢了，直接浏览器下完用vscode往上传的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dawnlake@dawnlake-virtual-machine:~/Downloads$ ls</span><br><span class="line">linux-4.9.229  linux-4.9.229.tar.xz</span><br></pre></td></tr></table></figure>
<p><img src="/images/14/1677997900172.png" alt="1677997900172"></p>
<ul>
<li>arch 目录， 和具体cpu有关的代码，例如arm/mach-omap1，即ti公司的soc，此soc的cpu核是ARM提供</li>
<li>init目录， 内核启动代码。对应到应用层就是main，内核里最早的目录是内核的解压程序，先执行汇编代码让cpu做一些初始化。 初始化完成之后会执行这个目录里的main。</li>
<li>drivers目录，驱动框架代码，例如i2c，dma， leds 鼠标 键盘 反正就是各种驱动。做驱动开发的可以关注一下。</li>
<li>fs目录，文件系统 </li>
<li>kernel目录，进程调度进程管理等等  注意和arm/kernel目录的区别。 kernel目录会调用arm/kernel。</li>
<li>net目录， 网络协议</li>
<li>include目录</li>
<li>mm目录 内存相关</li>
</ul>
<h2 id="3-编译内核"><a href="#3-编译内核" class="headerlink" title="3.编译内核"></a>3.编译内核</h2><p>下列命令要在管理员权限下执行，root用户可以不用加sudo</p>
<ol>
<li><p>指定硬件体系架构 ， 因为开发环境是x86，要编译arm内核就需要指定ARCH=arm且需要安装交叉编译器。 前面已经装好。这只是个临时的环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo export ARCH=x86 </span><br></pre></td></tr></table></figure>
</li>
<li><p>配置board config,此处配置为 x86_64_defconfig。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo make  x86_64_defconfig </span><br><span class="line"></span><br><span class="line">root@dawnlake-virtual-machine:/home/dawnlake/Downloads/linux-4.9.229# make  x86_64_defconfig </span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  HOSTCC  scripts/kconfig/conf.o</span><br><span class="line">  SHIPPED scripts/kconfig/zconf.tab.c</span><br><span class="line">  SHIPPED scripts/kconfig/zconf.lex.c</span><br><span class="line">  SHIPPED scripts/kconfig/zconf.hash.c</span><br><span class="line">  HOSTCC  scripts/kconfig/zconf.tab.o</span><br><span class="line">  HOSTLD  scripts/kconfig/conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># configuration written to .config</span></span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置内核，针对性配置，和实验不想关的就不做配置，避免内核臃肿。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p><img src="/images/14/1678000057028.png" alt="1678000057028"></p>
<p>进来之后，（[*]代表要选中哈）</p>
<ul>
<li>General setup   —-&gt;   <ul>
<li>[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support  </li>
</ul>
</li>
<li>Device Drivers  —-&gt;     <ul>
<li>[*] Block devices  —-&gt;   </li>
<li><img src="/images/14/1678000486617.png" alt="1678000486617"><ul>
<li><img src="/images/14/1678000467715.png" alt="1678000467715"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作时候一看就懂不解释了。</p>
</li>
<li><p>然后执行make编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>执行完毕后结果显示（找得到的），</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure>
<p>这就是编译好的内核。</p>
</li>
</ol>
<h2 id="4-编译文件系统-busybox"><a href="#4-编译文件系统-busybox" class="headerlink" title="4.编译文件系统 busybox"></a>4.编译文件系统 busybox</h2><h3 id="BusyBox-The-Swiss-Army-Knife-of-Embedded-Linux"><a href="#BusyBox-The-Swiss-Army-Knife-of-Embedded-Linux" class="headerlink" title="BusyBox: The Swiss Army Knife of Embedded Linux"></a>BusyBox: The Swiss Army Knife of Embedded Linux</h3><ul>
<li><p>BusyBox combines tiny versions of many common UNIX utilities into a single small executable. It provides replacements for most of the utilities you usually find in GNU fileutils, shellutils, etc. The utilities in BusyBox generally have fewer options than their full-featured GNU cousins; however, the options that are included provide the expected functionality and behave very much like their GNU counterparts. BusyBox provides a fairly complete environment for any small or embedded system.</p>
</li>
<li><p>BusyBox has been written with size-optimization and limited resources in mind. It is also extremely modular so you can easily include or exclude commands (or features) at compile time. This makes it easy to customize your embedded systems. To create a working system, just add some device nodes in /dev, a few configuration files in /etc, and a Linux kernel.</p>
</li>
</ul>
<ol>
<li><p>下载busybox 地址<a target="_blank" rel="noopener" href="https://busybox.net/downloads/">Index of /downloads (busybox.net)</a> 版本： 1.30.0  并解压 报错  建议下载更新版本的&gt;=1.36.0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf busybox-1.30.0.tar.bz2 </span><br></pre></td></tr></table></figure>
<p>然后进入到目录下</p>
</li>
<li><p>配置buysbox源码 </p>
<p>在这里我们把busybox配置为静态编译，这样busybox在运行的时候就不需要额外的动态链接库了。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig </span><br><span class="line"></span><br><span class="line">Settings  ---&gt;</span><br><span class="line">      Build Options  ---&gt;</span><br><span class="line">            [*] Build BusyBox as a static binary (no shared libs) </span><br></pre></td></tr></table></figure>
<p>操作时候就能看懂</p>
</li>
<li><p>然后编译安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install </span><br><span class="line">=======================================================================</span><br><span class="line">/usr/bin/ld: libbb/lib.a(inet_common.o): in function `INET6_resolve&#x27;:</span><br><span class="line">inet_common.c:(.text.INET6_resolve+0x4a): warning: Using &#x27;getaddrinfo&#x27; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</span><br><span class="line">/usr/bin/ld: coreutils/lib.a(mktemp.o): in function `mktemp_main&#x27;:</span><br><span class="line">mktemp.c:(.text.mktemp_main+0x98): warning: the use of `mktemp&#x27; is dangerous, better use `mkstemp&#x27; or `mkdtemp&#x27;</span><br><span class="line">/usr/bin/ld: networking/lib.a(ipcalc.o): in function `ipcalc_main&#x27;:</span><br><span class="line">ipcalc.c:(.text.ipcalc_main+0x231): warning: Using &#x27;gethostbyaddr&#x27; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</span><br><span class="line">/usr/bin/ld: libbb/lib.a(inet_common.o): in function `INET_resolve&#x27;:</span><br><span class="line">inet_common.c:(.text.INET_resolve+0x4d): warning: Using &#x27;gethostbyname&#x27; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</span><br><span class="line">/usr/bin/ld: networking/lib.a(inetd.o): in function `reread_config_file&#x27;:</span><br><span class="line">inetd.c:(.text.reread_config_file+0x254): warning: Using &#x27;getservbyname&#x27; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</span><br><span class="line">/usr/bin/ld: networking/lib.a(netstat.o): in function `ip_port_str&#x27;:</span><br><span class="line">netstat.c:(.text.ip_port_str+0x50): warning: Using &#x27;getservbyport&#x27; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</span><br><span class="line">/usr/bin/ld: util-linux/lib.a(rdate.o): in function `rdate_main&#x27;:</span><br><span class="line">rdate.c:(.text.rdate_main+0xff): undefined reference to `stime&#x27;</span><br><span class="line">/usr/bin/ld: coreutils/lib.a(date.o): in function `date_main&#x27;:</span><br><span class="line">date.c:(.text.date_main+0x25b): undefined reference to `stime&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">Note: if build needs additional libraries, put them in CONFIG_EXTRA_LDLIBS.</span><br><span class="line">Example: CONFIG_EXTRA_LDLIBS=&quot;pthread dl tirpc audit pam&quot;</span><br><span class="line">make: *** [Makefile:718: busybox_unstripped] Error 1</span><br></pre></td></tr></table></figure>
<p>解决方案：换更高版本的busybox</p>
<p>如果是老版本的ubuntu应该是不会报错，如果报错要么降低ubuntu版本，要么升级busybox版本。</p>
<p>重新执行上述步骤，安装成功<img src="/images/14/1678002515221.png" alt="1678002515221"></p>
<p>目前还不是完整的文件系统，还待完善，无法直接使用。现在只是目录，内核识别的是文件系统。内核启动需要consle打印信息，但是这里面连dev都没有，所以也不存在什么设备文件。</p>
</li>
<li><p>进入_install目录，补充一些必要的文件或目录，相关的shell命令如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一下三个目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> etc dev mnt</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">虚拟文件系统  虚拟文件系统 临时文件系统</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p proc sys tmp</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">里面存放文件系统启动的脚本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p etc/init.d/</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建并且存放文件系统挂载信息 文件系统启动时会在这个文件中读取挂载信息 将这些文件系统挂载起来</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim etc/fstab</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件系统     挂载路径</span></span><br><span class="line">proc        /proc           proc         defaults        0        0</span><br><span class="line">tmpfs       /tmp            tmpfs    　　defaults        0        0</span><br><span class="line">sysfs       /sys            sysfs        defaults        0        0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">busybox启动时执行的代码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim etc/init.d/rcS</span></span><br><span class="line"></span><br><span class="line">echo -e &quot;Welcome to tinyLinux&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。</span></span><br><span class="line">/bin/mount -a    #把上面的该挂载的挂载 </span><br><span class="line">echo -e &quot;Remounting the root filesystem&quot;</span><br><span class="line">mount  -o  remount,rw  /   #把根文件系统重新挂载以此设置成可读可写</span><br><span class="line">mkdir -p /dev/pts          </span><br><span class="line">mount -t devpts devpts /dev/pts  #用来挂载文件系统 -t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。</span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug   #用来处理热插拔</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mdev是busybox提供的一个工具，用在嵌入式系统中，相当于简化版的udev，作用是在系统启动和热插拔或动态加载驱动程序时，</span></span><br><span class="line">mdev -s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 755 etc/init.d/rcS</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">busybox执行的文件  一般的linux文件系统没有</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim etc/inittab</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 755 etc/inittab</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建设备节点</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> dev</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c表示字符型设备   5 主设备号 1 次设备号</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mknod</span> console c 5 1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mknod</span> null c 1 3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mknod</span> tty1 c 4 1</span> </span><br></pre></td></tr></table></figure>
<p><strong>至此完整的文件系统制作完成</strong></p>
</li>
</ol>
<h2 id="5-制作跟文件系统镜像"><a href="#5-制作跟文件系统镜像" class="headerlink" title="5.制作跟文件系统镜像"></a>5.制作跟文件系统镜像</h2><ol>
<li><p>先制作一个空的镜像文件；</p>
</li>
<li><p>然后把此镜像文件格式化为ext3格式；</p>
</li>
<li><p>然后把此镜像文件挂载，并把根文件系统复制到挂载目录；</p>
</li>
<li><p>卸载该镜像文件。</p>
</li>
<li><p>打成gzip包。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf rootfs.ext3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf fs</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">dd</span>命令 可以创建一个空的镜像文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./rootfs.ext3 bs=1M count=32</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式化为ext3的格式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.ext3 rootfs.ext3</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将该镜像文件挂载到fs这样一个临时的目录下</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> fs</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount -o loop rootfs.ext3 ./fs</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后把刚才./_install/* 也就是文件系统的东西 拷贝到 fs里 就相当于放到刚才的镜像里边了</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -rf ./_install/* ./fs</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">释放挂载点</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">umount ./fs</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打包成内核能识别的压缩模式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip --best -c rootfs.ext3 &gt; rootfs.img.gz</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是重要的步骤成功时的输出</p>
<p><img src="/images/14/1678005089603.png" alt="1678005089603"></p>
<p><img src="/images/14/1678005190545.png" alt="1678005190545"></p>
</li>
</ol>
<h2 id="6-qemu启动内核与文件系统"><a href="#6-qemu启动内核与文件系统" class="headerlink" title="6.qemu启动内核与文件系统"></a>6.qemu启动内核与文件系统</h2><p>​    参数说明：</p>
<ul>
<li>-kernel 编译好的内核镜像</li>
<li>-initrd 编译好的文件系统镜像</li>
<li>-append  “init” 表示内核在启动之后转交给文件系统执行的第一个程序</li>
<li>-serial输出日志</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">qemu-system-x86_64 \</span></span><br><span class="line"><span class="language-bash">    -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage  \ </span> </span><br><span class="line">    -initrd ./busybox-1.36.0/rootfs.img.gz   \</span><br><span class="line">    -append &quot;root=/dev/ram init=/linuxrc&quot;  \</span><br><span class="line">    -serial file:output.txt </span><br></pre></td></tr></table></figure>
<p><strong><em>注意：要在图形界面下执行！</em></strong>而且执行目录是<code>linux-4.9.229</code>所在的目录。</p>
<p>很快啊！！！！</p>
<p><img src="/images/14/1678006002978.png" alt="1678006002978"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/01/21/11-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94http%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/21/11-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94http%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/" itemprop="url">11.C++实战——Http业务逻辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-21T20:18:14+08:00">
                2022-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>书接上文，这里是http处理业务请求的具体逻辑内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    request_.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="comment">//没有数据可读直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_))  <span class="comment">//请求解析成功后 初始化相应</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//400代表解析不成功</span></span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//创造相应</span></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_);</span><br><span class="line">    <span class="comment">/* 响应头 */</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">    iovCnt_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件 */</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;</span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析http请求的逻辑"><a href="#解析http请求的逻辑" class="headerlink" title="解析http请求的逻辑"></a>解析http请求的逻辑</h2><p>下面简单分析，对http请求的解析的逻辑。</p>
<p><img src="/images/11/1677937698830.png" alt="1677937698830"></p>
<p>从http的请求报文的格式可看出，可以分为三个部分，<strong>请求首行</strong>、<strong>请求头部</strong>、<strong>请求数据</strong> 也叫<strong>请求体（body）</strong>，http解析也以此划分阶段。当解析数据还有剩余，会依据当前状态解析相应的部分。如：<code>ParseRequestLine_()</code>、<code>ParseHeader_()</code>、<code>ParseBody_</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> CRLF[] = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还有数据且状态不为解析完毕则不会跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_ != FINISH) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* lineEnd = <span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), CRLF, CRLF + <span class="number">2</span>);</span><br><span class="line">        <span class="function">std::string <span class="title">line</span><span class="params">(buff.Peek(), lineEnd)</span></span>;</span><br><span class="line">        <span class="keyword">switch</span>(state_)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_LINE:</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">ParseRequestLine_</span>(line)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ParsePath_</span>();</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> HEADERS:</span><br><span class="line">            <span class="built_in">ParseHeader_</span>(line);</span><br><span class="line">            <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                state_ = FINISH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BODY:</span><br><span class="line">            <span class="built_in">ParseBody_</span>(line);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lineEnd == buff.<span class="built_in">BeginWrite</span>()) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        buff.<span class="built_in">RetrieveUntil</span>(lineEnd + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(), version_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建响应的逻辑"><a href="#创建响应的逻辑" class="headerlink" title="创建响应的逻辑"></a>创建响应的逻辑</h3><p>同样，当请求的资源存在，可以响应时，也依次此创建响应。</p>
<p><img src="/images/11/1677939294522.png" alt="1677939294522"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 判断请求的资源文件 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> || <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;</span><br><span class="line">        code_ = <span class="number">404</span>; <span class="comment">//访问的是目录不是具体资源？？？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;</span><br><span class="line">        code_ = <span class="number">403</span>;   <span class="comment">//权限不够</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(code_ == <span class="number">-1</span>) &#123; </span><br><span class="line">        code_ = <span class="number">200</span>;   <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();         <span class="comment">//提醒错误的网页</span></span><br><span class="line">    <span class="built_in">AddStateLine_</span>(buff);  <span class="comment">//创建响应首行</span></span><br><span class="line">    <span class="built_in">AddHeader_</span>(buff);     <span class="comment">//创建响应头部</span></span><br><span class="line">    <span class="built_in">AddContent_</span>(buff);     <span class="comment">//创建内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
      
      
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanze5.github.io/2022/01/19/10-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也许不会有人进来吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/19/10-C-%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url">10.C++实战——高并发服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-19T21:34:35+08:00">
                2022-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" itemprop="url" rel="index">
                    <span itemprop="name">学无止境</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章代码来源:<a target="_blank" rel="noopener" href="https://github.com/gaojingcome/WebServer">高并发Web服务器</a></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>服务器的工作实际上就是监听并且处理各种各样的事件。当服务器处于启动状态，就会不断用Epoll去监听，正在被监听的文件描述符事件。根据返回值和事件类型做出相应的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isClose_) &#123;</span><br><span class="line">	<span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   	timeMS = timer_-&gt;<span class="built_in">GetNextTick</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//一直使用 epoller_-&gt;Wait 去检测事件 返回值 有多少个</span></span><br><span class="line">   <span class="type">int</span> eventCnt = epoller_-&gt;<span class="built_in">Wait</span>(timeMS);</span><br><span class="line">   <span class="comment">//遍历这些事件</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCnt; i++) &#123;</span><br><span class="line">       <span class="comment">/* 处理事件 */</span></span><br><span class="line">       <span class="type">int</span> fd = epoller_-&gt;<span class="built_in">GetEventFd</span>(i);</span><br><span class="line">       <span class="type">uint32_t</span> events = epoller_-&gt;<span class="built_in">GetEvents</span>(i);</span><br><span class="line">       <span class="comment">//如果是监听描述符    说明有监听进来</span></span><br><span class="line">       <span class="keyword">if</span>(fd == listenFd_) &#123;</span><br><span class="line">           <span class="built_in">DealListen_</span>();   <span class="comment">//处理事件监听</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//出现了错误   关闭文件描述符</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">           <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">           <span class="built_in">CloseConn_</span>(&amp;users_[fd]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//非监听文件描述符有事件    处理读操作</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLIN) &#123;</span><br><span class="line">           <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">           <span class="built_in">DealRead_</span>(&amp;users_[fd]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//处理写操作</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLOUT) &#123;</span><br><span class="line">           <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">           <span class="built_in">DealWrite_</span>(&amp;users_[fd]);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//关闭连接</span></span><br><span class="line">       	<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Unexpected event&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面就挑选个人感觉比较重要的 两个时间的处理代码。</p>
<h3 id="处理监听事件"><a href="#处理监听事件" class="headerlink" title="处理监听事件"></a>处理监听事件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    users_[fd].<span class="built_in">init</span>(fd, addr);</span><br><span class="line">    <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timer_-&gt;<span class="built_in">add</span>(fd, timeoutMS_, std::<span class="built_in">bind</span>(&amp;WebServer::CloseConn_, <span class="keyword">this</span>, &amp;users_[fd]));</span><br><span class="line">    &#125;</span><br><span class="line">    epoller_-&gt;<span class="built_in">AddFd</span>(fd, EPOLLIN | connEvent_);</span><br><span class="line">    <span class="built_in">SetFdNonblock</span>(fd);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] in!&quot;</span>, users_[fd].<span class="built_in">GetFd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealListen_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="comment">//超过最大数量 做相应处理 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HttpConn::userCount &gt;= MAX_FD) &#123;</span><br><span class="line">            <span class="built_in">SendError_</span>(fd, <span class="string">&quot;Server busy!&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Clients is full!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AddClient_</span>(fd, addr);<span class="comment">//添加客户端</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(listenEvent_ &amp; EPOLLET); <span class="comment">//如果是ET模式  就必须一次性把事件读完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理读写"><a href="#处理读写" class="headerlink" title="处理读写"></a>处理读写</h3><p>处理读写事件主要工作相当于将读数据的任务发布给线程池。经过了很多封装，这里面要去源码去层层查看理解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnWrite_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> readErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">read</span>(&amp;readErrno); <span class="comment">//读取客户端数据</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> &amp;&amp; readErrno != EAGAIN) &#123;</span><br><span class="line">        <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    <span class="built_in">OnProcess</span>(client);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> writeErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">write</span>(&amp;writeErrno);</span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">ToWriteBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 传输完成 */</span></span><br><span class="line">        <span class="keyword">if</span>(client-&gt;<span class="built_in">IsKeepAlive</span>()) &#123;</span><br><span class="line">            <span class="comment">//业务逻辑处理</span></span><br><span class="line">            <span class="built_in">OnProcess</span>(client);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(writeErrno == EAGAIN) &#123;</span><br><span class="line">            <span class="comment">/* 继续传输 */</span></span><br><span class="line">            epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="业务处理逻辑"><a href="#业务处理逻辑" class="headerlink" title="业务处理逻辑"></a>业务处理逻辑</h3><p>主要解释上部分处理读写事件中的<code>OnProcess</code>的，这部分代码 线程池里的子线程处理 。注意这里并不是真正的处理逻辑，真正的处理逻辑是<code>client-&gt;process()</code>，他的返回值为真的话，说明处理完一个用户请求了，该做出相应了所以可以看到监听描述符的时间是<code>EPOLLOUT</code>。当监听到TCP缓冲区不满也就是可写，就会开始写的任务。否则就还是处理读（监听读使事件）。注意这里的读写是对于TCP缓冲区而言。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnProcess</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果client-&gt;process()为真 则说明处理完请求，要做出相应 所以事件是EPOLLOUT</span></span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">process</span>()) &#123;</span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（待更新。。。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


      
    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my_avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawnlake</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
